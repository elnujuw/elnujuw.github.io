{"posts":[{"title":"ARM单片机STM32F103C8T6介绍","text":"STM32 STM32系列是STMicroelectronics半导体生产商生产的32位RISC ARM微控制器集成电路系列，下表总结了STM32微控制器系列。 STM32 Series ARM CPU Core L5 Cortex-M33F F7, H7 Cortex-M7F F3, F4, G4, L4, L4+, J Cortex-M4F F1, F2, L1, W, J Cortex-M3 G0, L0, J Cortex-M0+ F0, J Cortex-M0 STM32F1系列 STM32F1系列是第一批基于ARM Cortex-M3内核的STM32微控制器，被认为是它们的主流ARM微控制器。随着CPU速度，内部存储器大小和各种外围设备的发展，F1系列随着时间的推移而发展。这里我们介绍的是STM32F1系列的微控制器：STM32F103C8T6。 笔者购买的是STM32F103C8T6的核心板，使用CH340C实现USB转串口的调试接口，拥有64K FLASH和20K RAM，板载8M晶振/RTC晶振，和GPIO全部引出，非常方便进行学习和开发。","link":"/ARM%E5%8D%95%E7%89%87%E6%9C%BASTM32F103C8T6%E4%BB%8B%E7%BB%8D/"},{"title":"ERP5统一业务模型","text":"统一业务模型设计 ERP5统一业务模型用于ERP5中的会计，仓库管理，生产和人力资源管理。由于独立于特定业务流程的统一词汇表，为一个模块开发的所有功能都可以在其他模块中使用。ERP5的统一业务模型极大地缩短了学习曲线，并降低了多个模块上数据不一致的风险。 该模型基于五个抽象核心类： Resource：业务流程中的一种抽象资源，例如原材料，产品，货币或个人技能。 Node：可以接收和发送资源。它可以涉及诸如车间之类的实体，也可以涉及诸如银行账户之类的抽象实体。 Movement：描述了时间段内Resource在两个Node之间的移动。例如，一个Movement可能会将原材料从仓库发送到车间，或者将钱从一个帐户发送到另一个帐户。 Item：Resource的具体实物。一个Movement可以关联一系列可追溯的物件。比如Resource是人民币，Item则是流水号为xxx的纸币。 Path：定义了Node访问它可能需要的资源的方式。 例子 例子1假设一家公司A要向另一家公司B出售照相机。一旦双方同意，公司A将向公司B发送10台摄像机，单价为$100。在这种情况下，公司A和B被视为Node。产品（相机）是一种Resource。销售本身（以$1000订购10台摄像机）就是Movement。如果这些条件在这些公司之间达成一致，例如单价，则该条件为Path。如果公司A要跟踪摄像机，则可以为每个摄像机附加条形码，这将生成10个Item。 例子2假设一家公司A希望保留有关另一家公司B的电汇信息。公司B向公司A发送了$1000作为应收款。在这种情况下，应收帐款和银行帐户实际上是Node。从逻辑上讲，公司A和B也是Node。Movement是付款，金钱是Resource。 本例子未使用到Item和Path。 例子3假设公司A要用一家工厂的机械零件制造10台摄像机。在这种情况下，工厂是一个Node。摄像机和机械零件均可视为Resource。生产包括两个Movements，一个用于消耗零件，另一个用于生产相机。为了追溯，公司A可以在相机和零件上贴上标签，这些将成为Item。由原材料的消耗到成品的生产，这个过程称为Path。 个人看法ERP5的UBM模型高度抽象了ERP系统中几乎所有单据的数据模型，这个模型值得借鉴。 ERP5是基于Zope开发类似于Plone，但是nexedi把整个系统做得又长又臭（怀念5.4.6版本），其中还有不少的坑（可能是要收顾问费），整体感觉系统性能和体验都做得很拉跨。同样是开源的ERP ODOO能做得简单易用，作为一个开发者我更倾向于后者。 虽然ERP5系统做得很拉但是在系统设计方面还有很多很值得借鉴的地方，比如说ERP5的Simulation、Builder、Workflow等，我们会在以后的文章中再探讨。","link":"/ERP5%E7%BB%9F%E4%B8%80%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B/"},{"title":"CentOS7编译安装shadowsocks-libev + simple-obfs混淆","text":"安装前推荐系统先完成BBR的配置，配置方法可参考《如何在CentOS7上启用BBR提速》 安装shadowsocks-libev获取shadowsocks-libev源码 123git clone https://github.com/shadowsocks/shadowsocks-libev.gitcd shadowsocks-libevgit submodule update --init --recursive 安装基本构建依赖 1yum install gettext gcc autoconf libtool automake make asciidoc xmlto c-ares-devel libev-devel pcre-devel 安装libsodium 123456789export LIBSODIUM_VER=1.0.16wget https://download.libsodium.org/libsodium/releases/old/libsodium-$LIBSODIUM_VER.tar.gztar xvf libsodium-$LIBSODIUM_VER.tar.gzpushd libsodium-$LIBSODIUM_VER./configure --prefix=/usr &amp;&amp; makesudo make installpopdsudo ldconfig 安装MbedTLS 12345678export MBEDTLS_VER=2.6.0wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgztar xvf mbedtls-$MBEDTLS_VER-gpl.tgzpushd mbedtls-$MBEDTLS_VERmake SHARED=1 CFLAGS=-fPICsudo make DESTDIR=/usr installpopdsudo ldconfig 安装shadowsocks-libev 按照Shadowsocks-libev的README，在make时失败，解决方法https://github.com/shadowsocks/shadowsocks-libev/issues/1164#issuecomment-319578410安装过程如下： 123./autogen.sh./configure --with-sodium-include=/usr/include --with-sodium-lib=/usr/local/lib --with-mbedtls-include=/usr/include --with-mbedtls-lib=/usr/libmake &amp;&amp; make install 安装simple-obfs获取simple-obfs源码 123git clone https://github.com/shadowsocks/simple-obfs.gitcd simple-obfsgit submodule update --init --recursive 安装simple-obfs 123./autogen.sh./configuremake &amp;&amp; make install 配置shadowsocks-libev服务创建shadowsocks配置文件 12mkdir -p /etc/shadowsocks/touch /etc/shadowsocks/config.json 修改配置文件内容如下： 1234567891011{ &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;password&quot;, &quot;timeout&quot;:60, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;, &quot;user&quot;:&quot;daemon&quot;, &quot;plugin&quot;:&quot;obfs-server&quot;, &quot;plugin_opts&quot;:&quot;obfs=http;failover=example.com&quot;} 注意：需要修改password的内容。 创建shadowsocks启动脚本 12touch /etc/init.d/shadowsockschmod +x /etc/init.d/shadowsocks 修改脚本内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#!/usr/bin/env bash# chkconfig: 2345 90 10# description: A secure socks5 proxy, designed to protect your Internet traffic.### BEGIN INIT INFO# Provides: Shadowsocks-libev# Required-Start: $network $syslog# Required-Stop: $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Fast tunnel proxy that helps you bypass firewalls# Description: Start or stop the Shadowsocks-libev server### END INIT INFO# Author: Teddysun &lt;i@teddysun.com&gt;if [ -f /usr/local/bin/ss-server ]; then DAEMON=/usr/local/bin/ss-serverelif [ -f /usr/bin/ss-server ]; then DAEMON=/usr/bin/ss-serverfiNAME=Shadowsocks-libevCONF=/etc/shadowsocks/config.jsonPID_DIR=/var/runPID_FILE=$PID_DIR/shadowsocks.pidRET_VAL=0[ -x $DAEMON ] || exit 0if [ ! -d $PID_DIR ]; then mkdir -p $PID_DIR if [ $? -ne 0 ]; then echo &quot;Creating PID directory $PID_DIR failed&quot; exit 1 fifiif [ ! -f $CONF ]; then echo &quot;$NAME config file $CONF not found&quot; exit 1ficheck_running() { if [ -r $PID_FILE ]; then read PID &lt; $PID_FILE if [ -d &quot;/proc/$PID&quot; ]; then return 0 else rm -f $PID_FILE return 1 fi else return 2 fi}do_status() { check_running case $? in 0) echo &quot;$NAME (pid $PID) is running...&quot; ;; 1|2) echo &quot;$NAME is stopped&quot; RET_VAL=1 ;; esac}do_start() { if check_running; then echo &quot;$NAME (pid $PID) is already running...&quot; return 0 fi $DAEMON -uv -c $CONF -f $PID_FILE if check_running; then echo &quot;Starting $NAME success&quot; else echo &quot;Starting $NAME failed&quot; RET_VAL=1 fi}do_stop() { if check_running; then kill -9 $PID rm -f $PID_FILE echo &quot;Stopping $NAME success&quot; else echo &quot;$NAME is stopped&quot; RET_VAL=1 fi}do_restart() { do_stop do_start}case &quot;$1&quot; in start|stop|restart|status) do_$1 ;; *) echo &quot;Usage: $0 { start | stop | restart | status }&quot; RET_VAL=1 ;;esacexit $RET_VAL 配置shadowsocks开机启动 1chkconfig --add shadowsocks 启动shadowsocks 1/etc/init.d/shadowsocks start","link":"/CentOS7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85shadowsocks-libev-simple-obfs%E6%B7%B7%E6%B7%86/"},{"title":"ESP8266开发板NodeMcu开发-NodeMcu介绍","text":"NodeMcu简介NodeMcu是一款运行于乐鑫ESP8266芯片之中的可编程固件，是超简单的物联网开发平台。他以lua语言为基础，同时提供了封装ESP8266硬件操作的高级API，可以让开发者以类似于arduino的方式与底层硬件打交道，使软件开发人员轻松地操作设备；同时NodeMcu还提供了时间驱动型网络API， Nodejs风格的编程方式更是让互联网开发人员如鱼得水。 特点ESP8266对封装模块ESP12进行了扩展，包括了： D1~D10：均可服用位GPIO， PWM， I2C, 1-Wire A0：1路ADC USB供电 USB转串口调试接口 可用RAM位20Kbyte：目前采用4M Flash，用户可用存储空间150Kbyte。 NodeMcu开发板的价格非常便宜，某宝上一搜就能找到，笔者购买的是CP20102芯片USB转串口的开发板。","link":"/ESP8266%E5%BC%80%E5%8F%91%E6%9D%BFNodeMcu%E5%BC%80%E5%8F%91-NodeMcu%E4%BB%8B%E7%BB%8D/"},{"title":"ESP8266开发板NodeMcu开发-DHT11温湿度Web服务器","text":"本文介绍使用Arduino IDE开发一个显示温湿度的Web服务器DHT11温湿传感器，供局域网内的任何设备访问。在本教程中，我将展示如何构建异步Web服务器，该服务器自动更新温度和湿度，而无需刷新网页并使用自定义CSS设置网页样式。## DHT11DHT11是温湿传感器，产品参数如下： 内容 参数 湿度测量范围 20%~95%测量误差：±5% 温度测量范围 0~50℃测量误差：±2% 解析度 湿度0.1%，温度0.1℃ 工作电压 3V~5.5V DC 采样周期 1秒 连接DHT11 VCC接3V3，GND连地，DATA接GPIO5（D1）。 安装DHT库 打开Arduino IDE，项目 -&gt; 加载库 -&gt; 管理库； 搜索DHT，找到DHT sensor library by Adafruit并安装； 搜索Adafruit Unified Sensor，找到Adafruit Unified Sensor by Adafruit并安装； 安装完成后重启Arduino IDE。 安装异步Web服务库 要构建异步Web服务需要安装这两个库：ESPAsyncWebServer和ESPAsync TCP。 安装ESPAsyncWebServer库 下载安装ESPAsyncWebServer压缩文件； 解压后得到文件夹ESPAsyncWebServer-master； 重命名文件夹ESPAsyncWebServer-master为ESPAsyncWebServer； 复制文件夹到你的Arduino IDE的库文件夹，笔者的Arduino IDE的库文件夹为C:\\Users\\junle\\Documents\\Arduino\\libraries。 ESPAsync TCP库 下载安装ESPAsyncWebServer压缩文件； 解压后得到文件夹ESPAsyncTCP-master； 重命名文件夹ESPAsyncTCP-master为ESPAsyncTCP； 复制文件夹到你的Arduino IDE的库文件夹，笔者的Arduino IDE的库文件夹为C:\\Users\\junle\\Documents\\Arduino\\libraries。安装完成后重启Arduino IDE。 代码 打开您的Arduino IDE并复制以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;Arduino.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;Hash.h&gt;#include &lt;ESPAsyncTCP.h&gt;#include &lt;ESPAsyncWebServer.h&gt;#include &lt;Adafruit_Sensor.h&gt;#include &lt;DHT.h&gt;#define DHTPIN 5 //DHT数据Pin连接GPIO5#define DHTTYPE DHT11 //DHT 11const char* ssid = &quot;REPLACE_WITH_YOUR_SSID&quot;;const char* password = &quot;REPLACE_WITH_YOUR_PASSWORD&quot;;DHT dht(DHTPIN, DHTTYPE);float temperature = 0.0;float humidity = 0.0;AsyncWebServer server(80);unsigned long previousMillis = 0; // 记录DHT上次的采样时间const long interval = 10000; //每10秒读取一次DHT数据const char index_html[] PROGMEM = R&quot;rawliteral(&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.7.2/css/all.css&quot; integrity=&quot;sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;style&gt; html { font-family: Arial; display: inline-block; margin: 0px auto; text-align: center; } h2 { font-size: 3.0rem; } p { font-size: 3.0rem; } .units { font-size: 1.2rem; } .dht-labels{ font-size: 1.5rem; vertical-align:middle; padding-bottom: 15px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ESP8266 DHT Server&lt;/h2&gt; &lt;p&gt; &lt;i class=&quot;fas fa-thermometer-half&quot; style=&quot;color:#059e8a;&quot;&gt;&lt;/i&gt; &lt;span class=&quot;dht-labels&quot;&gt;Temperature&lt;/span&gt; &lt;span id=&quot;temperature&quot;&gt;%TEMPERATURE%&lt;/span&gt; &lt;sup class=&quot;units&quot;&gt;&amp;deg;C&lt;/sup&gt; &lt;/p&gt; &lt;p&gt; &lt;i class=&quot;fas fa-tint&quot; style=&quot;color:#00add6;&quot;&gt;&lt;/i&gt; &lt;span class=&quot;dht-labels&quot;&gt;Humidity&lt;/span&gt; &lt;span id=&quot;humidity&quot;&gt;%HUMIDITY%&lt;/span&gt; &lt;sup class=&quot;units&quot;&gt;%&lt;/sup&gt; &lt;/p&gt;&lt;/body&gt;&lt;script&gt;setInterval(function ( ) { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { document.getElementById(&quot;temperature&quot;).innerHTML = this.responseText; } }; xhttp.open(&quot;GET&quot;, &quot;/temperature&quot;, true); xhttp.send();}, 10000 ) ;setInterval(function ( ) { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { document.getElementById(&quot;humidity&quot;).innerHTML = this.responseText; } }; xhttp.open(&quot;GET&quot;, &quot;/humidity&quot;, true); xhttp.send();}, 10000 ) ;&lt;/script&gt;&lt;/html&gt;)rawliteral&quot;;// Replaces placeholder with DHT valuesString processor(const String&amp; var){ if(var == &quot;TEMPERATURE&quot;){ return String(temperature); } else if(var == &quot;HUMIDITY&quot;){ return String(humidity); } return String();}void setup(){ Serial.begin(115200); dht.begin(); //链接Wifi WiFi.begin(ssid, password); Serial.println(&quot;Connecting to WiFi&quot;); while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(&quot;.&quot;); } //打印IP Serial.println(WiFi.localIP()); server.on(&quot;/&quot;, HTTP_GET, [](AsyncWebServerRequest *request){ request-&gt;send_P(200, &quot;text/html&quot;, index_html, processor); }); server.on(&quot;/temperature&quot;, HTTP_GET, [](AsyncWebServerRequest *request){ request-&gt;send_P(200, &quot;text/plain&quot;, String(temperature).c_str()); }); server.on(&quot;/humidity&quot;, HTTP_GET, [](AsyncWebServerRequest *request){ request-&gt;send_P(200, &quot;text/plain&quot;, String(humidity).c_str()); }); //开启服务 server.begin();} void loop(){ unsigned long currentMillis = millis(); if (currentMillis - previousMillis &gt;= interval) { previousMillis = currentMillis; //读取温度 float newTemperature = dht.readTemperature(); if (isnan(newTemperature)) { Serial.println(&quot;Failed to read from DHT sensor!&quot;); } else { temperature = newTemperature; } //读取湿度 float newHumidity = dht.readHumidity(); if (isnan(newHumidity)) { Serial.println(&quot;Failed to read from DHT sensor!&quot;); } else { humidity = newHumidity; } }} 你还需要使用你所在的局域网的Wifi的ssid和密码代替以下内容： 12const char* ssid = &quot;REPLACE_WITH_YOUR_SSID&quot;;const char* password = &quot;REPLACE_WITH_YOUR_PASSWORD&quot;; 编译代码并下载到ESP8266 编译你的代码并下载到ESP8266开发板，打开串口监视器，程序启动并连接你的Wifi后将IP地址打印到监视器中；在浏览器中访问该IP即可。","link":"/ESP8266%E5%BC%80%E5%8F%91%E6%9D%BFNodeMcu%E5%BC%80%E5%8F%91-DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"ESP8266开发板NodeMcu开发-搭建Arduino IDE开发环境","text":"Arduino IDE是Arduino公司提供的集成开发软件，Arduino是一家制作开源硬件和开源软件的公司。Arduino是一套以Java编写的跨平台应用软件，使用与C语言和C++语言相仿的编程语言开发，主要针对Arduino系列的开发板编程。 本文介绍通过简单的配置可以在Arduino IDE中添加对ESP8266开发板的支持。 安装Arduino IDE 到官方网站下载页面下载Arduino IDE(建议下载最新版本)，选择Windows Installer, for Windows 7 and up (建议下载Installer版本); Installer版本请开启安装档，依照步骤安装；ZIP版本直接解压缩即可使用; 添加ESP8266支持Arduino IDE安装完成后，打开软件 文件 -&gt; 首选项 的设置页面，在附加开发板管理器网站中添加以下URL： 1https://arduino.esp8266.com/stable/package_esp8266com_index.json 打开 工具 -&gt; 开发板: “xxxx” -&gt; 开发板管理器… 等待下载平台索引，搜索中输入 ESP8266 找到ESP8266并安装。安装完成后重启Arduino IDE软件，在 工具 -&gt; 开发板 选项中即可看到ESP8266开发板选项：对于笔者购买的开发板这里选择的是 NodeMCU 1.0 (ESP-12E Module) 。至此ESP8266开发板的Arduino IDE开发环境搭建完成。","link":"/ESP8266%E5%BC%80%E5%8F%91%E6%9D%BFNodeMcu%E5%BC%80%E5%8F%91-%E6%90%AD%E5%BB%BAArduino-IDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"MySQL explain学习笔记","text":"explain用法查询居民id为“004386f02b6511e8ad1300163e08fb5b”的居民所在的部门信息： 123explain select department.* from department,westation,citizenwhere department.id = westation.department_id and westation.id = citizen.westation_idand citizen.id=&quot;004386f02b6511e8ad1300163e08fb5b&quot; id select_type table type possible_key key key_len ref rows Extra 1 SIMPLE citizen const PRIMARY,FK_Citizen_Westation PRIMARY 128 const 1 1 SIMPLE westation const PRIMARY,department_id,FK_deparment_westation PRIMARY 128 const 1 1 SIMPLE department const PRIMARY PRIMARY 128 const 1 各列的含义： id：查询id，id相同的从上往下顺序执行；id不同的，值越大越先执行；id有相同和不相同的，综合前两种，值大的先执行，相同的顺序执行。 select_type：查询类型 PRIMARY：包含子查询SQL中的主查询（最外层） SUBQUERY：包含子查询SQL中的子查询（非最外层） simple：简单查询（不包含子查询、union） derived：衍生查询（使用到了临时表） a. 在from子查询中有一张表 b. 在from子查询中如果有table1 union table2，则table1就是derived，table2就是union type：索引类型，常见索引类型从快到慢排序：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all system：只有一条数据的系统表或衍生表只有一条数据的主查询 const：仅仅能查到一条数据的SQL，用于Primary Key或unique索引（与索引类型有关） eq_ref：唯一性索引，对于每个索引键的查询，返回匹配唯一行数据（有且只有一条，不能多，不能为0），常见于唯一索引和主键索引 ref：与eq_ref一样，对于每个索引键的查询，返回匹配的所有行数据（不唯一） range：使用一个索引检索给定范围的行 index： 索引树遍历 all：全表遍历 possible_key：可以使用的索引 key：实际使用的索引 key_len：索引中使用的字节数 ref：列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows：估算出结果集行数 Extra：详细信息 Using where：用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤 ing temporary：示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by ing filesort：Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”","link":"/MySQL-explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Odoo14 systemd service模板","text":"Odoo14 systemd service 模板 12345678910111213141516[Unit]Description=odoo14Requires=postgresql.serviceAfter=network.target postgresql.service[Service]Type=simpleSyslogIdentifier=odoo14PermissionsStartOnly=trueUser=your_userGroup=your_userExecStart=/your/python/path/python3 /your/odoo/path/odoo-bin -c /your/odoo/config/path/odoo.configStandardOutput=journal+console[Install]WantedBy=multi-user.target","link":"/Odoo14-systemd-service%E6%A8%A1%E6%9D%BF/"},{"title":"Odoo14开发者指南第一章-安装Odoo开发环境【翻译】","text":"有几种方法可以建立Odoo开发环境。 本章提出其中一个。您肯定会在网络上找到许多其他教程，这些教程介绍了其他方法。请记住，本章是关于与生产环境有不同要求的开发环境。 如果您不熟悉Odoo开发，则必须了解Odoo生态系统的某些方面。第一个Recipe将为您简要介绍Odoo生态系统，然后我们将继续进行Odoo的安装以进行开发。 在本章中，我们将介绍以下Recipe： 了解Odoo生态系统 从源代码轻松安装Odoo 管理Odoo服务器数据库 将实例配置存储在文件中 激活Odoo开发者工具和更新附加模块列表 了解Odoo生态系统Odoo为开发人员提供了现成的模块化。 它强大的框架可帮助开发人员快速构建项目。 在开始成为一名成功的Odoo开发人员之前，您应该熟悉Odoo生态系统中的各种角色。 Odoo版本Odoo带有两个不同的版本。第一个是开源的社区版，第二个是具有许可费的企业版。与其他软件供应商不同，Odoo企业版只是一堆额外的应用程序，它们为社区版添加了额外的功能或新的应用程序。基本上，企业版在社区版之上运行。社区版已获得Lesser General Public License v3.0 (LGPLv3) 许可证，并随附所有基本的企业资源计划（ERP）应用程序，例如销售，客户关系管理（CRM），发票，购买和网站构建器 。另外，企业版附带Odoo企业版许可证，这是专有许可证。Odoo企业版具有许多高级功能，例如完整记帐，工作室，互联网协议语音（VoIP），移动响应设计，电子签名，营销自动化，交付和银行集成，IoT等。企业版还为您提供了无限的错误修复支持。下图显示了企业版取决于社区版，这就是为什么您需要后者才能使用前者的原因： 您可以在这里看到两个版本的完整比较：https://www.odoo.com/page/editions. Odoo拥有最多的社区开发人员，这就是为什么您会在应用商店中找到大量第三方应用（模块）的原因。一些免费应用程序使用**Affero General Public License version 3 (AGPLv3)**。如果您的应用程序对此类应用程序有依赖性，则不能在该应用程序上使用专有许可证。具有Odoo专有许可证的应用程序只能在具有LGPL或其他专有许可证的模块上开发。 Git存储库Odoo的整个代码库都托管在GitHub上。您可以在此处发布稳定版本的错误/问题。您还可以通过提交拉取请求（PR）提出新功能。Odoo中有几个存储库。有关更多信息，请参见下表： Repositories 仓库用途 https://github.com/odoo/odoo Odoo社区版，对公众开放。 https://github.com/odoo/enterprise Odoo企业版，仅对Odoo的合作伙伴开放。 https://github.com/odoo-dev/odoo 开发中的仓库，对公众开放。（已废弃） 每年，Odoo都会发布一个主要（长期支持（LTS））版本和一些次要版本。 次版本主要用于Odoo的在线SaaS服务，这意味着Odoo SaaS用户可以尽早使用这些功能。在GitHub上，主要版本分支的名称为14.0、13.0和12.0，次要版本分支的名称为saas-14.1和saas-14.2。这些次要版本主要用于Odoo的SaaS平台。master分支正在开发中并且不稳定，因此建议不要将此分支用于生产中，因为它可能会破坏数据库。 RunbotRunbot是Odoo的自动化测试环境。每当Odoo的GitHub分支中有新的提交时，Runbot都会提取这些最新更改并为最后四个提交创建构建测试环境。在这里，您可以测试所有稳定和未开发的分支。您甚至可以使用企业版及其开发分支。每个内部版本都有不同的背景颜色，用于指示测试用例的状态： 绿色的背景色表示所有测试用例都可以成功运行，并且您可以测试该分支； 红色的背景色则表示该分支上的某些测试用例已失败，并且某些功能可能在该版本上被破坏。 您可以查看所有测试用例的日志，准确显示安装过程中发生的情况。每个版本都有两个数据库。全部数据库已安装所有模块，而基础数据库仅已安装基本Odoo模块。每个版本都安装了基本的演示数据，因此您无需额外配置即可快速对其进行测试。 你可以通过http://runbot.odoo.com/runbot链接访问Runbot，以下凭证可用于访问任何Runbot构建的测试环境： Login ID: admin Password: admin Login ID: demo Password: demo Login ID: portal Password: portal 这是一个公共测试环境，因此有时其他用户可能正在使用/测试您正在测试的同一分支。 Odoo app store几年前，Odoo推出了应用程序商店，这立刻引起了轰动。 目前，这里托管了22,000多种不同的应用程序。 在应用商店中，您会找到许多针对不同版本的免费和付费应用。 这包括针对不同业务领域的特定解决方案，例如教育，食品工业和医学。 它还包括可扩展或向现有Odoo应用程序添加新功能的应用程序。 该应用程序商店还为Odoo网站构建者提供了许多精美的主题。 在第三章，创建Odoo附加模块中，我们将研究如何为自定义模块设置价格和货币。 您可以通过以下URL访问Odoo应用商店： https://www.odoo.com/apps 您可以通过以下URL访问Odoo主题： https://apps.odoo.com/apps/themes Odoo已开源了13版和14版的几个主题。请注意，这些主题是以前版本中的付费主题。 这意味着，在Odoo 13和14版本中，您可以免费下载和使用这些精美的主题。 Odoo社区协会（OCA）Odoo Community Association (OCA) 是一个非营利性组织，开发/管理基于社区的Odoo模块。所有OCA模块都是开源的，由Odoo社区成员维护。在OCA的GitHub帐户下，您可以找到用于不同Odoo应用程序的多个存储库。 除了Odoo模块之外，它还包含各种工具，迁移库，会计本地化等等。 这是OCA的官方GitHub帐户的URL：https://github.com/OCA。 官方Odoo帮助论坛Odoo具有非常强大的框架，仅通过使用/激活选项或遵循特定的模式就可以完成很多事情。因此，如果您遇到一些技术问题或不确定某些复杂情况，可以将查询发布到Odoo的官方帮助论坛上。许多开发人员都在这个论坛上很活跃，其中包括Odoo的一些正式员工。 您可以在以下URL搜索问题或发布新问题：https://help.odoo.com.help.odoo.com。 Odoo的eLearning 学习平台最近，Odoo启动了一个新的电子学习平台。 这个平台上有很多视频，解释了如何使用不同的Odoo应用程序。 在撰写本书时，该平台没有技术视频，而只是功能视频。 这是Odoo电子学习平台的URL：https://www.odoo.com/slides。 从源代码轻松安装Odoo强烈建议使用Linux Ubuntu操作系统来安装Odoo，因为除了大多数Odoo开发人员还使用Odoo进行所有测试、调试和安装外，Odoo还是使用该操作系统。使用GNU / Linux发行版，并且比Windows或macOS更容易获得Odoo社区对GNU / Linux中发生的OS级问题的支持。 还建议使用与生产环境相同的环境（相同的发行版和相同的版本）开发Odoo附加模块。这将避免令人讨厌的意外情况，例如在部署当天发现库具有比预期不同的版本，并且行为略有不同和不兼容的情况。如果您的工作站使用的是其他操作系统，则一种好的方法是在您的工作站上设置虚拟机（VM），然后在该VM中安装GNU / Linux发行版。 Ubuntu是Microsoft Store中的一个应用程序，因此，如果您不想切换到Ubuntu OS，也可以使用它。 对于这本书，我们将使用Ubuntu Server 18.04 LTS，但您可以使用任何其他Debian GNU / Linux OS。无论选择哪种Linux发行版，都应该对如何从命令行使用它有所了解，并且了解系统管理当然不会有任何危害。 做好准备我们假设您已启动并运行Ubuntu 18.04，并且您具有具有root用户访问权限的帐户或已配置sudo。 在以下各节中，我们将安装Odoo的依赖项并从GitHub下载Odoo的源代码。 有些配置需要系统登录用户名，因此只要命令行中需要登录用户名，我们都会使用$(whoami)。 这是一个shell命令，它将代替您在键入的命令中的登录名。 如果您拥有GitHub帐户，某些操作肯定会更容易。如果您还没有，请访问https://github.com并创建一个。 怎么做…要从源代码安装Odoo，请执行以下步骤： 运行以下命令以安装主要依赖项： 12$ sudo apt-get update$ sudo apt install git python3-pip build-essential wget python3-dev python3-venv python3-wheel libxslt-dev libzip-dev libldap2-dev libsasl2-dev python3-setuptools libpng-dev libjpeg-dev gdebi -y 下载和安装wkhtmltopdf: 12$ wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.bionic_amd64.deb$ sudo dpkg -i wkhtmltox_0.12.5-1.bionic_amd64.deb 如果在上一个命令中发现错误，请使用以下命令强制安装依赖项： 1$ sudo apt-get install -f 现在，安装PostgreSQL数据库： 1$ sudo apt install postgresql -y 配置PostgreSQL数据库： 1$ sudo -u postgres createuser --superuser $(whoami) 配置git： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email youremail@example.com 克隆Odoo代码： 123$ mkdir ~/odoo-dev$ cd ~/odoo-dev$ git clone -b 14.0 --single-branch --depth 1 https://github.com/odoo/odoo.git 创建odoo-14虚拟环境并激活： 12$ python3 -m venv ~/venv-odoo-14.0$ source ~/venv-odoo-14.0/bin/activate 在虚拟环境中安装Odoo的Python依赖： 12$ cd ~/odoo-dev/odoo/$ pip3 install -r requirements.txt 创建和开启你的Odoo实例： 12$ createdb odoo-test$ python3 odoo-bin -d odoo-test –i base --addons-path=addons --dbfilter=odoo-test$ 在浏览器中访问http://localhost:8069并通过使用admin帐户并使用admin作为密码对它进行身份验证。 如果需要RTL支持，请通过以下命令安装node和rtlcss： 12$ sudo apt-get install nodejs npm -y $ sudo npm install -g rtlcss 怎么运行的…在第1步中，我们安装了几个核心依赖项。 这些依赖项包括各种工具，例如git，pip3，wget，Python设置工具等。 这些核心工具将帮助我们使用简单的命令安装其他Odoo依赖项。 在第2步中，我们下载并安装了wkhtmltopdf软件包，该软件包在Odoo中用于打印PDF文档，例如销售订单，发票和其他报告。Odoo 14.0需要wkhtmltopdf的0.12.5版本，并且可能不包括该版本 在当前的Linux发行版中。对于我们来说幸运的是，wkhtmltopdf的维护者在http://wkhtmltopdf.org/downloads.html上为各种发行版提供预构建的软件包，我们已经从该URL下载并安装了该软件包。 PostgreSQL的配置在第3步中，我们安装了PostgreSQL数据库。 在第4步中，我们使用系统的登录名创建了一个新的数据库用户。$(whoami)用于获取您的登录名，-s选项用于提供超级用户权限。 让我们看看为什么我们需要这些配置。 Odoo使用psycopg2 Python库连接PostgreSQL数据库。要使用psycopg2库访问PostgreSQL数据库，Odoo默认使用以下值： 默认情况下，psycopg2尝试使用与本地连接上的当前用户相同的用户名连接到数据库，这将启用无密码身份验证（这对开发环境很有用）。 本地连接使用Unix域套接字。 数据库服务器在端口5432上侦听。 现在您的PostgreSQL数据库已准备就绪，可以与Odoo连接。 由于这是开发服务器，因此我们已向用户授予--superuser权限。可以给PostgreSQL用户更多的权限，因为这将是您的开发实例。对于生产实例，可以使用--createdb命令行而不是--superuser来限制权限。生产服务器中使用--superuser权限将被攻击者利用在已部署的代码的某些部分中的漏洞提供额外的杠杆作用。 如果要使用具有不同登录名的数据库用户，则需要提供该用户的密码。这是通过在创建用户时在命令行上传递--pwprompt标志来完成的，在这种情况下，该命令将提示您输入密码。 如果已经创建了用户，并且想要设置密码（或修改忘记的密码），则可以使用以下命令： 1$ psql -c &quot;alter role $(whoami) with password 'newpassword'&quot; 如果此命令失败，并显示一条错误消息，指出该数据库不存在，那是因为您没有在本Recipe的第4步中创建以登录名命名的数据库。没关系，只需添加--dbname选项和现有数据库名称即可，例如--dbname template1。 Git的配置对于开发环境，我们使用源自GitHub的Odoo。 使用git，您可以轻松地在不同的Odoo版本之间切换。 另外，您可以使用git pull命令获取最新更改。 在第5步中，我们配置了您的git用户。 在第6步中，我们从Odoo的官方GitHub存储库下载了源代码。 我们已经使用git clone命令下载Odoo的源代码。 我们只使用了一个分支，因为我们只想要14.0版本的分支。 另外，我们使用--depth 1来避免下载分支的完整提交历史记录。 这些选项将非常快速地下载源代码，但是如果需要，您可以省略这些选项。 Odoo开发人员还建议每晚进行构建，这些构建可以作为tarball和发行包使用。使用git clone的主要优点是，当在源树中提交新的错误修复程序时，您将能够更新您的存储库。您还可以轻松测试任何建议的修复程序并跟踪回归，从而可以使错误报告更加准确并对开发人员有所帮助。 如果您有权访问企业版源代码，也可以在~/odoo-dev目录下的单独文件夹中下载该源代码。 虚拟环境Python虚拟环境（简称venv）是隔离的Python工作区。 这些对Python开发人员非常有用，因为它们允许安装具有不同版本的各种Python库的不同工作区，并且可能安装在不同的Python解释器版本上。 您可以使用python3 -m venv ~/newvenv命令创建任意数量的环境。这将在指定位置创建一个newvenv目录，其中包含bin/子目录和lib/python3.6子目录。 在第7步中，我们在~/venv-odoo-14.0目录中创建了一个新的虚拟环境。这将是我们隔离的Odoo Python环境，所有Odoo的Python依赖项都将安装在此环境中。 要激活虚拟环境，我们需要使用source命令。使用source ~/venv-odoo-14.0/bin/activate命令，我们已经激活了虚拟环境。 安装Python包Odoo源代码的requirements.txt文件中列出了Python依赖项。在第8步中，我们通过pip3 install命令安装了所有这些要求。 至此，您可以运行Odoo实例。 开启实例现在到了您一直在等待的时刻。要启动我们的第一个实例，在步骤9中，我们首先创建一个新的空数据库，使用odoo-bin脚本，然后使用以下命令启动Odoo实例： 1python3 odoo-bin -d odoo-test -i base --addons-path=addons --db-filter=odootest$ 您也可以在odoo-bin之前使用./来省略python3，因为它是可执行的Python脚本，如下所示： 1./odoo-bin -d odoo-test –i base --addons-path=addons --db-filter=odoo-test$ 对于odoo-bin，将使用具有以下命令行参数的脚本： -d database_name：默认情况下使用此数据库。 --db-filter=database_name$：仅尝试连接到与提供的正则表达式匹配的数据库。一个Odoo安装可以为位于单独数据库中的多个实例提供服务，并且此参数限制了可用数据库。尾随的$很重要，因为正则表达式用于匹配模式。 这样可以避免选择以指定字符串开头的名称。 --addons-path=directory1,directory2,...：这是逗号分隔的目录列表，Odoo将在这些目录中查找附加组件。在实例创建时将扫描此列表，以填充实例中可用的附加模块的列表。如果要使用Odoo的企业版，请使用此选项添加其目录。 -i base: 这用于安装基本模块。通过命令行创建数据库时，这是必需的。 如果您使用的数据库用户的登录名与Linux登录名不同，则需要传递以下附加参数： --db_host=localhost: 使用与数据库服务器的TCP连接。 --db_user=database_username: 使用指定的数据库登录名。 --db_password=database_password: 这是用于对PostgreSQL服务器进行身份验证的密码。 要获得所有可用选项的概述，请使用--help参数。 我们将在本章后面看到更多的odoo-bin脚本。 在空数据库上启动Odoo时，它将首先创建支持其操作所需的数据库结构。它还将扫描加载项路径以找到可用的加载项模块，并将其插入数据库的初始记录中。这包括具有默认管理员密码的admin用户，您将使用该密码进行身份验证。 在浏览器中访问http://localhost:8069会将您带到新创建的实例的登录页面，如以下屏幕截图所示： 这是由于Odoo包含了HTTP服务器。默认情况下，它在TCP端口8069上侦听所有本地网络接口。 管理Odoo服务器数据库使用Odoo时，实例中的所有数据都存储在PostgreSQL数据库中。您可以使用所有常用的标准数据库管理工具，但是Odoo还建议使用Web界面进行一些常见操作。 我们假设您的工作环境已建立并且您正在运行一个实例。 怎么做…Odoo数据库管理界面提供了用于创建，复制，删除，备份和还原数据库的工具。 还有一种更改主密码的方法，该密码用于保护对数据库管理界面的访问。 访问数据库管理界面要访问数据库，请执行以下步骤： 转到实例的登录屏幕（如果已通过身份验证，请注销）。 单击Manage Databases链接。 这将导航到http://localhost:8069/web/database/manager（您也可以将浏览器直接指向该URL）： 设置或更改主密码如果您已经为实例设置了默认值并且尚未修改它，正如我们将在下一节中说明的那样，数据库管理屏幕将显示一条警告，告诉您尚未设置master password，并且将 建议您设置一个直接链接： 要设置master password，请执行以下步骤： 单击Set Master Password按钮。 您将看到一个对话框，要求您填写New Master Password字段： 输入新密码然后单击继续。 如果已经设置了主密码，请单击屏幕底部的Set Master Password按钮进行更改。在显示的对话框中，键入以前的主密码和新的主密码，然后单击Continue。 主密码是服务器配置文件的admin_password的值。如果在未指定配置文件的情况下启动服务器，则会在~/.odoorc中生成一个新的密码。有关该配置文件的更多信息，请参考下一个Recipe。 新建一个新的数据库此对话框可用于创建将由当前Odoo服务器处理的新数据库实例： 在数据库管理窗口中，单击Create Database按钮，该按钮可在屏幕底部找到。这将弹出以下对话框： 填写表格，如下所示： Master Password：这是此实例的Master Password。 Database Name：输入要创建的数据库的名称。 Email：在此处添加您的电子邮件地址； 以后将用作您的用户名。 Password：输入您要为新实例的管理员用户设置的密码。 Phone Number：设置电话号码（可选）。 Language：选择默认情况下要安装的语言下拉列表中的新数据库。Odoo将自动加载所选语言的翻译。 Country：在下拉菜单中选择主要公司的国家列表。 选择此项将自动配置一些东西，包括公司币种。 Demo data：选中此框可获得演示数据。 这对于运行交互式测试或为客户设置演示很有用，但不应检查旨在包含生产数据的数据库。 如果您希望使用数据库来运行模块的自动化测试（请参阅第7章，调试模块），则需要具有演示数据，因为Odoo中的绝大多数自动化测试都依赖于这些记录，以便运行成功。 单击Continue按钮，等待一段时间，直到新数据库被初始化。然后，您将被重定向到实例并以管理员身份连接。 故障排除 如果将您重定向到登录屏幕，这可能是因为--db-filter选项已传递给Odoo且新的数据库名称与新的数据库名称不匹配。请注意，odoo-bin start命令以静默方式执行此操作，仅使当前数据库可用。要解决此问题，只需在不使用start命令的情况下重新启动Odoo，如本章从源代码轻松安装Odoo所示。如果有配置文件（请参阅本章后面的在文件配方中存储实例配置），然后检查db_filter选项是否未设置或设置为与新数据库名称匹配的值。 复制数据库通常您将拥有一个现有的数据库，并且您想尝试使用该数据库尝试一个过程或运行一个测试，而无需修改现有的数据。这里的解决方案很简单：复制数据库并在副本上运行测试。根据需要重复多次： 在数据库管理屏幕中，单击要克隆的数据库名称旁边的Duplicate Database链接： 填写以下表格： Master Password: 这是Odoo服务器的主密码。 New Name: 您要赋予副本的名称。 点击Continue按钮。 然后您可以在数据库管理屏幕中单击新创建的数据库的名称，以访问该数据库的登录屏幕。 删除数据库完成测试后，您将需要清理重复的数据库。为此，请执行以下步骤： 在数据库管理屏幕中，您将在数据库名称旁边找到Delete按钮。点击它会弹出如下对话框： 填写表格并填写Master Password字段，这是Odoo服务器的主密码。 单击Delete按钮。 警告！ 潜在的数据丢失！如果您选择了错误的数据库并且没有备份，则无法恢复丢失的数据。 备份数据库要创建备份，请执行以下步骤： 在数据库管理屏幕中，您将在数据库名称旁边找到“备份”按钮。单击它会弹出对话框，如以下屏幕截图所示： 填写表格，如下所示： Master Password：这是Odoo服务器的主密码。 Backup Format：始终对生产数据库使用zip，因为这是唯一真正的完整备份格式。仅当您不太在乎文件存储时，才使用pg_dump的格式，pg_dump格式仅用在开发数据库。 点击Backup按钮，备份文件随后将下载到您的浏览器中。 恢复数据库备份如果需要还原备份，则需要执行以下操作： 在数据库管理屏幕中，您将在屏幕底部找到一个Restore Database按钮。单击它会弹出一个对话框，如以下屏幕截图所示： 填写表格，如下所示： Master Password：这是Odoo服务器的主密码。 File：这是之前下载的Odoo备份。 Database Name：提供将在其中还原备份的数据库的名称。 该数据库不得存在于服务器上。 This database might have been moved or copied： 如果原始数据库位于另一台服务器上，或者已从当前服务器中删除，请选择“此数据库已移动”。否则，选择“此数据库是副本”，这是安全的默认选项。 点击Continue按钮 如果尝试执行此操作，收到一条错误消息（数据库还原错误：数据库已存在）。您需要先删除该数据库。 怎么运行的…以上功能除了设置和更改主密码外，另外的功能还可以在服务器上运行PostgreSQL管理命令来实现。 主密码是非常重要的一条信息，它仅存在于Odoo服务器配置文件中，并且永远不会存储在数据库中。过去曾经是默认值admin，但是使用此值是有风险的， 在Odoo v9及更高版本中，此密码被标识为未设置的主密码，并且在访问数据库管理界面时敦促您对其进行更改。即使将其存储在admin_passwd条目下的配置文件中，这与管理员用户的密码不同；这是两个独立的密码。主密码是为Odoo服务器进程设置的，该进程本身可以处理多个数据库实例，每个实例都有一个具有自己密码的独立管理员用户。 安全注意事项 请记住，在本章中我们正在考虑开发环境。在生产服务器上工作时，必须保护Odoo数据库管理界面，因为它可以访问很多敏感信息，尤其是在服务器托管Odoo的情况下。 几个不同客户端的实例。 要创建新数据库，Odoo使用PostgreSQL createdb实用程序并调用内部Odoo函数来初始化新数据库，其方式与在空数据库上启动Odoo时相同。 为了复制数据库，Odoo使用createdb的--template选项，将原始数据库作为参数传递，这实质上是使用内部和优化的PostgreSQL例程在新数据库中复制模板数据库的结构，这比创建一个 备份和还原（特别是在使用Web界面时，这需要下载备份文件并再次上传）。 备份和还原操作分别使用pg_dump和pg_restore实用程序。当使用zip格式时，备份还包括文件存储的副本，当您将Odoo配置为不将这些文件保留在数据库中时，备份还将包括文件存储的副本，其中包含文件的副本，这在14.0中是默认的选项。除非您进行更改，否则这些文件位于~/.local/share/Odoo/filestore中。 如果备份变大，则下载可能会失败。这是因为Odoo服务器本身无法处理内存中的大文件，或者是因为该服务器在反向代理之后运行，因为HTTP响应的大小受到限制。相反，出于相同的原因，您可能会遇到数据库还原操作方面的问题。当您开始遇到这些问题时，是时候投资购买更强大的外部备份解决方案了。 还有更多…经验丰富的Odoo开发人员通常不使用数据库管理界面管理数据库，而是从命令行执行操作。例如，要使用演示数据初始化新数据库，可以使用以下单行命令： 1$ createdb testdb &amp;&amp; odoo-bin -d testdb 此命令行的额外用法是，您可以在使用时请求安装附加组件，例如，-i sale,purchase,stock。 要复制数据库，请停止服务器并运行以下命令： 123$ createdb -T dbname newdbname$ cd ~/.local/share/Odoo/filestore # 修改为你的备份文件目录$ cp -r dbname newdbname 仅当数据库上没有活动会话时才使用createdb -T，这意味着您必须在从命令行复制数据库之前关闭Odoo服务器。 要删除实例，请运行以下命令： 12$ dropdb dbname$ rm -rf ~/.local/share/Odoo/filestore/dbname 要创建备份（假设PostgreSQL服务器在本地运行），请使用以下命令： 12$ pg_dump -Fc -f dbname.dump dbname$ tar cjf dbname.tgz dbname.dump ~/.local/share/Odoo/filestore/dbname 要还原备份，请运行以下命令： 12$ tar xf dbname.tgz$ pg_restore -C -d dbname dbname.dump 警告！ 如果您的Odoo实例使用其他用户连接到数据库，则需要传递-U用户名，以便正确的用户是还原的数据库的所有者。 将实例配置存储在文件中odoo-bin脚本有很多选项，记住所有这些以及在启动服务器时记住正确设置它们是很乏味的，幸运的是，可以将它们全部存储在配置文件中并仅通过 递给您想要更改的内容，例如用于开发。 怎么做…对于此Recipe，请执行以下步骤： 要为您的Odoo实例生成配置文件，请运行以下命令： 1$ ./odoo-bin --save --config myodoo.cfg --stop-after-init 您可以添加其他选项，它们的值将保存在生成的文件中。所有未设置的选项将以其默认值设置保存。要获取可能选项的列表，请使用以下命令： 1$ ./odoo-bin --help | less 这将为您提供有关各种选项执行效果的帮助。 要将命令行形式转换为配置形式，请使用选项名称，删除前导破折号，然后将中间的破折号转换为下划线。例如--without-demo更改为without_demo。这适用于大多数选项 ，但有一些例外情况，将在下一节中列出。 编辑myodoo.cfg文件（使用下一节中的表获取您可能要更改的一些参数），然后使用保存的选项启动服务器，运行以下命令： 1$ ./odoo-bin -c myodoo.cfg --config选项通常缩写为-c。 怎么运行的…在启动时，Odoo会分三遍加载其配置；首先从源代码初始化所有选项的一组默认值，然后解析配置，如果文件中定义了相同的值都将覆盖默认值。 如前所述，选项的名称可以通过删除前导破折号并将中间的破折号转换为下划线来使用，但有一些例外情况，尤其是以下内容： Comand line Configuration file --db-filter dbfilter --no-http http_enable=True/False –database db_name --dev dev_mode --i18n-import / --i18n-export Unavailable 这是通过配置文件通常设置的选项列表： Options Format Usage without_demo Comma-separated list of module names This prevents module data from being loaded. Give the value all to disable demo data fro all modules, or False to enable demo data for all modules. To disable demo data for specific modules, provide module names, for example, sale,purchase,crm. addons_path Comma-separated list of paths This is a list of directory name in which the server will look for add-ons. admin_passwd Text This is the master password(take a look at the preceding recipe). data_dir Path to a directory This is a directory in which the server will store session information, add-ons downloaded from the internet, and documents if you enable the file store. http_portlongpolling_port Port number These are the ports on which the Odoo server will listen. You will need to specify booth to run multiple Odoo servers on the same host; longpolling_port is only used if workers is not 0. http_port defaults to 8069, and longpolling_port defaults to 8072. logfile Path to a file The file in which Odoo will write its logs. log_level Log verbosity level Specifies the level of logging. Accepted values(in increasing order of verbosity) include critecal,error,warn,debug_rpc_answer,debug_sql. workers Integer The number of worker processes. Refer to Chapter 3, Server Deployment, for more information. proxy_mode True/False Activate reverse proxy WSGI wrappers. Only enable this when running behind a trusted web proxy! 以下是与数据库相关的配置选项的列表： Options Format Usage db_host Hostname This is the name of the server running the PostgreSQL server. Use False to use local Unix domain sockets, and localhost to user TCP sockets locally. db_user Database user login This is generally empty if db_host is False. This will be the name of the user used to connect to the database. db_password Database user password This is generally empty if db_host is False and whendb_user has the same name as the user running the server. Read the main page of pg_hba.conf for more information on this. db_name Database name This is used to set the database name on which some commands operate by default. This does not limit the databases on which the server will act. Refer to the following dbfilter option for this. db_sslmode Database SSL mode This is used to specify the database SSL connection mode. dbfilter A regular expression The Expression should match the mane of the databases that are considered by the server. If you run the website, it should match a single database, so it will look like ^databasename$. More information on this can be found in Chapter 3, Server Deployment. list_db True/False Set to True to disable the listing of databases. See Chapter 3, Server Deployment, for more information. Odoo现在使用Python ConfigParser模块来解析配置文件。但是，Odoo 11.0中的实现已更改，并且不再可以使用变量插值，因此，如果习惯于使用%(section.variable)s表示法从其他变量的值中定义变量的值，则将需要改变您的习惯并恢复为明确的价值观。 某些选项未在配置文件中使用，但在开发过程中被广泛使用： Option Format Usage -i or --init Comma-separated list of module name It will install given modules by default while initializing the database. -u or --update Comma-separated list of module names It will update given modules when you restart the server. It is mostly used when you modify source code or update the branch from git. --dev all, reload, qweb, werkzeug and xml This enables developer mode and the auto-reload feature. 激活Odoo开发者模式工具当使用Odoo开发时，您需要知道如何在Web界面中激活开发者模式，以便可以访问技术设置菜单和开发人员信息。启用调试模式将暴露一些高级配置选项和字段，这些选项和字段是 隐藏在Odoo中以提高可用性，因为它们不是常用的。 怎么做…要在Web界面激活开发者模式，请执行以下步骤： 使用管理员账号登录你的Odoo实例。 进入设置菜单。 滚动到页面底部的Developer Tools部分： 点击Activate the developer mode链接。 等待页面刷新。 另外的方法 你也可以通过编辑URL激活开发人员模式。 在**#**号之前，插入?debug=1。例如，如果您当前的URL是http://localhost:8069/web#menu_id=102&amp;action=94，并且您要启用开发人员模式，则需要将该URL更改为http://localhost:8069/web?debug=1#menu_id=102&amp;action=94。此外，如果要使用资产调试模式，则将URL更改为http://localhost:8069/web?debug=assets#menu_id=102&amp;action=94。 要退出开发人员模式，您可以执行以下任一操作： 编辑URL并在查询字符串中写入?debug=0。 使用在设置菜单中的同一位置停用开发者模式。 单击顶部菜单中的错误图标，然后单击“离开开发者工具”选项。 许多开发人员正在使用浏览器扩展来切换调试模式。通过此功能，您可以快速切换调试模式而无需访问设置菜单。这些扩展适用于Firefox和Chrome。请看以下屏幕截图，它将帮助您在Chrome商店中识别插件： 自从Odoo v13版本后，调试模式的行为已发生更改。调试模式的状态存储在会话中，这意味着即使将?debug从URL中删除，调试模式仍会处于激活状态。 怎么运行的…在开发者模式下，会发生两件事： 将鼠标悬停在表单视图中的字段上或列表视图中的列上时，会有提示，提供有关该字段的技术信息（内部名称，类型等） 带有错误图标的下拉菜单会显示在右上角（用户菜单的旁边），通过这个菜单可访问有关正在显示的模型，各种相关视图定义，工作流，自定义过滤器管理等技术信息。 开发者模式有一个变体**Developer mode (with assets)**。此模式的行为类似于普通开发者模式，但是，发送到浏览器的JavaScript和CSS代码并未缩小，这意味着您的网络开发工具 浏览器很容易用于调试JavaScript代码（有关详细信息，请参阅第15章，Web客户端开发）。 更新附加模块列表当您添加新模块时，为了在Odoo中列出该模块，您需要更新模块列表。在此Recipe中，您将学习如何更新应用程序列表。 准备工作启动您的实例并使用管理员帐户连接到该实例。执行此操作后，激活开发者模式（如果您不知道如何激活开发者模式，请参上一小节）。 怎么做…要更新您实例中可用插件模块的列表，您需要执行以下步骤： 打开应用菜单。 点击刷新本地模块列表。 在弹出的对话框中点解更新按键。 更新结束时，您可以单击应用程序条目以查看可用附加模块的更新列表。您需要在搜索框中删除应用程序上的默认过滤器，以查看所有模块。 怎么运行的…单击更新按钮时，Odoo将读取加载项路径配置变量，对于列表中的每个目录，它将查找包含加载项清单文件的直接子目录，该文件是名为__manifest__.py的文件，存储在附加模块目录。 Odoo会读取清单，希望找到Python字典。除非清单中包含installable设置为False的实例，否则附加模块元数据将记录在数据库中；如果模块已经存在，则信息将被更新；否则，将创建新记录。如果找不到以前可用的附加模块，则不会从列表中删除该记录。 仅当在初始化数据库后添加了新的加载项路径时才需要更新的应用程序列表。如果在初始化数据库之前将新的加载项路径添加到配置文件中，则无需手动更新模块列表。 总结到目前为止，我们已经学到的知识，安装后，您可以使用以下命令行启动Odoo服务器（如果使用的是虚拟环境，则需要先激活虚拟环境）： 1python3 odoo-bin -d odoo-test -i base --addons-path=addons --db-filter=odootest Once you run the module, you can access Odoo from http://localhost:8069. You can also use a configuration file to run Odoo as follows: 运行模块后，您可以从http://localhost:8069访问Odoo。还可以使用配置文件来运行Odoo，如下所示： 1./odoo-bin -c myodoo.cfg 启动Odoo服务器后，您可以从应用菜单安装/更新模块。","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AE%89%E8%A3%85Odoo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14开发者指南第三章-创建Odoo附加模块【翻译】","text":"现在我们已经有了一个开发环境，也知道如何管理Odoo服务器实例和数据库，下面我们可以学习如何创建Odoo附加模块。 我们在本章的主要目标是了解一个附加模块的结构，以及向其添加组件的典型渐进式学习路线。本章教程名称中提到的各种组件将在后续章节中广泛介绍。 在这章中，包含以下教程： 创建和安装一个新的附加模块 完成附加模块的声明 组织附加模块的文件结构 添加模型 添加菜单项目和界面 添加访问安全 使用scaffold命令创建一个模块 技术要求在本章中，希望您已经安装了Odoo，并按照《第一章-安装Odoo开发环境》中的方法进行操作。此外，您还需要熟悉发现和安装额外的附加模块，如《第二章-管理Odoo服务器实例》中所述。 本章使用的所有代码你可以到以下GitHub仓库下载： https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter03 什么是Odoo附加模块处理Odoo框架的代码，Odoo的所有代码库都是以模块的形式打包的。这些模块可以随时从数据库中安装或卸载。这些模块有两个主要目的。要么你可以添加新的应用程序/业务逻辑，要么你可以修改现有的应用程序。简单地说，在Odoo中，一切都以模块开始和结束。 Odoo被各种规模的公司所使用，每个公司都有不同的业务流程和要求。为了处理这个问题，Odoo将应用程序的功能分割成不同的模块。这些模块可以根据需求在数据库中加载。基本上，用户可以启用/禁用这些模块的功能。因此，同一软件可以根据不同的要求进行调整。请看以下Odoo模块的截图；栏目中的第一个模块是主应用程序，其他模块是为了在该应用程序中添加额外的功能。要获得按应用类别分组的模块列表，请进入应用菜单，应用按类别分组： 如果你计划在Odoo中开发新的应用程序，你应该为各种功能创建边界。这对于将你的应用程序划分为不同的附加模块非常有帮助。现在你知道了Odoo中附加模块的目的，我们可以开始构建自己的附加模块了。 创建和安装新的附加模块在以下教程中我们会创建一个新的模块使其可以被Odoo实例识别并安装。 准备工作首先我们需要一个正在运行的Odoo实例，如果你进行了《第一章-安装Odoo开发环境》的操作，你的Odoo应该安装在 ~/odoo-dev/odoo 中。为了便于讲解教程，我们假设你的实例已经安装在以上目录中，当然你也可以根据你的喜好进行修改。 我们还需要一个目录来存放我们开发的Odoo模块。为了方便讲解，我们会使用odoo实例目录下的 local-addons 目录作为该目录，目录路径为 ~/odoo-dev/local-addons 。 操作步骤我们将创建一个小的附加模块，用于管理图书馆的图书列表来作为本章的例子。 使用以下步骤来创建和安装一个新的附加模块： 进入Odoo实例目录并创建一个新的目录来存放我们开发的模块： 12$ cd ~/odoo-dev$ mkdir local-addons 为新模块选择一个技术名称，并为模块创建一个同名的目录，例如我们使用 my_library 作为模块名称： 1$ mkdir local-addons/my_library 一个模块的技术名称必须是一个有效的Python标识符，它必须以字母开头并且只包含字母、数字和下划线字符。最好在模块名中只是用小写字母。 添加__init__.py文件使模块能被Python导入： 1$ touch local-addons/my_library/__init__.py 添加一个最小的模块清单，以便Odoo检测到它是一个附加模块。在my_library文件夹中，创建一个__manifest__.py文件，其中有这样一行： 1{'name': 'My Library'} 开启你的Odoo实例，在addons-path中添加我们模块目录： 1$ odoo/odoo-bin --addons-path=odoo/addon/,loacl-addons/ 如果使用了--save选项，add-ons 路径会被保存到配置文件中。下次启动服务器时，如果没有提供add-ons路径选项，将使用这个选项。 要使新模块在你的Odoo实例中可用，使用管理员登录Odoo，在关于框中启用开发者模式，在应用顶部菜单中选择更新应用程序列表。现在，Odoo应该能识别我们的Odoo模块了： 选择顶部的应用菜单，在右上角的搜索栏中，删除默认的应用筛选器，搜索my_library。点击安装按钮，即可完成安装。 运行原理一个Odoo模块目录包含代码文件和其他资源文件。文件夹的名称使用模块的技术名称。模块的清单文件中的name的value也是模块的技术名称。 __manifest__.py文件是模块的清单文件。这包含一个Python字典，其中包含模块元数据，包括类别、版本、它所依赖的模块，以及它将加载的数据文件列表。在本节教程中，我们使用了一个最小的清单文件，但在实际的模块中，我们将需要其他重要的键。这些将在下一节完成附加模块清单中再介绍。 模块的目录必须是Python能导入的，因此该目录中需要有__init__.py文件，该文件甚至可以是空文件。要加载一个模块，Odoo服务器将导入它。这将导致__init__.py文件中的代码被执行，所以它可以作为运行模块Python代码的入口点。由于这个原因，它通常会包含导入语句来加载模块的Python文件和子模块。 已知的模块可以使用--init或-i选项直接从命令行安装。例如，如果你想安装crm和网站应用，你可以使用-i crm,website。当你从当时提供的add-ons路径上找到的模块创建一个新的数据库时，这个列表会被初始化。可以在现有的数据库中通过更新模块列表菜单进行更新。 完善附加模块的清单文件清单文件是Odoo模块的重要的一部分。它包含了关于附加模块的重要元数据，并声明了应该加载的数据文件。 准备工作我们应该有一个模块来工作，已经包含一个__manifest__.py清单文件。你可能想按照前面的配方来提供这样一个模块来工作。 操作步骤我们将为我们的模块添加一个清单文件和图标： 创建一个清单文件__manifest__.py，编辑文件如下： 12345678910111213141516{'name': &quot;My library&quot;,'summary': &quot;Manage books easily&quot;,'description': &quot;&quot;&quot;Manage Library==============Description related to library.&quot;&quot;&quot;,'author': &quot;Your name&quot;,'website': &quot;http://www.example.com&quot;,'category': 'Uncategorized','version': '13.0.1','depends': ['base'],'data': ['views/views.xml'],'demo': ['demo.xml'],} 选择一个PNG格式的图片复制到static/description/icon.png。 工作原理清单文件中的内容是一个常规的Python字典，有键和值。我们最常用的键如下： name：模块的名称。 summary：这是带有单行说明的副标题。 description：这是一个以纯文本或 ReStructuredText (RST) 格式书写的长描述。它通常由三个引号包围，在 Python 中用于限定多行文本。对于RST的快速入门参考https://docutils.sourceforge.io/docs/user/rst/quickstart.html。 author：这是一个带有作者姓名的字符串。当有多个作者时，通常的做法是用逗号来分隔他们的名字，但注意它仍然应该是一个字符串，而不是一个Python列表。 website：这是一个URL，以了解作者和模块的更多信息。 category：用于组织模块，可用的标准别名列表可参考https://github.com/odoo/odoo/blob/13.0/odoo/addons/base/data/ir_module_category_data.xml。你也可以定义其他类别名称。 version：这是模块的版本号，它可以被Odoo应用商店检查以安装模块的较新版本。如果版本号不是以Odoo版本号（例如13.0），则会自动添加。不过，如果你明确说明Odoo的目标版本，例如使用13.0.1.0.0或13.0.1.0，而不是1.0.0或1.0，会更有参考价值。 depends：这是一个直接依赖的模块的技术名称列表，如果你的模块不依赖任何其他附加模块，则至少依赖 base 模块。不要忘记包括任何定义XML ID、视图或模型的模块，这些模块被该模块引用。这将确保它们都以正确的顺序加载，避免出现难以预计的错误。 data：这是一些用于安装和升级时加载的文件的路径列表。这些路径是相对与模块目录的相对路径。通常情况下，这些文件都是XML和CSV文件，但也有可能是YAML数据文件。这些将在第六章-管理模块数据中详细讨论。 demo：这是演示数据文件的相对路径列表，只有在创建数据库时启用了演示数据时才会加载这些数据。 用作模块图标的文件位于static/description/icon.png。 Odoo在不同的主要版本之间会有很大的变化，所以为一个主要版本建立的模块在没有转换和迁移工作的情况下不可能与下一个版本兼容。因此，在安装模块之前，一定要确定模块的Odoo目标版本。 扩展内容也可以用一个单独的描述文件来代替清单文件中定义的长描述，从8.0版本开始，可以用README文件代替，扩展名为.txt、.rst或.md（markdown）。此外，在模块中包含一个description/index.html文件。 HTML描述会覆盖清单文件中的长描述。 以下是一些常用的其他键： licence：默认值是LGPL-3，用于定义模块的许可证，其他可能的许可包括 AGPL-3 、 Odoo Proprietary License v1.0* （主要用于付费应用）和 Other OSI Approved Licence 。 application：该值如果为True，则模块为应用，通常情况下用于功能区的核心模块。 auto_install：该值如果为True，表示它是一个胶水模块，当所有的依赖项都安装完毕后，它会自动安装。 installable：默认值为True，表示该模块可以被安装。 external_dependencies：一些Odoo模块内部使用Python/bin库。如果你的模块使用了这样的库，你需要把它们放在这里。如果所列出的模块没有安装在主机上，这将阻止用户安装模块。 {pre_init, post_init, uninstall}_hook：这是一个Python函数钩子，在安装/卸载时被调用。更详细的例子，请参考第8章，高级服务器端开发技术。 以下是一些特殊的键，用于app商店的： price：这个键用于设置你的附加模块的价格，该值应该设置为整型值，如果为空则表示你的应用是免费的。 currency：币别，可用的值包括USD和EUR。默认值为EUR。 live_test_url：如果你想提供一个在线测试的URL，你可以使用这个键，设置后在App商店上会显示Live Preview按钮。 iap：如果这个模块提供IAP服务，可以使用这个键设置你的IAP开发者密钥。 images：图片的路径，用于设置在Odoo的App商店上显示你的App封面的图片。 组织附加模块的文件结构一个附加模块包含代码文件和其他资源文件，例如XML文件和图片文件，对于其中的大部分文件，我们可以自由选择放在模块目录内的位置。 但是，Odoo在模块结构上使用了一些约定，所以建议遵循这些约定。 准备工作我们希望有一个附加模块目录，里面只有__init__.py和__manifest__.py文件。在这个教程中，我们假设它是local-addons/my_library。 操作步骤执行以下步骤创建附加模块的基本框架： 创建代码文件的目录： 1234567891011121314$ cd local-addons/my_library$ mkdir models$ touch models/__init__.py$ mkdir controllers$ touch controllers/__init__.py$ mkdir views$ touch views/views.xml$ mkdir security$ mkdir wizard$ touch wizard/__init__.py$ mkdir report$ mkdir data$ mkdir demo$ mkdir i18n 编辑模块根目录的__init__.py，以便加载子目录中的代码： 12from . import controllersfrom . import wizard 我们应该会得到一个包含最常用的目录的结构，类似于这个my_library模块的结构： 12345678910111213141516171819202122├── __init__.py├── __manifest__.py├── controllers│ └── __init__.py├── data├── demo├── i18n├── models│ └── __init__.py├── security├── static│ ├── description│ └── src│ ├─ js│ ├─ scss│ ├─ css│ └ xml├── report├── wizard│ └── __init__.py└──views└── __init__.py 运行原理为了提供一些背景，一个Odoo附加模块可以有三种类型的文件。 Python代码由__init__.py文件加载，其中导入了.py文件和代码子目录。包含Python代码的子目录，则需要自己的__init__.py文件。 在__manifest__.py模块清单文件的data和demo键中要声明的数据文件才能加载，通常是用户界面、夹具数据和演示数据的XML和CSV文件。也可能有YAML文件，它可以包含一些程序指令，在模块加载时运行，例如，以编程方式而不是静态地在XML文件中生成或更新记录。 Web资源文件，如JavaScript代码和库、CSS、SASS和QWeb/HTML模板。这些文件用于构建UI部件和管理用户在这些UI元素中的操作。这些都是通过一个XML文件来声明的，这个XML文件是扩展主模板的，它将这些资产添加到Web客户端或网站页面中。 附加模块文件将被组织到以下目录中： models/ 包含后台创建模型及其业务逻辑的代码文件。每个模型建议使用一个与模型同名的文件，例如，library_book.py代表library.book模型。这些内容在《第4章-应用模型》中会有深入的阐述。 views/ 包含用户界面的actions、forms、list等XML文件。如模型，建议每个模型都有一个文件。网站模板的文件名应以 _tmplate 为后缀。后台视图在《第九章-后台视图》中讲解，网站视图在《第十四章-CMS网站开发》中讲解。 data/ 包含模块初始化的数据文件，数据文件将在《第六章-管理模块数据》中讲解。 demo/ 包含模块演示数据的数据文件，这些数据用于测试、培训和模块评估。 i18n/ 是Odoo寻找翻译.pot和.po文件的地方。更多细节请参考《第十一章-国际化》。这些文件不需要在清单文件中提及。 security/ 包含定义访问控制列表的数据文件，通常是一个ir.model.access.csv文件，也可能是一个XML文件，用于定义行级安全的访问组和记录规则。请看《第十章-安全访问》了解更多细节。 controllers/ 包含了网站控制器以及提供该类功能的模块的代码文件。Web控制器在第《十三章-Web服务器开发》中有所涉及。 static/ 是所有网站资源文件放置的地方。与其他目录不同的是，这个目录名不仅仅是一个约定俗成的名称。这个目录里面的文件是公开的，不需要用户登录就可以访问。这个目录主要包含JavaScript、样式表和图片等文件。它们不需要在模块清单中声明，但要在网页模板中必须要提及。这一点在《第十四章-CMS网站开发》中会详细讨论。 wizard/ 包含所有与向导相关的文件。在Odoo中，向导是用来保存中间数据的。我们在《第八章-高级服务器端开发技术》中学习更多关于向导的知识。 report/ Odoo提供了一个生成PDF文件的功能，如销售订单和发票。这个目录下存放了所有与PDF报表相关的文件。我们将在《第十二章-自动化、工作流、电子邮件和打印》中了解更多关于PDF报告的内容。 当为模块添加新文件时，不要忘记在__manifest__.py文件(数据文件)或__init__.py文件(代码文件)中声明它们，否则这些文件将被忽略并不会被加载。 添加模型模型定义了我们业务应用程序将使用的数据结构。本节教程向您展示了如何在模块中添加一个基本模型。 实现步骤要添加一个新的模型，我们需要添加一个描述它的Python文件，然后升级附加模块(或者安装它，如果还没有安装的话)。使用的路径是相对于我们的附加模块的位置(例如，~/odoo-dev/local-addons/my_library/)。 添加models/library_book.py Python文件，代码如下： 123456789from odoo import models, fieldsclass LibraryBook(models.Model): _name = 'library.book' name = fields.Char('Title', required=True) date_release = fields.Date('Release Date') author_ids = fields.Many2many( 'res.partner', string='Authors' ) 添加一个Python初始化文件models/__init__.py，代码如下: 1from . import library_book 编辑模块的Python初始化文件来加载models/目录： 1from . import models 通过命令行或用户界面的Apps菜单升级Odoo模块。如果你在升级模块时仔细观察服务器日志，你应该会看到以下一行： 1odoo.modules.registry: module my_library: creating or updating database table 在这之后，新的 library.book 模型应该在我们的 Odoo 实例中可用。有两种方法可以检查我们的模型是否已经被添加到数据库中。 第一种方法，你可以在Odoo用户界面中查看。计划开发者工具，打开菜单的设置-&gt;技术-&gt;数据库结构-&gt;模型，在这里搜索library.book模型。 第二种方法是检查PostgreSQL数据库中的表项，你可以在数据库中搜索library_book表。在下面的示例代码中我们使用test-14.0作为我们的数据库。然而，在以下的命令中你也可以替换你的数据库名称： 12$ psql test-14.0test-14.0# \\d library_book; 运行原理我们的第一步是创建一个Python文件，其中创建了我们的新模块。 Odoo框架有自己的Object Relational Mapping(ORM) 框架。这个ORM框架提供了对PostgreSQL数据库的抽象。通过继承Odoo Python类Model ，我们可以创建自己的模型（表）。当定义一个新模型时，它也会被添加到一个中央模型注册表中。这使得其他模块以后更容易对其进行修改。 模型有一些以下划线为前缀的通用属性。最重要的是_name ，它提供了一个唯一的内部标识符，将在整个Odoo实例中使用。ORM框架会根据这个属性生成数据库表。在本节中我们使用了_name = ‘library.book’ 。基于此属性，ORM框架将创建一个名为library_book 的新表。请注意，ORM框架通过替换_name属性的值的.为_来创建表名。 模型字段被定义为类属性。我们首先定义name 字段，字段类型为Char 。模型有这个字段很方便，因为默认情况下，它被其他模型引用时用作记录描述。 我们还使用了一个关系字段的示例author_ids 。这定义了Library Books 与其partner之间的多对多关系。一本书可以有很多作者，每个作者可以写很多书。 关于模型还有很多话要说，我们将在第四章《应用模型》中深入介绍。 接下来，我们必须让我们的模块知道这个新的Python文件。这是由__init__.py 文件完成的。由于我们将代码放在models/ 子目录中，我们需要之前的__init__ 文件来导入该目录，该目录又应该包含另一个__init__ 文件，在那里导入每个代码文件（在我们的例子中只有一个）。 通过升级模块激活对Odoo模型的更改。Odoo服务器将处理模型类到数据库结构更改的转换。 虽然这里没有提供示例，但也可以通过向模型的类添加新方法，或者通过扩展现有方法，例如 create() 或write() ，将业务逻辑添加到这些Python文件中。这将在第五章《基本服务器端开发》中讨论。 添加菜单项目和界面一旦我们有了满足数据结构需求的模型，我们就需要一个用户界面，以便我们的用户可以与它们进行交互。本节将在上一节的Library Book 模型之上添加了一个菜单项来显示具有列表和表单视图的用户界面。 准备工作需要上一节中实现的library.book 模型的附加模块。将使用的路径与我们的附加模块位置相关（例如，~/odoo-dev/localaddons/my_library/ ）。 实现步骤要添加视图，我们将在模块中添加一个带有其定义的XML 文件。由于它是一个新模型，我们还必须添加一个菜单选项，以便用户能够访问它。 请注意，以下步骤的顺序是相关的，因为其中一些使用对前面步骤中定义的ID的引用： 创建XML文件以添加描述用户界面的数据记录，views/library_book.xml ： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;odoo&gt; &lt;!-- Data records go here --&gt;&lt;/odoo&gt; 将新数据文件添加到附加模块清单__manifest__.py ，方法是将其添加到views/library_book.xml ： 123456{ 'name': &quot;My Library&quot;, 'summary': &quot;Manage books easily&quot;, 'depends': ['base'], 'data': ['views/library_book.xml'],} 在library_book.xml 文件中添加打开视图的操作： 12345&lt;record id='library_book_action' model='ir.actions.act_window'&gt; &lt;field name=&quot;name&quot;&gt;Library Books&lt;/field&gt; &lt;field name=&quot;res_model&quot;&gt;library.book&lt;/field&gt; &lt;field name=&quot;view_mode&quot;&gt;tree,form&lt;/field&gt;&lt;/record&gt; 将菜单项添加到library_book.xml 文件中，使其对用户可见： 123&lt;menuitem name=&quot;My Library&quot; id=&quot;library_base_menu&quot; /&gt;&lt;menuitem name=&quot;Books&quot; id=&quot;library_book_menu&quot; parent=&quot;library_base_menu&quot; action=&quot;library_book_action&quot;/&gt; 将自定义表单视图添加到library_book.xml 文件： 1234567891011121314151617&lt;record id=&quot;library_book_view_form&quot; model=&quot;ir.ui.view&quot;&gt; &lt;field name=&quot;name&quot;&gt;Library Book Form&lt;/field&gt; &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt; &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt; &lt;form&gt; &lt;group&gt; &lt;group&gt; &lt;field name=&quot;name&quot;/&gt; &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot;/&gt; &lt;/group&gt; &lt;group&gt; &lt;field name=&quot;date_release&quot;/&gt; &lt;/group&gt; &lt;/group&gt; &lt;/form&gt; &lt;/field&gt;&lt;/record&gt; 将自定义树（列表）视图添加到library_book.xml 文件： 12345678910&lt;record id=&quot;library_book_view_tree&quot; model=&quot;ir.ui.view&quot;&gt; &lt;field name=&quot;name&quot;&gt;Library Book List&lt;/field&gt; &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt; &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt; &lt;tree&gt; &lt;field name=&quot;name&quot;/&gt; &lt;field name=&quot;date_release&quot;/&gt; &lt;/tree&gt; &lt;/field&gt;&lt;/record&gt; 将自定义搜索选项添加到library_book.xml 文件： 12345678910111213&lt;record id=&quot;library_book_view_search&quot; model=&quot;ir.ui.view&quot;&gt; &lt;field name=&quot;name&quot;&gt;Library Book Search&lt;/field&gt; &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt; &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt; &lt;search&gt; &lt;field name=&quot;name&quot;/&gt; &lt;field name=&quot;author_ids&quot;/&gt; &lt;filter string=&quot;No Authors&quot; name=&quot;without_author&quot; domain=&quot;[('author_ids','=',False)]&quot;/&gt; &lt;/search&gt; &lt;/field&gt;&lt;/record&gt; 在Odoo中添加新模型时，用户默认没有任何访问权限。我们必须为新模型定义访问权限才能获得访问权限。在我们的示例中，我们没有定义任何访问权限，因此用户无权访问我们的新模型。如果没有访问权限，我们的菜单和视图也不可见。幸运的是，有一个捷径！通过切换到超级用户模式，您可以在没有访问权限的情况下查看我们应用程序的菜单。 以超级用户身份访问 Odoo通过将管理员用户转换为超级用户类型，可以绕过访问权限限制，从而访问菜单和视图而无需提供默认访问权限。要将管理员用户转换为超级用户，请激活开发人员模式。完成此操作后，从开发人员工具选项中，单击成为超级用户选项。 以下屏幕截图已作为参考提供： 成为超级用户后，您的菜单将具有条纹背景，如下图所示： 如果您现在尝试升级模块，您应该能够看到一个新的菜单选项（您可能需要刷新您的Web浏览器）。单击 Books 菜单将打开book模型的列表视图，如以下屏幕截图所示： 运行原理在底层，用户界面由存储在特殊模型中的记录定义。前两步创建一个空的XML文件来定义要加载的记录，然后将它们添加到模块的要安装的数据文件列表中。 数据文件可以放在模块目录中的任何位置，但惯例是在views/ 子目录中定义用户界面。通常这些文件的名称基于模型的名称。在我们的例子中，我们正在为library.book 模型创建用户界面，因此我们创建了views/library_book.xml 文件。 下一步是定义一个窗口动作以在Web客户端的主区域中显示用户界面。action是一个由res_model 定义的目标模型，name 属性用于在用户打开action时向用户显示标题，这些只是基本属性。窗口操作支持其他属性，可以更好地控制视图的呈现方式，例如要显示哪些视图、在可用记录上添加过滤器或设置默认值。 这些将在第九章《后端视图中》详细讨论。 通常，数据记录是使用&lt;record&gt; 标签定义的，我们在示例中为ir.actions.act_window 模型创建了一条记录。这将创建窗口操作。 同样，菜单项存储在ir.ui.menu 模型中，我们可以使用&lt;record&gt; 标记创建它们。但是在Odoo中有一个名为&lt;menuitem&gt; 的快捷方式标签，因此我们在示例中使用了它。 这些是菜单项的主要属性： name ：这是要显示的菜单项文本。 action ：这是要执行的操作的标识符。我们使用在上一步中创建的窗口操作的ID。 sequence ：用于设置同级菜单项的显示顺序。 parent ：这是父菜单项的标识符。我们的示例菜单项没有父项，这意味着它将显示在菜单的顶部。 web_icon ：此属性用于显示菜单的图标。此图标仅在Odoo企业版中显示。 此时我们还没有在我们的模块中定义任何视图。但是，如果您在此阶段升级您的模块，Odoo将自动动态创建它们。 尽管如此，我们肯定希望控制视图的外观，因此，在接下来的两个步骤中，将创建一个表单和一个树视图。 两个视图都使用ir.ui.view 模型上的记录定义。 我们使用的属性如下： name ：这是标识视图的标题。在Odoo的源代码中，您会发现这里重复了XML ID，但如果您愿意，可以添加一个更易读的标题作为名称。 如果name 字段被省略，Odoo将使用模型名称和视图类型生成一个。这对于新模型的标准视图来说非常好。建议在扩展视图时使用更明确的名称，当您在Odoo的用户界面中查找特定视图时，将变得非常方便。 model ：这是目标模型的内部标识符，在其_name 属性中定义。 arch ：这是视图架构，实际定义结构的地方。不同类型的视图都不相同。 表单视图由顶部的&lt;form&gt; 元素定义，其画布是一个双列网格。在表单内部，&lt;group&gt; 元素用于垂直组合字段。两个组产生两个带有字段的列，它们是使用&lt;field&gt; 元素添加的。字段根据其数据类型使用默认小部件，但可以在小部件属性的帮助下使用特定小部件。 树视图更简单；它们由顶部&lt;tree&gt; 元素定义，该元素包含要显示的列的&lt;field&gt; 元素。 最后，我们添加了一个搜索视图以扩展右上角框中的搜索选项。 在&lt;search&gt; 顶级标签内，我们可以有&lt;field&gt; 和&lt;filter&gt; 元素。字段元素是可以从搜索视图中给出的输入中搜索的附加字段。过滤器元素是预定义的过滤条件，可以通过单击激活。这些主题在第九章《后端视图》中详细讨论。 添加访问安全添加新数据模型时，您需要定义谁可以创建、读取、更新和删除记录。当创建一个全新的应用程序时，这可能涉及定义新的用户组。因此，如果用户没有这些访问权限，那么Odoo将不会显示您的菜单和视图。在上一节中，我们通过将管理员用户转换为超级用户来访问我们的菜单。通过本节，您将能够以管理员用户的身份直接访问我们的库模块的菜单和视图。 本节中建立在前一章节的Library Books之上，并定义了一个新的用户安全组来控制谁可以访问或修改图书记录。 准备工作需要上一章节使用的library.book 模型的附加模块，我们将为它添加安全规则。使用的路径与我们的附加模块位置相关（例如，~/odoo-dev/local-addons/my_library/ ）。 实现步骤在本小节中我们要添加的安全规则如下： 每个人都可以阅读图书馆的图书记录。 新建具有权创建、读取、更新和删除图书记录的安全组：Librarians 。 要实现这一点，您需要执行以下步骤： 创建一个名为security/groups.xml 的文件，其内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;odoo&gt; &lt;record id=&quot;group_librarian&quot; model=&quot;res.groups&quot;&gt; &lt;field name=&quot;name&quot;&gt;Librarians&lt;/field&gt; &lt;field name=&quot;users&quot; eval=&quot;[(4, ref('base.user_admin'))]&quot;/&gt; &lt;/record&gt;&lt;/odoo&gt; 创建名为security/ir.model.access.csv 文件，其内容如下： 123id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlinkacl_book,library.book_default,model_library_book,,1,0,0,0acl_book_librarian,library.book_librarian,model_library_book,group_librarian,1,1,1,1 将以上两个文件添加到__manifest__.py 文件的data 条目中： 1234567# ...'data': [ 'security/groups.xml', 'security/ir.model.access.csv', 'views/library_book.xml'],# ... 更新实例中的插件后，新定义的安全规则将生效。 运行原理我们提供了两个新的数据文件，将它们添加到附加模块的清单中，以便安装或更新模块会将它们加载到数据库中： security/groups.xml 文件通过创建res.groups 记录来定义新的安全组。我们还通过使用其参考ID base.user_admin 将Librarians 的权限授予admin 用户，这样admin用户将拥有library.book 模型的权限。 ir.model.access.csv 文件将模型的权限与组相关联。第一行有一个空的group_id:id 列，这意味着该规则适用于所有人。最后一行将所有权限授予我们刚刚创建的组的成员。 清单文件中的的数据部分文件的顺序很重要。创建安全组的文件必须在列出访问权限的文件之前加载，因为访问权限的定义取决于组的存在。由于视图可以特定于安全组，我们建议将组的定义文件放在列表中以更安全。 也可以看看本书有一章专门介绍安全性。有关安全性的更多信息，请参阅第十章《安全访问》。 使用scaffold命令创建一个模块创建新的Odoo模块时，需要设置一些样板代码。为了帮助快速启动新模块，Odoo提供了脚手架（scaffold ）命令。 本节向你展示了如何使用脚手架命令创建一个新模块，它将生成一个模块需要的文件目录。 准备工作我们将在自定义模块目录中创建新的附加模块，因此我们需要安装Odoo和自定义模块的目录。假设 Odoo安装在~/odoo-dev/odoo 并且我们的自定义模块放置在~/odoo-dev/local-addons 目录中。 实现步骤我们将使用scaffold 命令来创建模板代码。执行以下步骤以使用scaffold 命令创建新模块： 将工作目录更改为我们希望模块所在的位置。这可以是您选择的任何目录，但它必须位于附加路径中才能有用。 按照我们在上面中使用的目录选择，应该如下所示： 1cd ~/odoo-dev/local-addons 为新模块选择一个技术名称，并使用scaffold 命令创建它。对于我们的示例，我们将选择my_module ： 1~/odoo-dev/odoo/odoo-bin scaffold my_module 编辑提供的__manifest__.py 默认模块清单并更改相关值。您肯定希望至少更改name 键中的模块标题。 这是生成的附加模块应如下所示： 12345678910111213141516171819tree my_modulemy_module/├── controllers│ ├── controllers.py│ └── __init__.py├── demo│ └── demo.xml├── __init__.py├── __manifest__.py├── models│ ├── __init__.py│ └── models.py├── security│ └── ir.model.access.csv└── views ├── templates.xml └── views.xml 5 directories, 10 files 您现在应该编辑各种生成的文件并使它们适应新模块的用途。 运行原理scaffold 命令可使用模板来创建新模块的结构框架。 默认情况下，新模块是在当前工作目录中创建的，但我们可以提供一个特定的目录来创建模块，将其作为附加参数传递。 类似以下示例： 1~/odoo-dev/odoo/odoo-bin scaffold my_module ~/odoo-dev/local-addons 使用default 模板，但theme 模板也可用于网站主题创作。要选择特定模板，可以使用-t 选项。 我们还可以使用带有模板的目录的路径。 这意味着我们可以通过scaffold 命令使用我们自己的模板。 内置模板可以在/odoo/cli/templates 的子目录中找到。要使用我们自己的模板，我们可以使用类似以下命令： 1~/odoo-dev/odoo/odoo-bin scaffold -t path/to/template my_module 默认情况下，Odoo在/odoo/cli/templates 目录中有两个模板。一是default 模板，二是theme 模板。 但是，您可以创建自己的模板或将其与-t 一起使用，如前面的命令所示。","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BAOdoo%E9%99%84%E5%8A%A0%E6%A8%A1%E5%9D%97%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14开发者指南第二章-管理Odoo服务器实例【翻译】","text":"在第一章，安装Odoo开发环境中，我们研究了如何仅使用源附带的标准核心插件来设置Odoo实例。本章着重于向Odoo添加非核心或自定义插件。在Odoo中，您可以从多个目录加载add-ons，此外，建议使用单独的文件夹加载第三方add-ons或自己的自定义add-ons，以免与Odoo核心模块发生冲突。 在本章中，我们将介绍以下Recipes： 配置add-ons路径； 标准化您的实例目录布局； 安装和升级本地的add-ons； 从GitHub安装add-ons； 将更改应用到add-ons； 应用并尝试建议的拉取请求。 有关术语 在本书中，我们将交替使用（插件）add-no或（模块）module或（应用）app或（插件模块）add-on module这些术语。这些属于都代表一个意思，就是可以从用户界面安装的Odoo应用程序或者Extension应用程序。 配置add-ons路径借助addons_path参数，您可以将自己的附加模块加载到Odoo中。当Odoo初始化新数据库时，它将在addons_path配置参数提供的目录中搜索附加模块。 addons_path中列出的目录应该包含子目录，每个子目录都是一个附加模块。在数据库初始化之后，您将能够安装这些目录中提供的模块。 准备工作此Recipes假定您已准备好一个实例，并且已生成一个配置文件，如第1章的安装Odoo开发环境中的在文件配方中存储实例配置中所述。请注意，Odoo的源码目录是~/odoo-dev/odoo，Odoo配置文件目录是~/odoo-dev/myodoo.cfg。 如何配置add-no路径要将~/odoo-dev/loacl-addons目录添加到实例的addons-path配置中，需要以下步骤： 编辑你的实例的配置文件~/odoo-dev/myodoo.cfg; 找到以 addons_path= 开头的行,默认情况下，它应如下所示： 1addons_path = ~/odoo-dev/odoo/addons 用逗号分隔，后跟要添加到addons_path的目录的名称，如以下代码所示： 1addons_path = ~/odoo-dev/odoo/addons,~/odoo-dev/local-addons 重启你的实例： 1$ ~/odoo-dev/odoo/odoo-bin -c my-instance.cfg 运行原理当Odoo实例重启后，它会读取配置文件的addons_path变量并根据逗号分隔各个值。addons_path可以使用相对路径，但它们是相对于当前工作目录的，因此应避免在配置文件中使用。 至此，我们只添加了add-on目录 ~/odoo-dev/local-addons但是该目录中还没有模块。甚至在该目录下添加了新的模块，也不会显示在Odoo的用户界面中。为此，您需要执行额外的操作，我们将在下一部分更新插件模块列表中会进行讲解。 这背后的原因是，当初始化新数据库时，Odoo会自动在可用模块中列出您的自定义模块，但是如果在数据库初始化后添加新模块，则需要手动更新可用模块列表。 更多内容当你使用odoo-bin脚本来初始化新的数据库时，你可以在命令行输入--addons-path参数和以逗号分隔的插件目录。这样做Odoo会根据参数的内容来初始化插件目录。执行此操作时，必须显式包括基本加载项目录（odoo/odoo/addons）和核心加载项目录（odoo/addons）。与前面的方法的一个小区别是本地附加组件不能为空；它们必须至少包含一个子目录，该子目录具有附加模块的最小结构。 在第三章，创建Odoo附加模块，我们会介绍如何创建自己的模块，这里顺便介绍一些如何创建一个满足Odoo需求的模块的快捷方法： 1234$ mkdir -p ~/odoo-dev/local-addons/dummy$ touch ~/odoo-dev/local-addons/dummy/ init .py$ echo '{&quot;name&quot;: &quot;dummy&quot;, &quot;installable&quot;: False}' &gt; \\~/odoo-dev/local-addons/dummy/ manifest .py 您可以使用--save选项将路径保存到配置文件： 1234$ odoo/odoo-bin -d mydatabase \\--add-ons-path=&quot;odoo/odoo/addons,odoo/addons,~/odoo-dev/local-addons&quot;\\--save -c ~/odoo-dev/my-instance.cfg --stop-after-init 这里我们使用的是相对路径，保存时Odoo会自动转换为绝对路径存放到配置文件中。 标准化您的实例目录布局这个方法创建了一个结构化的目录，该目录将将相似生命周期或相似用途的文件分组放在特点的子目录中。 这个方法仅在你想使用类似的文件夹结构来管理开发环境和生产环境时使用，如果你不想可以跳过。 当然这个文件结构不是强制要求的，你可以根据你的需求更改此结构。 如何标准化你的实例目录布局要创建标准的实例布局，你需要执行以下步骤： 为每个实例创建一个目录： 12$ mkdir ~/odoo-dev/projectname$ cd ~/odoo-dev/projectname 创建Python虚拟环境： 1$ python3 -m venv env 创建子目录： 1$ mkdir src local bin filestore logs 子目录功能如下： src/: 它包含Odoo本身的克隆，以及各种第三方附加项目。 local/: 这用于保存您的实例特定的插件。 bin/: 这包括各种帮助程序可执行的Shell脚本。 filestore/: 这用作文件存储。 logs/ (可选): 这用作服务日期存储。 克隆Odoo源码和安装需求（详情可参考第一章，安装Odoo开发环境）： 123$ git clone -b 14.0 --single-branch --depth 1https://github.com/odoo/odoo.git src/odoo$ env/bin/pip3 install -r src/odoo/requirements.txt 保存以下代码到bin/odoo： 123#!/bin/sh ROOT=$(dirname $0)/..PYTHON=$ROOT/env/bin/python3 ODOO=$ROOT/src/odoo/odoo-bin$PYTHON $ODOO -c $ROOT/projectname.cfg &quot;$@&quot; exit $? 为bin/odoo添加可执行权限： 1$ chmod +x bin/odoo 创建一个空的名为dummy的本地模块： 1234$ mkdir -p local/dummy$ touch local/dummy/ init .py$ echo '{&quot;name&quot;: &quot;dummy&quot;, &quot;installable&quot;: False}' &gt;\\local/dummy/ manifest .py 为你的实例创建配置文件： 123$ bin/odoo --stop-after-init --save \\--addons-path src/odoo/odoo/addons,src/odoo/addons,local \\--data-dir filestore 添加.gitignore文件，用于告诉GitHub排除给定目录，以便在提交代码时Git会忽略这些目录，例如: filestore/, env/, logs/ 和 src/ 。 123456789101112# dotfiles, with exceptions:.*!.gitignore# python compiled files*.py[co]# emacs backup files*~# not tracked subdirectories/env//src//filestore//logs/ 为你的实例创建一个Git仓库并添加文件到Git仓库： 123$ git init$ git add .$ git commit -m &quot;initial version of projectname&quot; 运行原理我们会生成一个干净的目录结构，其中包含明确标记的目录和专门的角色。我们使用不同的目录来存储以下内容： 由其他人管理的代码（放在 src/ 目录下）； 本地相关的代码； 实例的文件存储。 为每个项目都创建一个Python虚拟环境，我们可以确保项目的依赖关系不会干扰到其他不同版本的Odoo实例，这个Python虚拟环境只会占有少量的硬盘空间。 以类似的方式，通过为我们的不同项目使用Odoo和第三方加载项模块的单独克隆，我们能够使它们各自独立发展，并且仅在需要它们的实例上安装更新，从而降低了发生更新回退的风险。 bin/odoo脚本不仅使我们无需记住各种路径或激活Python虚拟环境即可运行服务器，也为我们设置了配置文件。您可以在其中添加其他脚本来帮助您进行日常工作。例如，您可以添加脚本来检查运行实例所需的其他第三方项目。 关于配置文件，我们仅展示了在此处设置的最小化的选项，您也可以设置更多的选项，例如数据库名称，数据库过滤器或项目侦听的端口。详情可参考第一章，安装Odoo开发环境，以获取有关此主题的更多信息。 最后，通过在Git仓库中管理所有这些内容，将设置复制到另一台计算机上并在团队之间共享开发变得非常容易。 为了方便项目创建，您可以创建一个包含空结构的模板存储库，并为每个新项目fork该存储库。这将使您不必重新键入bin/odoo脚本，.gitignore文件以及所需的任何其他模板文件（连续集成配置，README.md，ChangeLog等）。 更多内容复杂模块的开发需要各种配置选项，每当您尝试使用任何配置选项时，都会导致更新配置文件。 频繁更新配置文件可能会让人头疼，为避免这种情况，另一种方法是从命令行传递所有配置选项，如下所示： 手动激活Python虚拟环境： 1$ source env/bin/activate 进入Odoo源码目录： 1$ cd src/odoo 运行Odoo服务： 12./odoo-bin --addons-path=addons,../../local -d test-14 -iaccount,sale,purchase --log-level=debug 在第3步中，我们直接在命令行中输入了一些选项，第一个是--add-ons-path，它会加载Odoo的核心插件目录addons以及你的本地的插件目录，您将在其中放置自己的加载项模块。-d选项将使用test-14数据库或创建一个新数据库（如果数据库不存在）-i选项将安装account，sale 和 purchase模块。接下来，我们传递了日志级别的选项，并设置了日志级别为debug，以便在日志中显示更多信息。 通过使用命令行，您可以快速更改配置选项。您还可以在终端中查看实时日志。 有关所有可用选项，请参阅可参考第一章，安装Odoo开发环境，或使用--help命令查看所有选项的列表以及每个选项的描述。 安装和升级本地附加模块Odoo的核心功能来自其附加模块，您可以从Odoo本身中获得大量附加模块，以及可以从App Store下载或自己编写的附加模块。 在这个Recipe中，我们会介分别绍如何通过web界面和命令行的方式去安装和更新这些附加模块。 使用命令行执行这些操作的主要好处包括：一次可以操作多个插件，并在安装或更新的过程中可以清晰的查看服务日子，这在开发模式下或编写实例安装脚本时非常有用。 准备工作确保您有一个正在运行的Odoo实例，其数据库已初始化并且正确设置了附加组件路径。在本教程中，我们将安装/升级一些附加模块。 如何安装和升级有两种可能的方法来安装或更新加载项-您可以使用Web界面或命令行。 使用Web界面安装和更新使用Web界面安装新的附件模块，你需要进行以下操作： 使用管理员账号登陆你的Odoo实例，进入应用菜单： 搜索你要安装的附加模块，下面是一些提示帮助你完成这个步骤： 激活未安装过滤器。 如果您正在寻找特定的功能附加组件，而不是广泛的功能附加组件，请删除应用程序过滤器。 在搜索栏输入模块的名称作为模块的过滤器。 您可能会发现使用列表视图使内容更具可读性。 点击模块名下面的安装按钮。 请注意，某些Odoo附加模块具有外部Python依赖关系。如果您的系统中未安装Python依赖关系，则Odoo将中止安装并显示以下对话框： 通过安装相关的Python依赖来修复它。 要更新数据库中的预安装模块，请执行以下步骤： 使用管理员账号登陆你的Odoo实力，进入应用菜单； 点击应用： 搜索你要安装的附加模块，下面是一些提示帮助你完成这个步骤： 激活已安装过滤器。 如果您正在寻找特定的功能附加组件，而不是广泛的功能附加组件，请删除应用程序过滤器。 在搜索栏输入模块的名称作为模块的过滤器。例如，这里我们输入CRM。 您可能会发现使用列表视图使内容更具可读性。 点击应用卡片右上角的三点，在弹出的菜单中选择*更新。 激活开发者模式以查看模块的技术名称。如果您不知道如何激活开发人员模式，请参考第一章，安装Odoo开发环境： 激活开发者模式后，它将以红色显示该模块的技术名称。如果您使用的是Odoo Community Edition，则您会看到一些带有升级按钮的其他应用程序。这些应用程序是Odoo Enterprise Edition应用程序，如要安装/使用它们您需要购买许可证。 使用命令行安装和更新使用命令行界面安装新的附件模块，你需要进行以下操作： 查找附件模块的名称。模块名称的定义是 __manifest__.py文件所在的目录名称，不带前导路径。 关闭Odoo实例，如果你是在生产环境中操作，请先进行数据库备份。 执行以下命令： 12$ odoo/odoo-bin -c instance.cfg -d dbname -i addon1,addon2 \\--stop-after-init 如果你在配置文件中设置了数据库名称，你可以忽略-d选项。 重启Odoo实例。 要更新数据库中的预安装模块，请执行以下步骤： 查找附件模块的名称。模块名称的定义是 __manifest__.py文件所在的目录名称，不带前导路径。 关闭Odoo实例，如果你是在生产环境中操作，请先进行数据库备份。 执行以下命令： 12$ odoo/odoo-bin -c instance.cfg -d dbname -u addon1 \\--stop-after-init 如果你在配置文件中设置了数据库名称，你可以忽略-d选项。 重启Odoo实例。 运行原理附加模块的安装和更新是两个紧密相关的过程，但是有一些重要的区别，如以下两节所强调。 安装当您安装插件时，Odoo会检查其可用附件列表中是否有带有提供名称的未安装的插件，还会检查该插件的依赖项，如果有依赖项，它将以递归方式安装它们。 单个模块的安装过程包括以下步骤： 如果有，运行插件的preinit挂钩。 从Python源代码加载模型定义，并在必要时更新数据库结构（有关详细信息，请参见第4章，应用程序模型）。 加载插件的数据文件，并在必要时更新数据库内容（有关详细信息，请参见第6章，管理模块数据）。 如果实例中已启用演示数据，安装附加演示数据。 如果有，运行插件的preinit挂钩。 对附加插件的视图定义进行验证。 如果启用了演示数据并启用了测试，运行附加组件的测试（有关详细信息，请参见第18章，自动测试用例）。 更新数据库中的模块状态。 从附加组件的翻译中更新数据库中的翻译（有关详细信息，请参见第11章，国际化）。 在__manifest__.py文件中分别使用pre_init_hook和post_init_hook key 定义了preinit和postinit hooks。 这些钩子用于在安装附加模块之前和之后调用Python函数。要了解有关init钩子的更多信息，请参阅第3章，创建Odoo附加模块。 更新更新插件时，Odoo会在可用插件模块列表中检查给定名称的已安装附件，还检查该附件的反向依赖关系（这些插件是取决于要更新的插件）。如果有的话，它也会递归地更新它们。 单个模块的更新过程包括以下步骤： 运行附加模块的预迁移步骤（如果有）（有关详细信息，请参见第6章，管理模块数据）。 从Python源代码加载模型定义，并在必要时更新数据库结构（有关详细信息，请参见第4章，应用程序模型）。 加载插件的数据文件，并在必要时更新数据库的内容（有关详细信息，请参见第6章，管理模块数据）。 如果实例中启用了演示数据，则更新加载项的演示数据。 如果您的模块有任何迁移方法，请运行附加的迁移后步骤（有关详细信息，请参阅第6章，管理模块数据）。 对加载项的视图定义进行验证。 如果启用了演示数据并启用了测试，请运行附加组件的测试（有关详细信息，请参见第18章，自动测试用例）。 更新数据库中的模块状态。 从附加组件的翻译中更新数据库中的翻译（有关详细信息，请参见第11章，国际化）。 请注意，更新未安装的附加模块根本没有任何作用，但是，安装已安装的附加模块会重新安装该附加模块，这可能会对某些包含文件数据的数据文件产生意外影响应该由用户更新，而不是在常规模块更新过程中更新（请参阅第6章，管理模块数据中的使用noupdate和forcecreate标志配方）。这种情况一般发生在从命令行界面更新模块，Web界面更新不会发生这种错误的风险。 更多内容请谨慎处理依赖项。考虑一个情况您要在实例中安装sale，sale_stock和sale_specific模块，sale_specific依赖于sale_stock，sale_stock依赖于sale。要安装这三个组件，您只需要安装sale_specific，因为它将递归地安装sale_stock和sale依赖项。要更新所有三个，您需要更新sale，因为这将递归更新反向依赖关系sale_stock和sale_specific。 管理依赖项的另一个棘手的部分是，当您向已经安装了版本的加载项中添加依赖项时。让我们继续前面的示例来理解这一点，假设您在sale_specific中添加了对stock_dropshipping的依赖关系。更新sale_specific加载项不会自动安装新的依赖关系，也不会请求安装sale_specific。在这种情况下，您会收到非常讨厌的错误消息，因为未能成功加载插件的Python代码，但是数据库中存在加载项的数据和模型表。要解决此问题，您需要停止实例并手动安装新的依赖项。 从GitHub安装插件模块GitHub是第三方加载项的绝佳来源。许多Odoo合作伙伴使用GitHub在内部共享他们维护的插件，Odoo社区协会（OCA）在GitHub上集体维护了数百个插件。在开始编写自己的插件之前，请确保已检查是否存在可以直接使用的内容。 此教程将向您展示如何从GitHub克隆OCA的合作伙伴的项目，以及如何在您的实例中使用其中包含的附加模块。 准备工作假设您要向客户（合作伙伴）表单添加新字段。通常情况下，Odoo客户模型没有性别字段，如果要添加性别字段，则需要创建一个新模块。幸运的是，邮件列表中的某人向您介绍了partner_contact_gender附加模块，该模块由OCA维护，作为 **partner-contact ** 联系项目的一部分。 此教程中使用的路径遵循了标准化实例目录布局教程中建议的布局。 如何实现安装 partner_contact_gender 模块，你需要执行以下步骤： 进入你的项目目录： 1$ cd ~/odoo-dev/my-odoo/src 克隆 partner-contact 项目的14.0分支代码到 src/ 目录： 12$ git clone --branch 14.0 \\https://github.com/OCA/partner-contact.git src/partner-contact 更改附件路径以包括该目录并更新实例的附件列表（请参阅本章中的配置附件路径配方和更新附件模块列表教程）。 instance.cfg的内容应如下所示： 1234addons_path = ~/odoo-dev/my-odoo/src/odoo/odoo/addons, \\~/odoo-dev/my-odoo/src/odoo/addons, \\~/odoo-dev/my-odoo/src/, \\~/odoo-dev/local-addons 安装partner_contact_gender附加插件（如果您不知道如何安装该模块，请查看上一教程安装和升级本地附加模块）。 运行原理所有Odoo社区协会代码存储库的插件模块都包含在单独的子目录中，这与Odoo对附件路径中的目录所期望的一致。因此，只需将存储库克隆到某个位置，然后将该位置添加到附加组件路径中就足够了。 更多内容一些维护者采用不同的方法，每个存储库都有一个附加模块，位于存储库的根目录中。在这种情况下，您需要创建一个新目录，将其添加到加载项路径，并从该目录中所需的维护者中克隆所有加载项。请记住，每次添加新的存储库克隆时，都要更新插件模块列表。 将更改应用到模块GitHub上可用的大多数附件都可能会发生更改，并且不遵循Odoo为其稳定版本强制执行的规则。他们可能会收到错误修复或增强功能，包括您提交的问题或功能请求，并且这些更改可能会在数据文件和视图中引入数据库架构更改或更新。本教程将介绍如何安装更新的版本。 准备工作假设您报告了partner_contact_gender的一个问题，并且收到有关该问题已在partner-contact项目的14.0分支的最新版本中解决的通知。在这种情况下，你想更新你的实例到最新的版本。 如何操作要将应用于来自GitHub的模块的源代码修改，您需要执行以下步骤： 停止你的Odoo实例。 如果这是生产数据库，请先进行数据库备份（请参阅第1章，安装Odoo开发环境中的管理Odoo服务器数据库教程）。 进入partner-contact模块目录： 1$ cd ~/odoo-dev/my-odoo/src/partner-contact 为项目创建一个本地标签，以便万一发生问题可以恢复到该版本： 12$ git checkout 14.0$ git tag 14.0-before-update-$(date --iso) 获取最新版本的代码： 1$ git pull --ff-only 更新数据库中的partner_address_street3模块（请参阅安装和升级本地加载项模块教程）。 运行原理通常，模块的开发人员有时会发布该加载项的最新版本。此更新通常包含错误修复和新功能。在这里，我们将获得该插件的新版本并在我们的实例中对其进行更新。 如果git pull --ff-only失败，则可以使用以下命令还原到以前的版本： 1$ git reset --hard 14.0-before-update-$(date --iso) 然后，您可以尝试git pull（不带--ff-only），这将导致合并，但这意味着您的模块本地代码被修改过。 也可以看看如果更新步骤中断，请参阅第1章，安装Odoo开发环境中的从源代码更新Odoo以获得恢复说明。请记住，始终先对生产环境的数据库副本进行更新测试。 应用并尝试建议的Pull Requests在Github的世界里，一个Pull Request(PR)是由开发者提出的请求，以便项目的维护者可以加入一些新的开发。例如一个PR可以修复Bug或者添加新的特性。这些请求在被合并到主分支之前都会进行审查和测试。 本节我们会介绍怎么应用一个PR到你的Odoo项目，以测试一个改进或修复一个错误。 准备工作就像之前的教程一样，假设你报告了一个 Partner_address_street3 的问题，并且受到一个通知，说这个问题已经在PR中解决了，但是还没被合并到14.0分支中。 开发者要求你严重PR #123中的修复。你需要用这个分支更新一个测试实例。 你不应该直接在生产数据库上尝试这种分支，所以首先要创建一个测试环境和生产数据库副本（详情可参考第一章，安装Odoo开发环境）。 如何实现要实现应用Github PR到模块上你需要进行以下步骤： 停止实例。 进入模块所在目录： 1$ cd ~/odoo-dev/my-odoo/src/partner-contact 为项目创建一个本地tag，以便你出现问题可以恢复到当前版本： 12$ git checkout 14.0$ git tag 14.0-before-update-$(date --iso) 拉取请求分支，最简单的方法就是使用PR的编号，这个编号应该是由开发者告知你的，在本例子中我们的PR号为123： 1$ git pull origain pull/123/head 重启实例后更新 partner_contact_gender1 模块（如果你不知道怎么操作，可参考安装和升级本地附件模块小节）。 测试更新，尝试重现你的问题，或者尝试你想要的新功能。 如果不能正常运行，可以到Github的PR页面进行评论，向开发者说明你做了什么和什么不能正常运行以便开发者更新PR。 如果能正常运行，也要评论PR页面，这是PR验证过程中必不可少的一部分，它将加快主分支的合并速度。 运行原理我们使用的是GitHub的一个特性，可以使用 pull/nnnn/head 分支名按编号拉取PR，其中nnnn是PR的编号。Git pull命令会将远程分支合并到我们的分支中，应用我们代码库中的改动。在这之后，我们更新附加模块，测试它，并向作者汇报任何失败或成功的变化。 更多内容如果你想同时测试不同的PR你可以重复上述教程的第4步。如果你对测试结果很满意，你可以创建一个分支来保留对应用的更改： 1$ git checkout -b 14.0-custom 使用不同的分支可以协助你记住你使用的不是Github的版本，而是你自定义的版本。 git branch命令可以用于列出你的本地仓库的所有分支。从此，如果你需要应用Githun 14.0的最新版本代码，你需要使用以下命令（不带–ff-only）： 1$ git pull origin 14.0","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%A1%E7%90%86Odoo%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14开发者指南第六章-管理模块数据【翻译】","text":"在本章中，我们将了解如何在安装附加模块时提供数据。在提供默认值、添加元数据（例如视图描述、菜单或操作）时对我们很有用。另一个重要的用途是提供演示数据，选中加载演示数据 复选框后，在创建数据库时加载演示数据。 在本章中，我们将介绍以下内容： 使用外部ID和命名空间 使用XML文件加载数据 使用noupdate 和forcecreate 标志 使用CSV文件加载数据 附加更新和数据迁移 从XML文件中删除记录 从XML文件调用函数 技术要求本章的技术要求包括在线的Odoo平台。 本章中使用的所有代码都可以从以下GitHub存储库下载： https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter06 为了避免重复大量代码，我们将使用第四章《应用模型》中定义的模型。要遵循这些示例，请确保从Chapter04/r6_hierarchy_model/my_library 获取my_library 模块的代码。 使用外部ID和命名空间Odoo中的外部ID或XML ID用于识别记录。到目前为止，在本书中，我们已经在视图、菜单和操作等领域使用了XML ID。但是，我们还没有看到XML ID的真正含义。本节会让你有更深入的了解。 实现步骤我们将写入已经存在的记录来演示如何使用跨模块引用： 更新my_library 模块的清单文件注册数据文件： 123'data': [ 'data/data.xml',], 在library.book 模型中创建一本新书： 123&lt;record id=&quot;book_cookbook&quot; model=&quot;library.book&quot;&gt; &lt;field name=&quot;name&quot;&gt; Odoo 14 Development Cookbook &lt;/field&gt;&lt;/record&gt; 更改主公司名称： 123&lt;record id=&quot;base.main_company&quot; model=&quot;res.company&quot;&gt; &lt;field name=&quot;name&quot;&gt;Packt publishing&lt;/field&gt;&lt;/record&gt; 安装模块以应用更改。安装后将创建新的书籍记录Odoo 14 Development Cookbook ，公司将更名为Packt publishing 。 运行原理XML ID是引用数据库中记录的字符串。ID本身是ir.model.data 模型的记录。该模型包含声明XML ID的模块名称、ID字符串、引用模型和引用ID等数据。 每次我们在&lt;record&gt; 标签上使用XML ID时，Odoo都会检查字符串是否已命名空间（即它是否正好包含一个点），如果没有，它会将使用当前模块名称作为命名空间。 然后，它会查找ir.model.data 中是否已经存在具有指定名称的记录。如果存在，则执行列出字段的UPDATE 语句； 如果不存在，则执行CREATE 语句。这是在记录已经存在时提供部分数据的方式，就像我们之前所做的那样。 在章的第一个示例中，记录的ID为book_cookbook 。由于它还没有命名，因此最终的外部ID将具有这样的模块名称：my_library.book_cookbook 。然后Odoo将尝试查找my_library.book_cookbook 的记录。 由于Odoo还没有该外部ID的记录，它将在library.book 模型中生成新记录。 在第二个示例中，我们使用了主公司的外部ID，即base.main_company。正如其命名空间所暗示的，它是从基本模块加载的。由于外部ID已经存在，而不是创建记录，Odoo将执行write(UPDATE) 操作更新公司名为Packt publishing 。 重要笔记除了更改其他模块定义的记录外，部分数据的广泛应用是使用快捷方式元素以方便的方式创建记录并在该记录上写入字段，快捷方式元素不支持： 1234&lt;act_window id=&quot;my_action&quot; name=&quot;My action&quot; model=&quot;res.partner&quot; /&gt;&lt;record id=&quot;my_action&quot; model=&quot;ir.actions.act_window&quot;&gt; &lt;field name=&quot;auto_search&quot; eval=&quot;False&quot;/&gt;&lt;/record&gt; 在本章的使用XML文件加载数据一节中使用的ref 函数也会在适当的情况下将当前模块添加为命名空间，但如果生成的XML ID不存在，则会引发错误。如果它还没有命名空间，这也适用于id属性。 提示如果您想查看所有外部标识符的列表，请激活开发者模式并打开菜单到Settings | Technical | Sequence &amp; Identifiers | ExternalIdentifiers 。 扩展内容您可能迟早需要通过Python代码访问具有XML ID的记录。在这些情况下使用self.env.ref() 函数。这将返回被引用记录的浏览记录（记录集）。请注意，在这里，您始终必须传递完整的XML ID。下面是一个完整的XML ID示例： 1&lt;module_name&gt;.&lt;record_id&gt; 您可以从用户界面查看任何记录的XML ID。为此您需要在Odoo中激活开发者模式。请参阅第一章《安装Odoo开发环境》激活开发者模式。激活开发人员模式后，打开要查找其XML ID的记录的表单视图。您将在顶部栏中看到一个bug图标。从该菜单中，单击View Metadata 选项。请参阅以下屏幕截图以供参考： 也可以看看请参阅本章的使用noupdate和forcecreate标志章节，了解为什么公司名称仅在模块安装期间更改。 使用XML文件加载数据在前面的章节中，我们使用外部标识符book_cookbook 创建了新的图书记录。在本节中，我们将从XML文件中添加不同类型的数据。我们将添加一本书和一位作者作为演示数据。我们还将在我们的模块中添加一个知名出版社作为常规数据。 实现步骤按照给定的步骤创建两个数据XML文件并将它们注册到您的__manifest__.py 文件中： 在demo 中将名为data/demo.xml 的文件添加到清单中： 123'demo': [ 'data/demo.xml',], 将以下内容添加到该文件中： 123456789101112131415161718192021&lt;odoo&gt; &lt;record id=&quot;author_pga&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Parth Gajjar&lt;/field&gt; &lt;/record&gt; &lt;record id=&quot;author_af&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Alexandre Fayolle&lt;/field&gt; &lt;/record&gt; &lt;record id=&quot;author_dr&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Daniel Reis&lt;/field&gt; &lt;/record&gt; &lt;record id=&quot;author_hb&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Holger Brunn&lt;/field&gt; &lt;/record&gt; &lt;record id=&quot;book_cookbook&quot; model=&quot;library.book&quot;&gt; &lt;field name=&quot;name&quot;&gt;Odoo Cookbook&lt;/field&gt; &lt;field name=&quot;short_name&quot;&gt;cookbook&lt;/field&gt; &lt;field name=&quot;date_release&quot;&gt;2016-03-01&lt;/field&gt; &lt;field name=&quot;author_ids&quot; eval=&quot;[(6, 0, [ref('author_af'), ref('author_dr'), ref('author_hb')])]&quot; /&gt; &lt;field name=&quot;publisher_id&quot; ref=&quot;res_partner_packt&quot; /&gt; &lt;/record&gt;&lt;/odoo&gt; 在data 部分中将名为data/data.xml 的文件添加到清单中： 1234'data': [ 'data/data.xml', ...], 将以下XML内容添加到data/data.xml 文件中： 1234567&lt;odoo&gt; &lt;record id=&quot;res_partner_packt&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Packt Publishing&lt;/field&gt; &lt;field name=&quot;city&quot;&gt;Birmingham&lt;/field&gt; &lt;field name=&quot;country_id&quot; ref=&quot;base.uk&quot; /&gt; &lt;/record&gt;&lt;/odoo&gt; 当你现在更新了你的模块，你会看到我们创建的出版社，如果你的数据库启用了演示数据，如第三章《创建Odoo附加模块》中所指出的，你还会找到这本书及其作者。 运行原理数据XML文件使用&lt;record&gt; 标签在数据库表中创建一行记录。&lt;record&gt; 标签有两个强制属性，id 和model 。对于id 属性，请参阅使用外部ID和命名空间章节；model 属性是指模型的_name 属性。然后，我们使用&lt;field&gt; 元素填充数据库中的列，由您命名的模型定义。该模型还决定必须填写哪些字段并定义默认值。在这种情况下，您不需要显式地为这些字段赋值。 有两种方法可以在模块清单中注册数据XML文件。一个带有data 键，第二个带有demo 键。每次安装或更新模块时都会加载data 键中的XML文件。仅当您为数据库启用演示数据时，才会加载带有demo 键的XML文件。 在第1步中，我们在清单中使用demo 注册了一个data XML文件。因为我们使用的是demo 键，所以只有在您为数据库启用了演示数据时才会加载XML文件。 在第2步中，在标量值的情况下，&lt;field&gt; 元素可以包含作为简单文本的值。如果您需要传递文件的内容（例如设置图像），请使用&lt;field&gt; 元素上的文件属性并传递相对于附加组件路径的文件名。 对于设置引用有两种方法。 最简单的是使用ref 属性，它适用于many2one 字段，并且只包含要引用的记录的XML ID。对于one2many 和 many2many 字段，我们需要使用eval 属性。这是一个通用属性，可用于运行Python代码来作为字段的值；例如使用strftime(‘%Y-01-01’) 来填充date 字段。X2many 字段应使用三个元素元组列表来填充，其中元组的第一个值决定要执行的操作。 在eval 属性中，我们可以访问一个名为ref 的函数，该函数返回以字符串传入的XML ID对应的数据库ID。这允许我们在不知道其具体ID的情况下引用记录，这在不同的数据库中可能不同，如下所示： (2, id, False) ：这将从数据库中删除带有id 的关联记录。 元组的第三个元素被忽略。 (3, id, False) ：取消带有id 的记录的从one2many 关联。请注意，此操作不会删除记录，它只是将现有记录保持原样。 元组的最后一个元素也被忽略。 (4, id, False) ：添加一个记录与id 的记录的关联，并且元组的最后一个元素被忽略。这是最常使用到的，通常会使用ref 函数来获取由其XML ID已知的记录的数据库ID。 (5, False, False) ：它会切断所有关联，但仍保持所关联的记录的完整性。 (6, False, [id,...]) ：这会清除当前引用的记录，以将它们替换为ID列表中的记录。元组的第二个元素被忽略。 在第3步和第4步与第1步和第2步相同，仅使用data 键替换了demo 键，这意味着每次安装或升级模块时都会加载XML文件。 重要笔记请注意，数据文件中的顺序是很重要的，并且数据文件中的记录只能引用列表中较早的数据文件中定义的记录。这就是为什么您应该始终检查您的模块是否安装在空数据库中的原因，因为在开发过程中，您经常会在各处添加记录，这是因为之后定义的记录已经在早期更新的数据库中。演示数据总是在data 键的文件之后加载，这就是本示例中的引用可生效的原因。 扩展内容虽然您基本上可以使用记录元素做任何事情，但有一些快捷元素可以让开发人员更方便地创建某些类型的记录。其中包括菜单项、模板和动作窗口。有关这些信息，请参阅第九章《后端视图》和第十四章《CMS网站开发》。 字段元素还可以包含函数元素，它调用模型上定义的函数来提供字段的值。请参阅从XML文件调用函数章节，在该章节里，我们只需调用一个函数直接写入数据库，绕过加载机制。 前面的列表缺少0 和1 的条目，因为它们在加载数据时不是很有用。为了完整起见，它们输入如下： (0, False, {'key': value}) ：这将创建引用模型的新记录，其字段从位置3 的字典中填充。元组的第二个元素被忽略。由于这些记录没有XML ID，并且每次更新模块时都会运行，从而导致重复条目，因此最好避免这种情况。相反，在它自己的记录元素中创建记录，并按照本节的工作原理部分中的说明关联它。 (1, id, {'key': value}) ：这可用于写入已关联的记录。出于我们前面提到的相同原因，您应该在XML文件中避免使用这种语法。 这些语法与我们在第五章《基本服务器端开发》中的创建新记录 和更新记录集记录的值 中解释的语法相同。 使用noupdate和forcecreate标志大多数附加模块具有不同类型的数据。有些数据只需要存在模块才能正常工作，其他数据不应该由用户更改，并且大多数数据可以根据用户的需要更改并且只是为了方便而提供。本节将详细说明如何处理不同的类型。首先，我们将在已经存在的记录中写入一个字段，然后我们将创建一个应该在模块更新期间重新创建的记录。 实现步骤通过在&lt;odoo&gt; 标签或&lt;record&gt; 标签上设置某些属性，我们可以在加载数据时强制执行不同的行为： 添加将在安装时创建但不会在后续更新中更新的发布者。但是，如果用户删除它，它将被重新创建： 1234567&lt;odoo noupdate=&quot;1&quot;&gt; &lt;record id=&quot;res_partner_packt&quot; model=&quot;res.partner&quot;&gt; &lt;field name=&quot;name&quot;&gt;Packt publishing&lt;/field&gt; &lt;field name=&quot;city&quot;&gt;Birmingham&lt;/field&gt; &lt;field name=&quot;country_id&quot; ref=&quot;base.uk&quot;/&gt; &lt;/record&gt;&lt;/odoo&gt; 添加图书类别，它在附加更新期间不会更改，如果用户删除它也不会重新创建： 12345&lt;odoo noupdate=&quot;1&quot;&gt; &lt;record id=&quot;book_category_all&quot; model=&quot;library.book.category&quot; forcecreate=&quot;false&quot;&gt; &lt;field name=&quot;name&quot;&gt;All books&lt;/field&gt; &lt;/record&gt;&lt;/odoo&gt; 运行原理&lt;odoo&gt; 标签可以有一个noupdate 属性，该属性会传递到第一次读取包含的数据记录时创建的ir.model.data 记录，从而最终成为该表中的一列。 当Odoo 安装一个插件（称为init 模式）时，所有记录都会被写入，无论noupdate 是True 还是False 。当您更新附加组件（称为update 模式）时，会检查现有XML ID以查看它们是否设置了noupdate 标志，如果是，则忽略尝试写入此XML ID的元素。如果有问题的记录被用户删除，则情况并非如此，这就是为什么您可以通过将记录上的forcecreate 标志设置为false 来强制在更新模式下不重新创建noupdate 记录。 重要笔记在旧版附加组件（包括8.0和之前的版本）中，您经常会发现一个&lt;openerp&gt; 元素包含一个&lt;data&gt; 元素，该元素包含&lt;record&gt; 和其他元素。这仍然是可能的，但已弃用。现在，&lt;odoo&gt; 、&lt;openerp&gt; 和&lt;data&gt; 具有完全相同的语义； 它们是用来括起XML数据的括号。 扩展内容如果您想使用noupdate 标志加载记录，您可以使用--init=your_addon 或-i your_addon 参数运行Odoo服务器。这将迫使Odoo重新加载您的记录。这也将导致重新创建已删除的记录。请注意，如果模块绕过XML ID机制，例如通过在&lt;function&gt; 标签调用的Python代码中创建记录，这可能会导致重复记录和相关的安装错误。 使用此代码，您可以绕过任何noupdate 标志，但首先，请确保这确实是您想要的。解决此处介绍的场景的另一个选项是编写迁移脚本，在附加更新和数据迁移章节中进行详细介绍。 也可看看Odoo还使用XML ID来跟踪插件更新后要删除的数据。如果记录在更新之前具有来自模块命名空间的XML ID，但在更新期间未恢复XML ID，则该记录及其XML ID将从数据库中删除，因为它们被认为已过时。有关此机制的深入讨论，请参阅附加更新和数据迁移章节。 使用CSV文件加载数据虽然您可以使用XML文件做任何事情，但当您需要提供大量数据时，这种格式并不是最方便的，尤其是考虑到许多人更愿意在Calc或其他电子表格软件中预处理数据。CSV格式的另一个优点是它是您使用标准导出功能时所得到的。在本节中，我们将看看导入类似表格的数据。 实现步骤一般情况下access-control lists（ACLs 请参阅第十章《安全访问》）是一种通过CSV文件加载的数据： 将security/ir.model.access.csv 添加到您的清单的data列表中： 1234'data': [ ... 'security/ir.model.access.csv',], 在这个文件中为我们的书籍添加一个 ACL（我们已经从第三章《创建Odoo附加模块》的添加访问安全 中获得了一些记录）： 12id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlinkacl_library_book_user,ACL for books,model_library_book,base.group_user,1,0,0,0 至此我们拥有一个ACL允许普通用户阅读书籍记录，但不允许他们编辑、创建或删除它们。 运行原理您只需将所有数据文件放入清单的data列表中。Odoo将使用文件扩展名来决定它是哪种类型的文件。CSV文件的一个特点是它们的文件名必须与要导入的模型的名称相匹配，在我们的例子中是ir.model.access 。 第一行需要是列名与模型的字段名完全匹配的标题。 对于标量值，您可以使用带引号的（如有必要，因为字符串本身包含引号或逗号）或不带引号的字符串。 当使用CSV文件编写many2one 字段时，Odoo首先尝试将列值解释为XML ID。 如果没有Odoo将当前模块名称添加为命名空间，并在ir.model.data 中查找结果。如果失败，模型的name_search 函数以列的值作为参数调用，返回的第一个结果。如果这也失败了，该行被认为是无效的并且Odoo会抛出一个错误。 重要笔记请注意，从CSV文件读取的数据始终为noupdate=False ，并且没有方便的解决方法。这意味着您的附加组件的后续更新将始终覆盖用户所做的可能更改。如果您需要加载大量数据并且需要noupdate 这对您来说是个问题，请使用init 钩子加载CSV文件。 扩展内容可以使用CSV文件导入one2many 和many2many 字段，但有点棘手。通常，您最好分别创建记录并随后使用XML文件设置关系，或者使用设置关系的第二个CSV文件。 如果您确实需要在同一文件中创建关联记录，请对列进行排序，以便所有标量字段位于左侧，链接模型的字段位于右侧，列标题由链接字段的名称和链接的 模型的字段，用冒号分隔： 12&quot;id&quot;,&quot;name&quot;,&quot;model_id:id&quot;,&quot;perm_read&quot;,&quot;perm_read&quot;, &quot;group_id:name&quot;&quot;access_library_book_user&quot;,&quot;ACL for books&quot;,&quot;model_library_book&quot;,1, &quot;my group&quot; 这将创建一个名为my group 的组；您可以通过在右侧添加列来在组记录中写入更多字段。如果您需要关联多条记录，请重复该行并根据需要更改右侧列。鉴于Odoo使用前一行的值填充空列，因此您不需要复制所有数据，添加一行时，对想要填充值的关联模型字段以外的字段只需使用空值。 附加更新和数据迁移您在编写附加模块时选择的数据模型可能会出现一些弱点，因此您可能需要在附加模块的生命周期中对其进行调整。为了在没有大量操作的情况下实现这一点，Odoo支持附加模块中的版本控制，并在必要时运行迁移。 实现步骤假设在我们模块的早期版本中date_release 字段是一个字符字段，人们在其中写下他们认为合适的任何日期作为日期。我们现在意识到我们需要这个字段来进行比较和聚合，这就是我们想要将其类型更改为Date 的原因。 Odoo在类型转换方面做得很好，但是在这种情况下，我们是靠自己的，这就是为什么我们需要提供有关如何使用安装在数据库上的先前版本的模块来转换数据库的说明，其中当前版本可以运行。让我们尝试以下步骤： 在__manifest__.py 文件中添加版本： 1'version': '13.0.1.0.1', 在migrations/13.0.1.0.1/pre-migrate.py 中提供预迁移代码： 12def migrate(cr, version): cr.execute('ALTER TABLE library_book RENAME COLUMN date_release TO date_release_char') 在migrations/13.0.1.0.1/post-migrate.py 中提供迁移后代码： 123456789101112131415from odoo import fieldsfrom datetime import datedef migrate(cr, version): cr.execute('SELECT id, date_release_char FROM library_book') for record_id, old_date in cr.fetchall(): # check if the field happens to be set in Odoo's internal format new_date = None try: new_date = fields.Date.to_date(old_date) except ValueError: if len(old_date) == 4 and old_date.isdigit(): # probably a year new_date = date(int(old_date), 1, 1) if new_date: cr.execute('UPDATE library_book SET date_release=%s',(new_date,)) 如果没有此代码，Odoo会将旧的date_release 列重命名为date_release_moved 并创建一个新列，因为没有从字符字段到日期字段的自动转换。从用户的角度来看，date_release 中的数据将完全消失。 运行原理第一个关键点是增加附加组件的版本号，因为迁移代码仅在版本变更时运行。在每次更新期间，Odoo将更新时清单中的版本号会写入ir_module_module 表。如果版本号包含三个或更少的组件，则版本号以Odoo的主要和次要版本作为前缀。在前面的示例中，我们明确命名了Odoo的主要版本和次要版本，这是一个很好的做法，但值为1.0.1 会产生相同的效果，因为在内部，Odoo会为带有自己主要版本和次要版本号的附加组件添加版本号前缀。通常使用长符号是一个好主意，因为您可以一眼看出插件适用于哪个版本的Odoo。 这两个迁移文件只是代码文件，不需要在任何地方注册。更新插件时，Odoo会将插件的版本（如ir_module_module 中所述）与插件清单中的版本进行比较。如果清单的版本更高（在添加Odoo的主要和次要版本之后），将搜索此插件的迁移文件夹以查看它是否包含中间版本的文件夹，直到当前更新版本的版本号。 然后在找到的文件夹中名称以pre- 开头的Python文件，加载它们，并为其定义一个名为migrate 的函数，该函数有两个参数。该函数以数据库游标作为第一个参数，当前安装的版本作为第二个参数调用。这一时间在Odoo查找插件定义的其它代码之前，因此你可以假定你的数据库结构对比此前版本没有做过任何修改。 在所有的pre-migrate 函数运行成功后，Odoo会加载模型和插件中声明的数据，这会导致数据库布局发生变化。鉴于我们在pre-migrate.py 中重命名了date_release ，Odoo将使用该名称创建正确的数据类型一个新列。 之后，使用相同的搜索算法，将搜索并执行迁移后的文件。在我们的例子中，我们需要查看每一个值，看看我们是否可以从中得到一些有用的东西；否则，我们将数据保持为NULL 。如果不是绝对必要，不要编写遍历整个表的脚本；在这种情况下，我们可能会编写一个很大且可读性差的SQL的switch语句。 重要提示如果您只是想重命名列，则不需要迁移脚本。在这种情况下，您可以将相关字段的oldname 参数设置为该字段的原始列名，Odoo会自动更新它。 扩展内容在迁移前和迁移后步骤中，您只能访问游标，如果您熟悉Odoo环境，这会变得不是很方便。在这个阶段使用模型可能会导致意想不到的结果，因为在预迁移步骤中，附加组件的模型尚未加载，并且在迁移后步骤中，由依赖于当前插件的插件定义的模型也尚未加载。 但是，如果这对您来说不是问题，也许是因为你想要使用你的插件所不涉及的模型或者是你已知这不会是一个问题的模型，那么就可以编写如下代码创建一个习惯的环境： 1234from odoo import api, SUPERUSER_IDdef migrate(cr, version): env = api.Environment(cr, SUPERUSER_ID, {}) # env holds all currently loaded models 也可以看看在编写迁移脚本时，您经常会遇到重复性任务，例如检查列或表是否存在、重命名或将一些旧值映射到新值。在这里重新发明轮子是令人沮丧和容易出错的；如果您负担得起额外的依赖，请考虑使用https://github.com/OCA/openupgradelib。 从XML文件中删除记录在前面的章节中，我们看到了如何从XML文件创建或更新记录。有时，您希望从依赖模块中删除以前创建的记录。这可以通过&lt;delete&gt; 标签来完成。 准备工作在本节中，我们将从XML文件中添加一些类别，后删除它们。在实际情况下，您将从另一个模块创建此记录。但为简单起见，我们将在同一个XML文件中添加一些类别，如下所示： 123456&lt;record id=&quot;book_category_to_delete&quot; model=&quot;library.book.category&quot;&gt; &lt;field name=&quot;name&quot;&gt;Test Category&lt;/field&gt;&lt;/record&gt;&lt;record id=&quot;book_category_not_delete&quot; model=&quot;library.book.category&quot;&gt; &lt;field name=&quot;name&quot;&gt;Test Category 2&lt;/field&gt;&lt;/record&gt; 实现步骤有两种方法可以从XML文件中删除记录： 使用先前创建的记录的XML ID： 1&lt;delete model=&quot;library.book.category&quot; id=&quot;book_category_to_delete&quot;/&gt; 使用搜索域： 1&lt;delete model=&quot;library.book.category&quot; search=&quot;[('name', 'ilike', 'Test')]&quot;/&gt; 运行原理您将需要使用&lt;delete&gt; 标签。要从模型中删除记录，您需要在模型属性中提供模型的名称。这是一个强制属性。 在第一种方法中，您需要提供先前从另一个模块的数据文件创建的记录的XML ID。在模块安装过程中，Odoo会尝试查找记录。如果找到给定XML ID的记录，它将删除该记录，否则将抛出错误。您只能删除从XML文件创建的记录（或具有XML ID的记录）。 第二种方法，需要在domain属性中传入domain 。在安装模块的过程中，Odoo会按这个domain搜索记录。如果找到记录，它将删除它们。如果没有记录与给定域匹配，则此选项不会抛出错误。使用此选项时要格外小心，因为它可能会删除用户的数据，因为搜索选项会删除与域匹配的所有记录。 警告&lt;delete&gt; 在Odoo中很少使用，因为它很危险。如果您对此不小心，您可能会破坏系统。尽可能避免它。 从XML文件调用函数您可以从XML文件创建所有类型的记录，但有时很难生成包含某些业务逻辑的数据。当用户在生产中安装依赖模块时，您可能希望修改记录。例如，假设您要创建一个模块来在线显示书籍。my_library 模块已经有一个image-cover 字段。 想象一下，在新模块中，您实现了减小图像大小并将其存储在新缩略图字段中的逻辑。现在，当用户安装这个模块时，他们可能已经有了书籍和图像。无法从XML文件中的&lt;record&gt; 标签生成缩略图。在这种情况下，您可以通过&lt;function&gt; 标签调用模型方法。 实现步骤本节我们将使用上节中的代码。例如，我们将现有图书价格提高10美元。请注意，您可能会根据公司配置使用其他货币。 按照以下步骤从XML文件调用Python方法： 在library.book 模型中添加_update_book_price() 方法： 12345@api.modeldef _update_book_price(self): all_books = self.search([]) for book in all_books: book.cost_price += 10 在数据XML文件中添加&lt;function&gt; ： 1&lt;function model=&quot;library.book&quot; name=&quot;_update_book_price&quot;/&gt; 运行原理在第1步中，我们添加了_update_book_price() 方法，该方法搜索所有书籍并将价格提高10美元。 以_ 开头的函数名称会被ORM认为是私有的，不能通过RPC调用。 在第2步中，我们使用了具有两个属性的&lt;function&gt; 标签： model ：声明方法的模型名称 name ：要调用的方法的名称 当您安装此模块时，_update_book_price() 将被调用，书籍的价格将增加10美元。 重要笔记始终将此功能与noupdate 选项一起使用。 否则，每次更新模块时都会调用它。 扩展内容使用&lt;function&gt; 还可以向函数传递参数。假设您只想提高特定类别书籍的价格，并且希望将该金额作为参数发送。 为此，您需要创建一个接受类别作为参数的方法，如下所示： 12345@api.modeldef update_book_price(self, category, amount_to_increase): category_books = self.search([('category_id', '=', category.id)]) for book in category_books: book.cost_price += amount_to_increase 要将类别和金额作为参数传递，需要使用eval 属性，如下： 123&lt;function model=&quot;library.book&quot; name=&quot;update_book_price&quot; eval=&quot;(ref('category_xml_id'), 20)&quot;/&gt; 当您安装该模块时，它会将给定类别的书籍的价格增加20美元。","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%95%B0%E6%8D%AE%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14开发者指南第五章-基本服务端开发【翻译】","text":"在第四章《应用模型》中，我们看到了如何在自定义模块中声明或扩展业务模型。那一章涵盖了计算字段的编写方法，以及约束字段的方法。本章重点介绍Odoo方法定义、记录集操作和扩展继承方法的服务器端开发基础知识。有了这个，您将能够在Odoo模块中添加/修改业务逻辑。 在本章中，我们将介绍以下内容： 定义模型方法和使用API装饰器 向用户报告错误 获取不同模型的空记录集 创建新记录 更新记录集记录的值 搜索记录 组合记录集 过滤记录集 遍历记录集关联 排序记录集 扩展模型中定义的业务逻辑 扩展write() 和create() 自定义搜索记录的方式 使用read_group() 分组获取数据 技术要求本章的技术要求包括可用的Odoo平台。 本章中使用的代码可以在https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter05下载。 定义模型方法和使用API装饰器在Odoo模型中，类定义了字段和业务逻辑方法。在第四章《应用模型》中，我们看到了如何将字段添加到模型中。现在我们将看到如何向模型添加方法和业务逻辑。 在本节中我们将看到如何编写一个可以被用户界面中的按钮或应用程序中的另一段代码调用的方法。此方法将作用于Library Books 并执行所需的操作以更改所选书籍的状态。 准备工作本节假设你已经准备好一个实例，并且my_library 模块可用，如第三章《创建Odoo附加模块》中所述。 您需要在Library Books 模型中添加一个state 字段，其定义如下： 123456789from odoo import models, fields, apiclass LibraryBook(models.Model): # [...] state = fields.Selection([ ('draft', 'Unavailable'), ('available', 'Available'), ('borrowed', 'Borrowed'), ('lost', 'Lost')], 'State', default=&quot;draft&quot;) 请参阅第三章《创建Odoo附加模块》，以获取更多信息。 实现步骤要在library books上定义一个方法来更改所选书籍的状态，您需要在模型定义中添加以下代码： 添加辅助方法来检查是否允许状态转换： 123456789@api.modeldef is_allowed_transition(self, old_state, new_state): allowed = [('draft', 'available'), ('available', 'borrowed'), ('borrowed', 'available'), ('available', 'lost'), ('borrowed', 'lost'), ('lost', 'available')] return (old_state, new_state) in allowed 添加一个方法以将某些书籍的状态更改为作为参数传递的新状态： 123456def change_state(self, new_state): for book in self: if book.is_allowed_transition(book.state, new_state): book.state = new_state else: continue 通过调用change_state 方法添加一个更改图书状态的方法： 12345678def make_available(self): self.change_state('available')def make_borrowed(self): self.change_state('borrowed')def make_lost(self): self.change_state('lost') 在&lt;form&gt; 视图中添加一个按钮和状态栏。这将帮助我们从用户界面触发这些方法： 12345678&lt;form&gt; ... &lt;button name=&quot;make_available&quot; string=&quot;Make Available&quot; type=&quot;object&quot;/&gt; &lt;button name=&quot;make_borrowed&quot; string=&quot;Make Borrowed&quot; type=&quot;object&quot;/&gt; &lt;button name=&quot;make_lost&quot; string=&quot;Make Lost&quot; type=&quot;object&quot;/&gt; &lt;field name=&quot;state&quot; widget=&quot;statusbar&quot;/&gt; ...&lt;/form&gt; 更新或安装模块以使这些更改可用。 运行原理本节的代码定义了一些方法。它们是普通的Python方法，它们的第一个参数是self ，也可以有其他参数。一些方法用odoo.api 模块中的装饰器装饰。 提示API装饰器最初是在Odoo 9.0中引入的，用于支持新旧框架。从Odoo 10.0开始，不再支持旧的API，但仍然使用一些装饰器，例如@api.model 。 编写新方法时，如果不使用任何装饰器，则该方法将在记录集上执行。在这样的方法中，self是一个可以引用任意数量的数据库记录（这包括空记录集），并且代码通常会循环遍历self 中的记录以对每个单独的记录执行某些操作。 @api.model 装饰器类似，但它用于仅对模型很重要的方法，而不是记录集的内容，方法不对其进行操作。 这个概念类似于Python的@classmethod 装饰器。 在第1步中，我们创建了is_allowed_transition() 方法。此方法的目的是验证从一种状态到另一种状态的转换是否有效。允许列表中的元组是可用的转换。例如，我们希望不允许从lost 状态转换到borrowed 状态，这就是我们没有加入('lost, 'borrowed')的原因。 在第2步中，我们创建了change_state() 方法。此方法的目的是更改图书的状态。调用此方法时，它将书的状态更改为new_state 参数给定的状态。如果允许转换它只会更改图书状态。我们在这里使用了一个for 循环，因为self 可以包含多个记录集。 在第3步中，我们通过调用change_state() 方法创建了更改图书状态的方法。在我们的例子中，这个方法将由添加到用户界面的按钮触发。 在第4步中，我们在&lt;form&gt; 视图中添加了&lt;button&gt; 标签。 单击此按钮后，Odoo Web 客户端将调用name 属性中的Python函数。 请参阅第九章《后端视图》中的向表单添加按钮 一节，了解如何从用户界面调用此类方法。我们还添加了带有状态栏小部件的状态字段，以在&lt;form&gt; 视图中显示图书的状态。 当用户从用户界面单击按钮时，将调用步骤3中的方法之一。在这里，self 将是包含library.book 模型记录的记录集。之后我们调用change_state() 方法并根据单击的按钮传递适当的参数。 当调用change_state() 时，self 是library.book 模型的相同记录集。change_state() 方法的主体循环遍历self 以处理记录集中的每一本书。循环遍历self 一开始看起来很奇怪，但你很快就会习惯这种模式。 在循环内部change_state() 调用is_allowed_transition() ,它使用book 局部变量进行的，但它可以在library.book 模型的任何记录集上进行，包括例如self ，因为is_allowed_transition() 是使用@api.model 修饰的。如果允许转换，则change_state() 通过为记录集的属性分配一个值来将新状态分配给书籍。这仅对长度为1 的记录集有效，用于确保和遍历self 的情况一致。 向用户报告错误在方法执行期间，有时需要中止处理，因为用户请求的操作无效或已满足错误条件。本节向你展示了如何通过显示有用的错误消息来管理这些情况。 准备工作本节假设你已经准备好一个实例，并且my_library 插件模块可用，如前一节中所述。 实现步骤我们将对上一节中的change_state 方法进行改造，并在用户尝试更改is_allowed_transition 方法不允许的状态时显示有用的消息。 执行以下步骤开始： 在Python文件的开头添加以下导入 12from odoo.exceptions import UserErrorfrom odoo.tools.translate import _ 修改change_state 方法并从else 部分抛出UserError 异常： 1234567def change_state(self, new_state): for book in self: if book.is_allowed_transition(book.state, new_state): book.state = new_state else: msg = _('Moving from %s to %s is not allowed') % (book.state, new_state) raise UserError(msg) 运行原理当Python中抛出异常时，它会向上传播调用堆栈，直到它被处理。在Odoo中，RPC (remote procedure call) 层会响应Web客户端捕获所有异常，并根据异常类在Web客户端上触发不同的行为。 odoo.exceptions 中未定义的任何异常都将作为内部服务器错误（HTTP状态500 ）与堆栈跟踪一起处理。UserError 将在用户界面中显示错误消息。本节的代码引发UserError 以确保消息以用户友好的方式显示。在所有情况下，当前数据库事务都会回滚。 我们正在使用一个名字奇怪的函数：_()，它是在odoo.tools.translate 中定义的。此函数用于将字符串标记为可翻译，并在运行时根据上下文中的语言检索已翻译的字符串。有关这方面的更多信息，请查阅第十一章《国际化》。 重要提示使用_() 函数时，请确保只传递带有插值占位符的字符串，而不是整个插值字符串。例如，_(‘Warning: could not find %s’) % value 是正确的，但_(‘Warning: could not find %s’ % value) 是不正确的，因为第一个字符串不能在翻译数据库中找到替换值。 扩展内容有时您正在处理容易出错的代码，这意味着您正在执行的操作可能会产生错误。Odoo将捕获此错误并向用户显示回溯。如果您不想向用户显示完整的错误日志，您可以缓存错误并使用有意义的消息引发自定义异常。在提供的示例中，我们从try…cache 块生成UserError，因此Odoo现在不会显示完整的错误日志，而是显示带有有意义消息的警告： 12345678def post_to_webservice(self, data): try: req = requests.post('http://my-test-service.com', data=data, timeout=10) content = req.json() except IOError: error_msg = _(&quot;Something went wrong during data submission&quot;) raise UserError(error_msg) return content 在odoo.exceptions 中定义了更多的异常类，它们都派生自基本的遗留的except_orm 异常类。它们中的大多数仅在内部使用，除了以下内容： ValidationError ：当不遵守字段上的Python约束时会引发此异常。请参阅第四章《应用模型》向模型添加约束验证 以获取更多信息。 AccessError ：当用户尝试访问不允许的内容时，通常会自动生成此错误。如果要显示代码中的访问错误，可以手动引发错误。 RedirectWarning ：使用此错误您可以显示带有错误消息的重定向按钮。你需要给这个异常传递两个参数：第一个参数是action ID，第二个参数是错误信息。 Warning ：在Odoo 8.0中，odoo.exceptions.Warning 与9.0及更高版本中的UserError 所起的作用是相同的。它现在已被弃用，因为该名称具有欺骗性（这是一个错误，而不是警告）并且它与Python内置的警告类发生冲突。它只是为了向后兼容而保留的，您应该在代码中使用UserError 。 获取不同模型的空记录集在编写Odoo代码时，当前模型的方法可以通过self 获得。如果您需要处理不同的模型，则无法直接实例化该模型的类；首先您需要获取该模型的记录集。 本节向您展示了如何在模型方法中为在Odoo中注册的任何模型获取空记录集。 准备工作本节将重用my_library 附加模块中库示例的设置。 我们将在library.book 模型中编写一个小方法并搜索所有library.members。为此我们需要为library.members 获取一个空记录集。确保您已添加library.members 模型和该模型的访问权限。 实现步骤要在library.book 的方法中获取library.members 的记录集，您需要执行以下步骤： 在LibraryBook 类中添加名为get_all_library_members 方法： 12345678class LibraryBook(models.Model): # ... def log_all_library_members(self): # This is an empty recordset of model library.member library_member_model = self.env['library.member'] all_members = library_member_model.search([]) print(&quot;ALL MEMBERS:&quot;, all_members) return True 在&lt;form&gt; 视图添加一个按钮来调用我们的方法： 1&lt;button name=&quot;log_all_library_members&quot; string=&quot;Log Members&quot; type=&quot;object&quot;/&gt; 更新模块以应用更改。之后您将在本书的&lt;form&gt; 视图中看到Log Members 按钮。单击该按钮后，您将在服务器日志中看到该成员的记录集。 运行原理在启动时Odoo加载所有模块并组合从模型派生的各种类，并定义或扩展给定模型。这些类存储在Odoo注册表中，按名称索引。任何记录集的env 属性（可用作self.env ）是odoo.api 模块中定义的Environment 类的一个实例。 Environment 类在Odoo开发中起着核心作用： 它通过模拟Python字典提供对注册表的快捷访问。如果您知道要查找的模型的名称，可通过self.env[model_name] 来获取该模型的空记录集。此外，记录集将共享self 的环境。 它有一个cr 属性，这是一个可以用来传递原生SQL 查询的数据库游标。有关这方面的更多信息，请参阅第八章《高级服务器端开发》中的执行原生SQL查询 。 它有一个user 属性，是对当前执行的用户的引用。请查看第八章《高级服务器端开发》中的更改执行操作的用户 以了解更多信息。 它有一个context 属性，这是一个包含调用上下文的字典。这包括有关用户语言、时区、当前记录选择等的信息。有关这方面的更多信息，请参阅第八章《高级服务器端开发》中的使用修改的上下文调用方法 方法一节。 对search() 的调用将在稍后的搜索记录中解释 也可以看看有时您想使用环境的修改版本，一个这样的例子是您想要一个具有不同用户和语言的环境。在第八章《高级服务器端开发》中您将学习如何在运行时修改环境。 创建新记录编写业务逻辑方法时的一个常见的要求是创建新记录。本节解释了如何创建library.book.category 模型的记录。对于我们的示例，我们将为library.book.category 模型创建虚拟类别的方法。要触发此方法，我们将在&lt;form&gt; 视图中添加一个按钮。 准备工作您需要知道要为其创建记录的模型的结构，尤其是它们的名称和类型，以及这些字段上存在的任何约束（例如其中一些是否是强制性的）。 本节我们将重用第四章《应用模型》的my_library 模块。看下面的例子快速回忆library.book.category 模型： 12345678910111213class BookCategory(models.Model): _name = 'library.book.category' name = fields.Char('Category') description = fields.Text('Description') parent_id = fields.Many2one( 'library.book.category', string='Parent Category', ondelete='restrict', index=True ) child_ids = fields.One2many( 'library.book.category', 'parent_id', string='Child Categories') 确保您已经为library.book.category 模型添加了菜单、视图和访问权限。 实现步骤要创建具有一些子类别，您需要执行以下步骤： 在library.book.category 模型中创建一个名为create_categories 的方法： 12def create_categories(self): ...... 在此方法的主体内，为第一个子类别的字段准备一个值字典： 1234categ1 = { 'name': 'Child category 1', 'description': 'Description for child 1'} 为第二类字段准备一个值字典： 1234categ2 = { 'name': 'Child category 2', 'description': 'Description for child 2'} 为父类别的字段准备一个值字典： 12345678parent_category_val = { 'name': 'Parent category', 'email': 'Description for parent category', 'child_ids': [ (0, 0, categ1), (0, 0, categ2), ]} 调用create() 方法创建新记录： 1record = self.env['library.book.category'].create(parent_category_val) 在&lt;form&gt; 视图中添加一个按钮以从用户界面触发create_categories 方法： 1&lt;button name=&quot;create_categories&quot; string=&quot;Create Categories&quot; type=&quot;object&quot;/&gt; 运行原理要为模型创建新记录，我们可以在与模型相关的任何记录集上调用create(values) 方法。此方法返回一个长度为1 的新记录集，其中包含新记录，其字段值在值字典中指定。 在字典中键是字段的名称，值是对应于字段的值。根据字段类型您需要为值传递不同的Python数据类型： Text 字段对应Python的字符串。 Float 和Interger 字段对应Python的浮点型和整型。 Boolean 字段对应Python的布尔型。 Date 字段对应Python的datetime.date对象。 Datetime 字段对应Python的datetime.datetime对象。 Binary 字段的值是Base64编码的字符串。Python标准库中的base64 模块提供了诸如encodebytes(bytestring) 之类的方法来对Base64 中的字符串进行编码。 Many2one 字段的值以整数形式给出，该整数必须是关联记录的数据库ID。 One2many 和Many2many 字段使用特殊语法，该值是一个包含三个元素的元组的列表，如下所示： Tuple Effect (0, 0, dict_val) 创建与主记录关联的新记录。 (6, 0, id_list) 在正在创建的记录和现有记录之间创建关联，其ID在名为id_list的Python列表中。 注意：当在One2many 字段上使用时，这会删除此前关联中的记录。 本节中我们为我们想要创建的公司中的两个联系人创建字典，然后我们使用我们解释过的(0, 0, dict_val) 语法在正在创建的公司的字典的child_ids 条目中使用这些字典。 在步骤5中调用create() 时，会创建三个记录： 一个用于父书类别，由create 返回。 子书类别的两条记录，在record.child_ids 中可用。 扩展内容如果模型为某些字段定义了一些默认值，则不需要做任何特别的事情。create() 将自动处理字典中不存在的字段的默认值。 create() 方法还支持批量创建记录。要批量创建多条记录，您需要将多个值的列表传递给create() 方法，如下例所示： 123456789categ1 = { 'name': 'Category 1', 'description': 'Description for Category 1'}categ2 = { 'name': 'Category 2', 'description': 'Description for Category 2'}multiple_records = self.env['library.book.category'].create([categ1, categ2]) 更新记录集记录的值业务逻辑通常要求我们通过更改某些字段的值来更新记录。本节向你展示了如何修改partner的date 字段。 准备工作本章将使用与上一节相同的library.book 定义。您可以参考这个简化的定义来了解这些字段。 我们在library.book 模型中有date_release 字段。出于说明目的，我们将通过单击按钮更新此字段。 实现步骤 要实现更新书籍的data_update 字段，你可以新增一个名为change_update_date() 的方法，它的定义如下： 123def change_release_date(self): self.ensure_one() self.date_release = fields.Date.today() 然后你需要在&lt;form&gt; 视图中添加一个按钮，定义如下： 1&lt;button name=&quot;change_release_date&quot; string=&quot;Update Date&quot; type=&quot;object&quot;/&gt; 重新启动服务器并更新my_library 模块以查看更改。单击更新日期按钮后，更新日期将更改。 运行原理该方法首先通过调用ensure_one() 检查作为self 传递的book 记录集是否恰好包含一条记录。如果不是这种情况，此方法将引发异常，并且处理将中止。这是必要的，因为我们不想更改多条记录的日期。如果要更新多个值，可以删除ensure_one() 并使用记录集上的循环更新属性。 最后，该方法修改书籍记录的属性值。它使用当前日期更新date_release 字段。只需修改记录集的字段属性，就可以进行写操作。 扩展内容如果您想将新值写入记录字段，可以使用三个选项： 选项一是本节中使用的选项。它通过将值直接分配给表示记录字段的属性，这种方法可用在所有上下文中。它不可能一次性为所有记录集元素赋值，因此您需要遍历记录集，除非您确定您只处理一条记录。 选项二是通过将字典映射字段名称传递给您要设置的值来使用update() 方法来赋值。这也仅适用于长度为1 的记录集。当您需要在同一笔记录一次更新多个字段的值时，它可以节省一些输入。将本节的第2步重写为以下内容来使用此选项： 1234567def change_update_date(self): self.ensure_one() self.update({ 'date_release': fields.Datetime.now(), 'another_field': 'value' ... }) 选项三是调用write() 方法，传递一个将字段名称映射到您要设置的值的字典。 此方法适用于任意大小的记录集，并且当前两个选项对每个记录和每个字段执行一次数据库调用时，将在一次数据库操作中使用指定值更新所有记录。但是，它有一些限制：如果数据库中还没有记录，它就不起作用（有关这方面的更多信息，请参阅第八章《高级服务器端开发》中的关于定义onchange方法 ）。此外，在编写关联字段时，它需要一种特殊的格式，类似于create() 方法使用的格式。查看下表以了解用于为关系字段生成不同值的格式： Tuple Effect (0, 0, dict_val) 这将创建一个与主记录关联的新记录。 (1, id, dict_val) 这将使用提供的值更新具有指定ID的关联记录。 (2, id) 这将从关联记录中删除具有指定ID的记录，并从数据库中删除。 (3, id) 这将从关联记录中删除具有指定ID的记录。该记录不会从数据库中删除。 (4, id) 这会将具有提供的ID的现有记录添加到相关记录列表中。 (5, ) 这将删除所有其他相关记录，相当于为每个关联id调用**(3, id)** 。 (6, 0, id_list) 这会在正在更新的记录与现有记录之间创建关联，其ID在名为id_list 的Python列表中。 重要提示操作类型 1、2、3和5 不能与create() 方法一起使用。 搜索记录搜索记录也是业务逻辑方法中的常见操作。本节向您展示如何按名称和类别查找书籍。 准备工作本章将使用与上一节相同的library.book 定义。我们将新增一个名为find_book(self) 的新方法。 实现步骤要查找书籍，您需要执行以下步骤： 在library.book 模型种添加find_book 方法： 12def find_book(self): ... 为您的条件编写搜索域： 1234567domain = [ '|', '&amp;', ('name', 'ilike', 'Book Name'), ('category_id.name', 'ilike', 'Category Name'), '&amp;', ('name', 'ilike', 'Book Name 2'), ('category_id.name', 'ilike', 'Category Name 2')] 使用域调用search() 方法，这将返回记录集： 1books = self.search(domain 书籍变量将有一个搜索书籍的记录集。您可以打印或记录该变量以在服务器日志中查看结果。 运行原理第1部定义方法。 第2步局部变量中创建搜索域。通常您会在搜索调用中看到这种创建内联，但对于复杂的域，最好单独定义它。 有关搜索域语法的完整说明，请参阅第九章《后端视图》中的在记录列表上定义域过滤器 。 第3步使用域调用search() 方法。该方法返回一个记录集，其中包含与域匹配的所有记录，然后可以进一步处理。在本节中我们只使用域调用方法，但也支持以下关键字参数： offset=N ：这用于跳过与查询匹配的前N 条记录。这可以与limit 一起使用来实现分页或在处理大量记录时减少内存消耗。它的默认值为0 。 limit=N ：表示最多返回N 条记录。默认情况下是没有限制。 order=sort_specification ：这用于返回的记录集中的排序。 默认情况下，顺序由模型类的_order 属性给出。 count=boolean ：如果为True ，则返回记录数而不是记录集。它默认为False 。 重要提示我们建议使用search_count(domain) 方法而不是search(domain, count=True) ，因为该方法的名称以更清晰的方式传达了行为。两者都会给出相同的结果。 有时您需要从另一个模型中搜索，以self 来搜索将返回当前模型的记录集。要从另一个模型中搜索，我们需要为模型获取一个空记录集。例如，假设我们要搜索一些联系人。为此，我们需要在res.partner 模型上使用search() 方法。请参考以下代码，这里我们得到res.partner 的空记录集来搜索联系人： 1234567def find_partner(self): PartnerObj = self.env['res.partner'] domain = [ '&amp;', ('name', 'ilike', 'Parth Gajjar'), ('company_id.name', '=', 'Odoo') ] partner = PartnerObj.search(domain) 在上面的代码中，你可以在域中省略’&amp; ‘，因为当你不指定域时，Odoo会默认使用’&amp; ‘。 扩展内容我们之前说过search() 方法返回所有匹配域的记录。这实际上并不完全正确。安全规则确保用户只获得他们具有读取 访问权限的那些记录。 此外，如果模型有一个名为active 的布尔字段，并且没有搜索域的术语在该字段上指定条件，则搜索会添加一个隐式条件以仅返回active=True 的记录。 因此，如果您希望搜索返回某些内容，但只得到空记录集，请确保检查active 字段的值（如果存在）以检查记录规则。 有关不添加隐式active=True 条件的方法，请参阅第八章《高级服务器端开发》中的使用不同上下文调用方法一节。查看第十章《安全访问》中的使用记录规则限制记录访问 了解有关记录级访问规则的更多信息。 如果由于某种原因，您需要自己编写原生SQL查询来查找记录ID，请确保使用self.env[‘record.model’].search([(‘id’, ‘in’, tuple(ids)) ]).ids 在检索ID之后以确保应用安全规则。这在使用记录规则来区分的多公司的Odoo实例中尤其重要。 组合记录集有时，您会发现您获得的记录集并非您所需要的。本节将展示各种组合它们的方法。 准备工作在开始学习本节内容之前，你需要有两个或多个相同模型的记录集。 实现步骤执行以下步骤以对记录集执行常见操作： 要将两个记录集合并为一个，同时保留它们的顺序，请使用以下操作： 1result = recordset1 + recordset2 要将两个记录集合并为一个，同时确保结果中没有重复项，请使用以下操作： 1result = recordset1 | recordset2 要查找两个记录集共有的记录，请使用以下操作: 1result = recordset1 &amp; recordset2 运行原理记录集的类重载了各种Python的运算符。以下是可用于记录集的最有用的Python运算符的汇总表： Oprator Action performed R1 + R2 这将返回一个新记录集，其中包含来自R1的记录，然后是来自R2的记录。这会在记录集中生成重复记录。 R1 - R2 这将返回一个新记录集，其中包含R1中不在R2中的记录，保留排序。 R1 &amp; R2 这将返回一个新记录集，其中包含属于R1和R2的所有记录（记录集的交集）。此处不保留顺序，但没有重复。 R1 R2 R1 == R2 如果两个记录集包含相同的记录，则为True 。 R1 &lt;= R2 如果R1中的所有记录都是R2的子集，则为True 。 R1 &lt; R2 如果R1中的所有记录都是R2的子集，则为True 。 R1 &gt;= R2 如果R1中的所有记录都是R2的超集，则为True 。 R1 &gt; R2 如果R1中的所有记录都是R2的超集，则为True 。 R1 != R2 如果R1和R2不包含相同的记录，则为True 。 R1 in R2 如果R1（必须是一条记录）是R2的一部分，则为True 。 R1 not in R2 如果R1（必须是一条记录）不属于R2，则为True 。 还有就地运算符，+=、-=、&amp;= 和 |=，它们是修改左侧操作数而不是创建新记录集。这些在更新记录的One2many 或Many2many 字段时非常有用。有关此示例，请参阅更新记录集记录的值。 过滤记录集在某些情况下，您已经有一个记录集，但您只需要对某些记录进行操作。当然，您可以对记录集进行迭代，检查每次迭代的条件并根据检查结果采取行动。构造一个只包含感兴趣的记录并在该记录集上调用单个操作的新记录集可能更容易，并且在某些情况下更有效。 本节展示了如何使用filter() 方法根据条件提取记录集的子集。 准备工作我们将重用创建新记录一节中显示的简化library.book 模型。本节定义了一种从提供的记录集中提取具有多个作者的书籍的方法。 定义接受原始记录集的方法 12@api.modeldef books_with_multiple_authors(self, all_books): 定义一个内部谓词函数： 1234def predicate(book): if len(book.author_ids) &gt; 1: return True return False 调用filter() ，如下： 1return all_books.filter(predicate) 您可以打印或记录此方法的结果以在服务器日志中查看它。有关更多信息，请参阅本节的示例代码。 运行原理filter() 方法的实现会创建一个空记录集。谓词函数计算结果为True 的所有记录都添加到这个空记录集中。最终返回新记录集。原始记录集中的记录顺序被保留。 前面的例子使用了一个命名的内部函数。对于这样简单的谓词，您经常会发现使用了一个匿名Lambda 函数： 123@api.modeldef books_with_multiple_authors(self, all_books): return all_books.filter(lambda b: len(b.author_ids) &gt; 1) 实际上，您需要根据字段的值在Python意义上为真（非空字符串、非零数字、非空容器等）这一事实来过滤记录集。因此，如果要过滤具有类别集合的记录，可以像这样传递字段名称进行过滤：all_books.filter(‘category_id’) 。 扩展内容请记住filter() 是在内存中运行的。如果您需要在关键路径上优化方法的性能，您可能希望使用搜索域甚至迁移到SQL，但以牺牲可读性为代价。 遍历记录集关联使用长度为1 的记录集时，各种字段可用作记录属性。关联属性（One2many 、Many2one 和Many2many ) 也可用于记录集的值。例如，假设我们要从library.book 模型的记录集中访问类别的名称。您可以通过遍历Many2one 字段的category_id 来访问类别名称，如下所示：book.category_id.name。但是，当使用具有多个记录的记录集时，不能使用属性。 本节向你展示了如何使用mapped() 方法来遍历记录集关系。我们将编写一个方法来从书籍记录集中检索作者姓名，并作为参数传递。 准备工作本章重用与创建新记录相同的library.book 模型。 实现步骤要从图书记录集中获取作者姓名，您需要执行以下步骤： 定义一个名为get_author_name() 的函数： 12@api.modeldef get_author_name(self, books): 调用mapped() 获取partner的联系人邮箱地址： 1return books.mapped('author_ids.name') 运行原理第1步只是定义方法。第2步我们调用mapped(path) 方法遍历记录集的字段；path 是一个字符串，其中包含用点分隔的字段名称。对于路径中的每个字段，mapped() 生成一个新记录集，其中包含与该字段相关的所有记录与当前记录集中的所有元素，然后路径中的下一个元素应用于该新记录集。如果路径中的最后一个字段是关联字段，则mapped() 将返回一个记录集；否则，返回的是Python列表。 mapped() 方法有两个有用的属性： 如果路径是单个标量字段名称，则返回的列表与处理的记录集的顺序相同。 如果路径包含关联字段，则不会保留顺序，但会从结果中删除重复项。 重要信息当您想对self 中的所有记录的Many2many 字段指向的所有记录执行操作时，第二个属性非常有用，但是您需要确保该操作只执行一次（即使self 中的两个记录共享同一个目标记录）。 扩展内容使用mapped() 时，请记住它在Odoo服务器内部的内存中运行的，通过重复遍历关联并因此进行SQL查询，这效率可能不高。但是，这种代码更简洁且可读性高。如果您尝试在实例性能的关键路径上优化方法，您可能需要重写对mapped() 的调用并以适当的域以search() 进行表现，或者甚至转移到SQL（代码可读性成本增加）。 mapped() 方法也可以通过函数作为参数来调用。在这种情况下，它返回一个列表，包含应用于self 每条记录的函数的结果列表，或者返回在函数返回的是记录集的情况下由该函数返回的记录集的并集。 也可以看看 搜索记录章节。 第八章《高级服务器端开发》中的执行原生SQL查询章节。 排序记录集当您使用search() 方法获取记录集时，您可以传递一个可选参数order 来获取特定排序的记录集。如果您已经拥有来自前一段代码的记录集并且想要对其进行排序，这将非常有用。如果您使用集合操作来组合两个记录集，它也可能很有用，例如，这会导致排序丢失。 本节向你展示了如何使用sorted() 方法对现有记录集进行排序。我们将按发行日期对书籍进行排序。 准备工作本章重用与创建新记录相同的library.book 模型。 实现步骤您需要执行以下步骤来获取基于release_date 排序的图书记录集： 定义名为sort_books_by_date() ： 12@api.modeldef sort_books_by_date(self, books): 如给定示例所示，使用sorted() 方法根据release_date 字段对图书记录进行排序： 1return books.sorted(key='release_date') 运行原理第1步只是定义方法。在步骤2中，我们调用书籍记录集中的sorted() 方法。在内部，sorted() 方法将获取作为键参数传递的字段的数据。然后，通过使用Python的原生排序方法，返回一个排序的记录集。 它还有一个可选参数reverse=True ，它以相反的顺序返回一个记录集。反向使用如下： 1books.sorted(key='release_date', reverse=True) 扩展内容sorted() 方法将对记录集中的记录进行排序。不带参数调用，默认使用模型的_order 属性来排序。也可以传递一个函数以与Python内置的sorted(sequence, key) 函数相同的方式计算比较。 重要笔记当使用模型默认的_order参数时，排序会在数据库中进行，执行新的SELECT函数获取排序。否则排序由Odoo执行。根据所操作的内容以及记录集的大小，可能存在一些重要的性能差异。 扩展模型中定义的业务逻辑在Odoo中，将应用程序功能划分为不同的模块是一种非常常见的做法。通过这样做，您可以通过安装/卸载应用程序来简单地启用/禁用功能。而且，当您向现有应用程序添加新功能时，就需要自定义在原始应用程序中定义的某些方法的行为。有时，您还想向现有模型添加新字段。这在Odoo中是一项非常简单的任务，也是底层框架最强大的功能之一。 在本节中，我们将看到如何从另一个模块中的方法扩展一个方法的业务逻辑。我们还将从新模块向现有模块添加新字段。 准备工作对于本节我们将继续使用上一节中的my_library 模块。确保在my_library 模块中有library.book.category 模型。 对于本节我们将创建一个名为my_library_return 的新模块，它依赖于my_library 模块。在新模块中，我们将管理借书的归还日期。我们还将根据类别自动计算归还日期。 在第四章《应用模型》中的使用继承向模型添加功能小节中，我们看到了如何向现有模型添加字段。在这个模块中，需要扩展library.book 模型如下： 123class LibraryBook(models.Model): _inherit = 'library.book' date_return = fields.Date('Date to return') 然后扩展library.book.category 模型，如下： 123456class LibraryBookCategory(models.Model): _inherit = 'library.book.category' max_borrow_days = fields.Integer( 'Maximum borrow days', help=&quot;For how many days book can be borrowed&quot;, default=10) 要在视图中添加此字段，您需要遵循第九章《后端视图》中的更改现有视图-视图继承 章节。您可以在https://github.com/PacktPublishing/Odoo-13-Development-Cookbook-Fourth-Edition找到完整的代码示例。 实现步骤要扩展library.book 模型中的业务逻辑，您需要执行以下步骤： 在my_library_return 中，当我们将图书状态更改为已借阅时，我们希望在图书记录中设置date_return 。 为此，我们将重写my_module_return 模块中的make_borrowed 方法： 1234def make_borrowed(self): day_to_borrow = self.category_id.max_borrow_days or 10 self.date_return = fields.Date.today() + timedelta(days=day_to_borrow) return super(LibraryBook, self).make_borrowed() 我们还想在图书归还时重置date_return ，因此我们将重写make_available 方法来重置日期： 123def make_available(self): self.date_return = False return super(LibraryBook, self).make_available() 运行原理步骤1和2对业务逻辑进行了扩展。我们定义了一个扩展的library.books 模型，并重新定义了make_borrowed() 和make_available() 方法。在这两个方法的最后一行，返回的是父类实现的结果： 1return super(LibraryBook, self).make_borrowed() 对于Odoo模型，通过查看Python类定义，父类并不是您所期望的。框架为我们的记录集动态生成了一个类层次结构，父类是我们依赖的模块中模型的定义。因此使用super() 方法从my_module 中调用library.book 中的实现。 本例中的make_borrowed() 需要将图书的状态更改为已借阅。 因此使用super() 调用父类中的方法并将图书状态设置为已借阅。 扩展内容在本节中我们选择扩展默认的实现方法。在make_borrow() 和make_available() 方法中，我们在super() 调用之前修改了返回的结果。请注意，当您调用super() 时，它将执行父类中的逻辑。也可以在super() 调用之后执行一些操作。当然，我们也可以同时做这两件事。 但是，更改方法中间的行为更加困难。为此我们需要重构代码，以便我们可以将扩展点提取到单独的方法中，并在扩展模块中重写这个新方法。 您可能很想完全重写一个方法。这样做时要非常小心。如果您不调用方法的 super() 实现，您将破坏扩展机制并可能破坏扩展方法的附加组件，这意味着永远不会调用扩展方法。除非您在受控环境中工作，您确切知道安装了哪些附加组件，并且您已经检查过您没有破坏它们，请避免这样做。此外如果必须确保以非常明显的方式记录您正在做的事情。 在调用方法的原始实现之前和之后可以做什么？有很多东西包括（但不限于）以下内容： 修改传递给原始实现的参数（之前） 修改传递给原始实现的上下文（之前） 修改原始实现返回的结果（之后） 调用另一个方法（之前和之后） 创建记录（之前和之后） 在禁止的情况下（之前和之后）抛出UserError 错误以取消执行 将self 拆分为更小的记录集，并以不同的方式（之前）在每个子集上调用原始实现 扩展write()和create()本章的扩展模型中定义的业务逻辑一节向我们展示了如何扩展定义在模型类上的方法。您应该知道，在父类模型上定义的方法也是模型的一部分。这意味着models.Model 上定义的所有基础方法（实际上是models.BaseModel ，它是models.Model 的父类）也是可用的并且可以扩展。 本节向你展示了如何扩展create() 和write() 来控制对记录的某些字段的访问。 准备工作我们将使用第三章《创建Odoo附加模块》中的my_library 模块来扩展。 将manager_remarks 字段添加到library.book 模型。我们只希望Library Managers 组的成员能够写入该字段： 1234from odoo import models, api, exceptionsclass LibraryBook(models.Model): _name = 'library.book' manager_remarks = fields.Text('Manager Remarks') 将manager_remarks 字段添加到view/library_book.xml 文件的&lt;form&gt; 视图，以便从用户界面访问此字段： 1&lt;field name=&quot;manager_remarks&quot;/&gt; 修改security/ir.model.access.csv 文件，为Library用户提供写入权限： 123id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlinkacl_book_user,library.book_default,model_library_book,base.group_user,1,1,0,0acl_book_librarian,library.book_librarian,model_library_book,group_librarian,1,1,1,1 实现步骤为了防止非librarian组成员的用户修改manager_remarks 的值，您需要执行以下步骤： 扩展create() 方法，如下： 123456789@api.modeldef create(self, values): if not self.user_has_groups('my_library.group_librarian'): if 'manager_remarks' in values: raise UserError( 'You are not allowed to modify ' 'manager_remarks' ) return super(LibraryBook, self).create(values) 扩展write() 方法，如下： 12345678def write(self, values): if not self.user_has_groups('my_library.group_librarian'): if 'manager_remarks' in values: raise UserError( 'You are not allowed to modify ' 'manager_remarks' ) return super(LibraryBook, self).write(values) 安装模块以查看运行中的代码。现在只有manager类型的用户可以修改manager_remarks 字段。要测试此实现，您可以以demo用户登录或撤销当前用户的图书管理员访问权限。 运行原理第1步重新定义create() 方法。在调用create() 的基础实现之前，我们的方法使用user_has_groups() 方法检查用户是否属于my_library.group_librarian 组（这是组的XML ID）。如果用户不属于my_library.group_librarian 组并且为manager_remarks 传递了一个值，则会抛出UserError 异常，从而阻止创建记录。此检查应放在调用父类实现之前执行。 第2步对write() 方法执行相同的操作。在写入之前，我们检查组和值中是否存在要写入的字段，如果有问题则抛出UserError 异常 重要笔记当在Web客户端中将该字段设置为只读时不会阻止RPC调用写入它。这就是我们扩展create() 和write() 的原因。 在本节中，你已经看到了如何重写create() 和write() 方法。 但请注意，这不仅限于create() 和write() 方法。您可以重写任何模型方法。例如假设您想在删除记录时执行某些操作。为此您需要重写unlink() 方法（删除记录时会调用unlink() 方法）。下面是重写unlink() 方法的小代码片段： 123def unlink(self): # 这里写你的业务逻辑 return super(LibraryBook, self).unlink() 警告在Odoo中重写方法时，千万不要忘记调用super() 方法，否则会遇到问题。这是因为当你不使用super() 方法时，父类方法中的代码永远不会执行。如果在我们之前的代码片段中，我们没有调用**super(…).unlink()**，则记录不会被删除。 扩展内容在扩展write() 时，请注意在调用write() 的super() 实现之前，self仍然是未修改的。您可以使用它来将字段的当前值与值字典中的值进行比较。 在本节中，我们选择了抛出异常，但我们也可以选择从值字典中删除有问题的字段，并默默地跳过更新记录中的该字段： 12345def write(self, values): if not self.user_has_groups( 'my_library.group_librarian'): if 'manager_remarks' in values: del values['manager_remarks'] return super(LibraryBook, self).write(values) 在调用super().write() 之后，如果你想执行额外的操作，你必须警惕任何可能导致再次调用write() 的事情，否则你将创建一个无限递归的循环。解决方法是在上下文中放置一个标记，以便检查以中断递归： 12345678class MyModel(models.Model): def write(self, values): sup = super(MyModel, self).write(values) if self.env.context.get('MyModelLoopBreaker'): return self = self.with_context(MyModelLoopBreaker=True) self.compute_things() # can cause calls to writes return sup 在前面的示例中，我们在compute_things() 方法之前添加了MyModelLoopBreaker 键。因此，如果再次调用write() 方法，它不会进入无限循环。 自定义搜索记录的方式在第四章《应用模型》中的定义模型表现及排序 ，介绍了name_get() 方法，该方法用于计算不同位置的记录表示，包括用于显示Many2one 关联的小部件。 本节向您展示如何通过重新定义name_search 在Many2one 小部件中按标题、作者或ISBN搜索一本书。 准备工作对于本节，我们将使用以下模型定义： 12345678910111213class LibraryBook(models.Model): _name = 'library.book' name = fields.Char('Title') isbn = fields.Char('ISBN') author_ids = fields.Many2many('res.partner', 'Authors') def name_get(self): result = [] for book in self: authors = book.author_ids.mapped('name') name = '%s (%s)' % (book.name, ', '.join(authors)) result.append((book.id, name)) return result 使用此模型时，Many2one 小部件中的一本书显示为书名(作者1, 作者2…) 。 用户希望能够输入作者的姓名并找到根据此姓名过滤的列表，但这不会起作用，因为name_search 的默认实现仅使用模型类的_rec_name 属性所引用的属性，在我们的例子是'name' 。我们还希望允许按ISBN编号进行过滤。 实现步骤您需要执行以下步骤： 为了能够通过书名、作者或ISBN号搜索library.book ，您需要在LibraryBook 类中定义name_search() 方法，如下所示： 12345678910@api.modeldef _name_search(self, name='', args=None, operator='ilike', imit=100, name_get_uid=None): args = [] if args is None else args.copy() if not(name == '' and operator == 'ilike'): args += ['|', '|', ('name', operator, name), ('isbn', operator, name), ('author_ids.name', operator, name) ] return super(LibraryBook, self)._name_search(name=name, args=args, operator=operator, limit=limit, name_get_uid=name_get_uid) 在library.book 模型中添加名为old_editions 的Many2one 字段以测试_name_search 实现： 1old_edition = fields.Many2one('library.book', string='Old Edition') 将以下字段添加到用户界面： 1&lt;field name=&quot;old_edition&quot; /&gt; 重新启动并更新模块以反映这些更改。 您可以通过在old_edition Many2one 字段中来调用_name_search 方法搜索。 运行原理name_search() 的默认实现实际上只调用_name_search() 方法，它完成了真正的工作。这个_name_search() 方法有一个额外的参数name_get_uid，它在一些极端情况下使用，例如如果你想使用sudo() 或不同的用户来计算结果。 我们将收到的大部分参数原封不动地传递给方法的super() 实现： name 是一个字符串，其中包含用户输入的值。 args 是None 或用作可能记录的预过滤器的搜索域。（例如它可以来自Many2one 关联的域参数。） operator 是包含匹配运算符的字符串。一般来说，你会有'ilike' 或'='。 limit 是要检索的最大行数。 name_get_uid 可用于在调用name_get() 以计算要在小部件中显示的字符串时指定不同的用户。 我们对该方法的实现执行以下操作： 如果args 为None，它会生成一个新的空列表，否则会生成args 的副本。我们制作一个副本以避免我们对列表的修改对调用者产生副作用。 然后，我们检查name 不是空字符串或者操作符不是'ilike' 。这是为了避免生成一个不过滤任何内容的哑域[('name', ilike, '')] 。在这种情况下，我们直接跳转到super() 调用实现。 如果我们有name ，或者如果operator 不是'ilike' ，那么我们会在args 中添加一些过滤条件。在我们的例子中，我们添加了对所提供名称在图书标题、ISNB 或作者姓名中搜索的语句。 最后，我们使用args 中修改的域调用super() 实现，并强制name 为'' 和operator 为 ilike 。我们这样做是为了强制_name_search() 的默认实现不改变它接收的域，因此将使用我们指定的域。 扩展内容我们在介绍中提到，这个方法用在Many2one 小部件中。为了完整起见，它也用于Odoo 的以下部分： 在域中的One2many 和Many2many 字段上使用in 运算符时 在many2many_tags 小部件中搜索记录 在CSV文件中搜索记录导入 也可以看看第四章《应用模型》中的定义模型表现及排序 介绍了如何定义name_get() 方法，该方法用于创建记录的文本表示。第九章《后端视图》中的在记录列表上定义过滤器-域 提供了有关搜索域语法的更多信息。 使用read_group()分组获取数据在之前章节中，我们看到了如何从数据库中搜索和获取数据。但有时，您希望通过汇总记录获得结果，例如上个月销售订单的平均成本。通常我们在SQL查询中使用group by 和aggregate 函数来获得这样的结果。幸运的是在Odoo中，我们有read_group() 方法。在本节中，你将学习如何使用read_group() 方法来获取聚合结果。 准备工作本节我们将使用第三章《创建Odoo附加模块》中的my_library 模块。 修改library.book 模型，如下模型定义所示： 12345678class LibraryBook(models.Model): _name = 'library.book' name = fields.Char('Title', required=True) date_release = fields.Date('Release Date') pages = fields.Integer('Number of Pages') cost_price = fields.Float('Book Cost') category_id = fields.Many2one('library.book.category') author_ids = fields.Many2many('res.partner', string='Authors') 添加library.book.category 模型。为简单起见，我们只需将其添加到同一个library_book.py 文件中： 1234class BookCategory(models.Model): _name = 'library.book.category' name = fields.Char('Category') description = fields.Text('Description') 我们将使用library.book 模型并获得每个类别的平均成本价格。 实现步骤为了提取分组结果，我们将_get_average_cost 方法添加到library.book 模型中，该模型将使用read_group() 方法获取组中的数据： 12345678@api.modeldef _get_average_cost(self): grouped_result = self.read_group( [('cost_price', &quot;!=&quot;, False)], # Domain ['category_id', 'cost_price:avg'], # Fields to access ['category_id'] # group_by ) return grouped_result 要测试此实现，您需要在用户界面中添加一个按钮来触发此方法。然后，您可以在服务器日志中打印结果。 运行原理read_group() 方法在内部使用SQL group by 和 aggregate 函数来获取数据。传递给read_group() 方法的最常见参数如下： domain :这用于过滤记录以进行分组。有关域的更多信息请参阅第九章《后端视图》中的搜索视图 章节。 fields :这将传递您要与分组数据一起获取的字段的名称。此参数的可能值如下： field name ：可以将字段名称传递给fields 参数，但如果使用此选项，则必须将此字段名称也传递给groupby 参数，否则会产生错误。 field_name:agg：可以通过aggregate 函数传递字段名称。例如，在cost_price:avg 中，avg 是一个SQL聚合函数。可以在https://www.postgresql.org/docs/current/static/functions-aggregate.html 找到PostgreSQL聚合函数的列表。 name:agg(field_name)：这与前一个相同，但使用此语法，您可以提供列别名，例如average_price:avg(cost_price) 。 groupby :此参数接受字段描述列表。记录将根据这些字段进行分组。对于日期和时间列，您可以通过groupby_function 根据不同的持续时间应用日期分组，例如date_release:month 。这将应用基于月份的分组。 read_group() 还支持一些可选参数，如下： offset ：这表示要跳过的记录数。 limit ：这表示要返回的最大记录数。 orderby ：如果使用了这个选项，结果将根据给定的字段进行排序。 lazy ：这接收布尔值，默认情况下为True 。如果为True ，则结果仅按第一个groupby 分组，其余groupby 放在__context 键中。如果为False ，则所有groupby 函数都在一次调用中完成。 性能提示read_group() 比从记录集中读取和处理值要快得多。 因此，对于KPI或图表，您应该始终使用read_group() 。 扩展内容","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14开发者指南（Development Cookbook）第四版【翻译】","text":"由于个人需要最近在学习Odoo14，我参考的书籍是《Odoo 14 Development Cookbook Fourth Edition》，随便翻译一下作为学习笔记。 前言Odoo 14开发者指南第四版提供了各种完整的开发方案，以帮助您使用Odoo框架构建复杂的业务应用程序。 无论您是要自定义现有模块，创建新模块还是自定义网站或后端Web客户端（JS），这本书都涵盖了Odoo开发的各个方面。 凭借其最新版本，强大的Odoo框架发布了用于快速应用程序开发的多种功能。此更新的Odoo开发指南将帮助您探索Odoo 14中的新功能，并学习如何使用它们从头开始开发Odoo应用程序。您将学习Odoo 14中的新网站概念，并了解Odoo的新Web客户端框架OWL（Odoo Web Library）。 完成安装后，您将开始通过实际示例探索Odoo框架。 然后，您将从头创建一个新的Odoo模块，并逐步发展到高级框架概念。您还将学习如何修改现有应用程序，包括销售点（PoS）。这本书不仅限于后端开发；您会发现用于创建新视图和小部件的高级JavaScript Recipes。随着您的学习进程，您将学习网站开发，并通过研究性能优化，调试和自动化测试来成为一名优质的Odoo开发人员。最后，您将深入研究高级概念，例如多网站，应用程序内购买（IAP），Odoo.sh，IoT Box和部署。 您将使用动态构组件构建漂亮的Odoo CMS网站；掌握高级概念，例如缓存，预取和调试；使用新的OWL框架修改后端JavaScript组件和POS；通过远程过程调用（RPC）连接并访问Odoo中的任何对象；使用Odoo.sh来管理、部署和测试Odoo实例；配置IoT Box以添加和升级POS硬件，并了解如何实施IAP服务。 到本书结尾，您将拥有构建令人印象深刻的Odoo应用程序所需的全部知识，并且您将精通开发最佳实践，这些最佳实践将在使用Odoo框架时变得非常有用。 本书适用于本书适合希望使用Odoo框架开发高效业务应用程序的新手和有经验的Odoo开发人员。要充分利用本书，必须具备Python和JavaScript的基本知识。 本书涵盖的内容 第一章：安装Odoo开发环境，说明如何为Odoo创建开发环境，启动Odoo，创建配置文件以及激活Odoo的开发者工具。 第二章：管理Odoo服务器实例，提供了一些有用的技巧，可用于处理从GitHub安装的附加组件以及组织实例的源代码。 第三章：创建Odoo附加模块，介绍了Odoo附加模块的结构，并提供了从头开始创建简单模块的分步指南。 第四章：应用程序模型，着重于Odoo模型结构，并解释所有类型的字段及其属性。它还涵盖了通过扩展模块扩展现有数据库结构的技术。 第五章：基本的服务器端开发，介绍了在Odoo中执行CRUD操作的各种框架方法。本章还包括继承和扩展现有方法的不同方法。 第六章：管理模块数据，显示如何将数据与模块代码一起运送。它还说明了在新发行版中修改了附件提供的数据模型时如何编写迁移脚本。 第七章：调试模块，提出了一些用于服务器端调试的策略，并介绍了Python调试器。它还介绍了在开发人员模式下运行Odoo的技术。 第八章：先进的服务器端开发技术，涵盖了ORM框架的更多高级主题。这对于开发向导，SQL视图，安装挂钩，更改方法等很有用。 本章还说明了如何在数据库中执行原始SQL查询。 第九章：后端视图，介绍了如何为数据模型编写业务视图以及如何从这些视图调用服务器端方法。它涵盖了常规视图（列表视图，表单视图和搜索视图），以及一些复杂的视图（看板，图形，日历，枢轴等）。 第十章：安全访问，介绍如何通过创建安全组，编写访问控制列表来定义给定模型上的每个组可以使用哪些操作，以及在必要时编写记录级规则来控制谁有权访问您的Odoo实例中的内容。 第十一章：国际化，介绍了语言翻译在Odoo中的工作方式。它显示了如何安装多种语言以及如何导入/导出翻译的术语。 第十二章：自动化，工作流，电子邮件和打印，介绍了Odoo中可用于实现记录业务流程的不同工具。它还显示了如何使用服务器操作和自动规则来支持业务规则。这也涵盖了生成动态PDF文档的QWeb报告。 第十三章：Web服务器开发，涵盖了Odoo Web服务器的核心。它显示了如何创建自定义URL路由以在给定URL上提供数据，还显示了如何控制对这些URL的访问。 第十四章：CMS网站开发，展示了如何使用Odoo管理网站。它还显示了如何创建和修改漂亮的网页和QWeb模板。本章还包括如何使用选项创建动态构件块。它包括一些用于管理SEO，用户表单，UTM跟踪，站点地图以及获取访问者位置信息的专用配方。本章还重点介绍了Odoo中多网站的最新概念。 第十五章：Web客户端开发，深入到Odoo的JavaScript部分。它介绍了如何创建新的字段窗口小部件以及如何对服务器进行RPC调用。这也包括如何从头开始创建全新的视图。您还将学习如何创建入职游览。 第十六章：Odoo Web库（OWL），介绍了称为OWL的新客户端框架。它涵盖了OWL组件的生命周期。它还涵盖了从零开始创建字段小部件的配方。 第十七章：Odoo的应用内购买，涵盖了与Odoo中IAP最新概念相关的所有内容。在本章中，您将学习如何为IAP创建客户端和服务模块。您还将学习如何创建IAP帐户以及如何从最终用户那里获得IAP信用。 第十八章：自动化测试用例，包括如何编写和执行自动化测试用例。这包括服务器端和客户端测试用例。本章还介绍了巡回测试用例，以及如何设置无头Chrome浏览器以获取失败的测试用例的视频。 第十九章：使用Odoo.sh进行管理，部署和测试，说明了如何使用PaaS平台Odoo.sh来管理，部署和测试Odoo实例。 它介绍了如何管理不同类型的实例，例如生产，登台和开发。本章还介绍了Odoo.sh的各种配置选项。 第二十章：Odoo中的远程过程调用涵盖了从外部应用程序连接Odoo实例的不同方法。本章教您如何通过XML-RPC，JSON-RPC和odoorpc库连接和访问Odoo实例中的数据。 第二十一章：性能优化，介绍了用于提高Odoo性能的不同概念和模式。本章包括预取，ORM高速缓存以及对代码进行性能分析以检测性能问题的概念。 第二十二章：销售点，涵盖PoS应用程序中的自定义。 这包括自定义用户界面，添加新的操作按钮，修改业务流程以及扩展客户配方。 第二十三章：在Odoo中管理电子邮件，介绍了如何在Odoo中管理电子邮件和聊天。 首先从配置邮件服务器开始，然后移至Odoo框架的邮件API。本章还介绍了Jinja2和QWeb邮件模板，表单视图上的聊天记录，字段日志和活动。 第二十四章：管理IoT Box，可让您重点了解IoT Box的最新硬件。本章介绍如何配置，访问和调试IoT Box。它还包括将IoT Box与您的自定义加载项集成的方法。 本书包括Odoo的安装步骤，因此您唯一需要的就是Ubuntu 18.04或任何其他基于Linux的操作系统。 在其他操作系统上，您可以通过虚拟机使用它。 如果您使用的是Windows还可以将Ubuntu安装为子系统： Odoo版本 OS需求 Odoo v14 推荐使用Ubuntu（或者其他Linux发行版） 由于Odoo后端在Python上运行，因此该书适用于具有Python编程语言基础知识的开发人员。在Odoo中，数据文件是使用XML创建的，因此需要XML的基本知识。 本书还介绍了后端JavaScript框架，PoS应用程序和网站构建器，它们需要JavaScript，jQuery和Bootstrap 4的基本知识。Odoo社区版是开源的，可免费获得，但其中包括一些功能，包括IoT， 队列和仪表板仅在企业版中可用，因此要遵循该食谱，您将需要企业版。 要遵循第24章，管理IoT Box，您将需要Raspberry Pi 3 B +模型，该模型可从https://www.raspberrypi.org/products/raspberrypi-3-model-b-plus/获得。 如果您使用的是本书的数字版本，建议您自己键入代码或通过GitHub存储库（下一节中提供的链接）访问代码。 这样做将帮助您避免与代码复制和粘贴相关的任何潜在错误。 下载示例代码文件您可以从GitHub上的https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition下载此书的示例代码文件。 如果代码有更新，它将在现有的GitHub存储库中进行更新。 我们还提供了丰富的书籍和视频目录中的其他代码包，可从https://github.com/PacktPublishing/获得。 去看一下！ 下载彩色图像我们还提供了一个PDF文件，其中包含本书中使用的屏幕截图/图表的彩色图像。 您可以在这里下载：https://static.packt-cdn.com/downloads/9781800200319_ColorImages.pdf","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%EF%BC%88Development-Cookbook%EF%BC%89%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14打印PDF中文显示乱码解决方法","text":"安装字体： 12$ sudo apt-get install ttf-wqy-zenhei$ sudo apt-get install ttf-wqy-microhei 安装完成后重启服务。","link":"/Odoo14%E6%89%93%E5%8D%B0PDF%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"Odoo14开发者指南第四章-应用模型【翻译】","text":"本章中的教程将对现有的附加模块稍稍进行补充。在上一章中，我们在Odoo实例中注册了我们的附加模块。在本章中，我们将对模块的数据库方面进行深入的探讨。我们将添加一个新模型（数据库表）、新字段和约束。我们还将研究Odoo中模型的继承使用。本章中我们将继续使用在第三章中创建的附加模块。本章中包含以下小节： 定义模型表现及排序 向模型添加数据字段 使用可配置精度的浮点型字段 向模型添加货币字段 向模型添加关联字段 添加模型层次结构 向模型添加约束验证 向模型添加计算字段 暴露存储在其他模型中的相关字段 使用引用字段添加动态关联 使用继承向模型添加功能 使用继承复制模型定义 使用代理继承将功能复制至另一个模型 使用抽象模型实现可复用的模型功能 技术要求您应该拥有我们在第三章创建的模块，并且该模块必须可以使用。本章中使用的所有代码都可以从https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter04上下载。 定义模型表现及排序模型中使用结构性属性来定义模型的行为，这些属性是前缀带下划线的。_name 属性是模型中最重要的属性，它是模型的内部全局标识符，Odoo会根据_name 属性来创建数据库表。例如：模型的_name=”library.book” ，Odoo的ORM会在数据库中创建名为library_book 的表。模型的_name 属性在整个Odoo实例中必须是唯一的。在模型中可以使用另外两个属性： _rac_name ：用于设置用作记录的表示或标题的字段。 _order ：用于设置记录的排序。 准备工作你需要准备好一个带有my_library 模块的Odoo实例（第三章中创建的模块）。 实现过程my_library 模块应该已经包含一个名为models/library_book.py 的Python文件，它定义了一个基本模型。我们将对其进行编辑，在_name 之后添加一个新的类级属性： 要为模型添加用户友好的标题，请添加以下代码： 1_description = 'Library Book' 要首先对记录进行排序（从最新到最旧，然后按标题排序），请添加以下代码： 1_order = 'date_release desc, name' 要将short_name 字段用作记录的显示，请添加以下代码： 12_rec_name = 'short_name'short_name = fields.Char('Short Title', required=True) 在表单视图中添加short_name 字段，以便它可以在视图中显示新字段： 1&lt;field name=&quot;short_name&quot;/&gt; 完成后，我们的library_book.py 文件应如下所示： 123456789101112from odoo import models, fieldsclass LibraryBook(models.Model): _name = 'library.book' _description = 'Library Book' _order = 'date_release desc, name' _rec_name = 'short_name' name = fields.Char('Title', required=True) short_name = fields.Char('Short Title', required=True) date_release = fields.Date('Release Date') author_ids = fields.Many2many('res.partner', string='Authors') library_book.xml 文件中的&lt;form&gt; 视图将如下所示： 123456789101112&lt;form&gt; &lt;group&gt; &lt;group&gt; &lt;field name=&quot;name&quot;/&gt; &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot;/&gt; &lt;/group&gt; &lt;group&gt; &lt;field name=&quot;short_name&quot;/&gt; &lt;field name=&quot;date_release&quot;/&gt; &lt;/group&gt; &lt;/group&gt;&lt;/form&gt; 然后我们需要升级模块以激活Odoo中的这些更改。要更新模块，您可以打开Apps 菜单，搜索my_library 模块，然后通过下拉列表更新模块，如下图所示： 或者，您也可以在命令行中使用-u my_library 命令来更新模块。 运行原理第一步为模型的定义添加一个对用户更友好的标题。这不是强制性的，但可以为一些附加组件使用。例如，邮件插件模块中的跟踪功能将它用于创建新记录时的通知文本。 有关详细信息，请参阅第二十三章，在Odoo中管理电子邮件。如果您的模型不使用_description ，在这种情况下，Odoo将在日志中显示警告信息。 默认情况下，Odoo使用内部id值（自动生成的主键）对记录进行排序。但是，这可以更改，我们可以通过提供一个包含字段名以逗号隔开的字符串作为_order 属性，字段名称后可以跟desc 关键字以降序排列。 重要提示只能使用存储在数据库中的字段。非存储计算域不能用于对记录进行排序；_order 字符串的语法类似于SQL ORDER BY子句，不允许使用例如NULLS FIRST等特殊子句； 模型记录在被其他记录引用时使用的一种表示形式。例如，user_id值为1的 员用户代表的管理员用户。当在表单视图中显示时，Odoo将显示用户名，而不是数据库ID。简而言之，_rec_name 是用于Odoo界面上显示记录的名称。默认情况下，使用的是name 字段。事实上，这是_rec_name 属性的默认值。在我们的示例中，library.book 模型有一个name 字段，因此，默认情况下，Odoo将使用它作为显示名称。我们第3步中使用了short_name 作为_rec_name 。之后，library.book 模型的显示名称从name 更改为了short_name ，Odoo显示界面将使用short_name 的值来展示记录。 警告如果您的模型没有name 字段并且在这种情况下您也没有指定_rec_name ，那么您的显示名称将是模型名称和记录ID的组合，如下所示：(library.book, 1) 。 由于我们向模型添加了一个新字段short_name ，Odoo的ORM将向数据库表添加一个新列，但它不会在视图中显示该字段。为此，我们需要将此字段添加到表单视图中。在第4步中，我们将short_name 字段添加到表单视图中。 扩展内容记录的展示也可以在一个神奇的计算display_name 设置，并且自8.0版以来已自动添加到所有模型中。它的值是使用name_get() 模型方法生成的，该方法在当前版本的Odoo中已经存在。 name_get() 的默认实现使用_rec_name 属性来查找哪个字段保存数据，用于生成显示名称。如果您想要自己实现显示名称的方法，您可以覆盖name_get() 的逻辑以生成自定义显示名称。该方法必须返回一个包含两个元素的元组列表：记录的ID和记录的Unicode字符串。 例如，要在显示中包含标题及其发布日期，例如Moby Dick (1851-10-18) ，我们可以定义以下内容： 123456def name_get(self): result = [] for record in self: rec_name = &quot;%s (%s)&quot; % (record.name, record.date_release) result.append((record.id, rec_name)) return result 添加上述代码后，您的display_name 记录将被更新。假设您有一个名为Odoo Cookbook 的记录和发布日期为19-04-2019 ，那么前面的name_get() 方法会生成一个这样的名字Cookbook (19-04-2019) 。 向模型添加数据字段模型用于存储数据，并且这些数据是按字段构造的。在这里，您将了解可以存储在字段中的几种数据类型，以及如何将它们添加到模型中。 准备工作你需要准备好一个带有my_library 模块的Odoo实例（第三章中创建的模块）。 实现过程my_library 模块应该已经有models/library_book.py 定义了一个基本模型。 我们将对其进行编辑以添加新字段： 使用最少的语法添加字段到Libraty Book 模型： 123456789101112131415161718192021from odoo import models, fieldsclass LibraryBook(models.Model): # ... short_name = fields.Char('Short Title') notes = fields.Text('Internal Notes') state = fields.Selection( [('draft', 'Not Available'), ('available', 'Available'), ('lost', 'Lost')], 'State') description = fields.Html('Description') cover = fields.Binary('Book Cover') out_of_print = fields.Boolean('Out of Print?') date_release = fields.Date('Release Date') date_updated = fields.Datetime('Last Updated') pages = fields.Integer('Number of Pages') reader_rating = fields.Float( 'Reader Average Rating', digits=(14, 4), # Optional precision decimals, ) 我们在模型中添加了新字段。我们仍然需要将这些字段添加到表单视图中，以便在用户界面中反映这些更改。参考以下代码在表单视图中添加字段： 123456789101112131415161718192021&lt;form&gt; &lt;group&gt; &lt;group&gt; &lt;field name=&quot;name&quot;/&gt; &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot;/&gt; &lt;field name=&quot;state&quot;/&gt; &lt;field name=&quot;pages&quot;/&gt; &lt;field name=&quot;notes&quot;/&gt; &lt;/group&gt; &lt;group&gt; &lt;field name=&quot;short_name&quot;/&gt; &lt;field name=&quot;date_release&quot;/&gt; &lt;field name=&quot;date_updated&quot;/&gt; &lt;field name=&quot;cover&quot; widget=&quot;image&quot; class=&quot;oe_avatar&quot;/&gt; &lt;field name=&quot;reader_rating&quot;/&gt; &lt;/group&gt; &lt;/group&gt; &lt;group&gt; &lt;field name=&quot;description&quot;/&gt; &lt;/group&gt;&lt;/form&gt; 升级模块将使这些更改在 Odoo 模型中生效。查看如下这些不同字段的示例。这里我们对字段使用了不同类型的属性。这会让读者对字段声明拥有更好的概念： 1234567891011short_name = fields.Char('Short Title',translate=True, index=True)state = fields.Selection( [('draft', 'Not Available'), ('available', 'Available'), ('lost', 'Lost')], 'State', default=&quot;draft&quot;)description = fields.Html('Description', sanitize=True, strip_style=False)pages = fields.Integer('Number of Pages', groups='base.group_user', states={'lost': [('readonly', True)]}, help='Total book page count', company_dependent=False) 运行原理通过在其Python类中定义一个属性，将字段添加到模型中。可用的非关系字段类型如下： Char 用于字符串值。 Text 用于多行字符串值。 Selection 用于选择列表。这是一个值和描述的列表。所选择的值会存储在数据库中，可以是字符串或整型。描述可自动翻译。 重要提示在Selection类型的字段中，值您可以使用整数，但注意Odoo会将0解释为内部未设置，如果存储的值为0，则不会显示描述。因此您需要考虑到这一点。 Html 类似于文本字段，通常以HTML格式存的储富文本。 Binary 二进制字段存储二进制文件，例如图像或文档。 Boolean 布尔类型，存储True/False 值。 Date 用于存储日期值。在数据库中以日期存储。在ORM中以Python日期对象的形式处理。您可以使用fields.Date.today() 将当前日期设置为日期字段中的默认值。 Datetime 用于存储日期时间值。在数据库中以原生UTC 时区存储。在ORM中以Python日期时间对象的形式处理。您可以使用fields.Date.now() 将当前时间设置为DateTime字段中的默认值。 Integer 字段无需进一步解释。 Float 字段存储数值。精度可以用总位数和小数位数来定义。 Monetary 可以存储某种货币的金额。这也将在本章的向模型添加货币字段 中进行解释。 本小节第一步展示了添加到每个字段类型的最小语法。第二步中扩展了字段定义的其他可选属性。这是对使用的字段属性的解释： string 是字段的标题，用于Odoo界面视图标签。它是可选的。如果未设置，自动通过字段名首字母大写，并用空格替换下划线规则产生。 translate 当设置为True 时，该字段可翻译。该字段可以根据用户界面设置的语言来保存不同的值。 default 字段的默认值，也可以设置为一个计算默认值的函数；例如：default = _computer_default，其中_compute_default 是在字段定义之前在模型上定义的方法。 help 是显示在界面提示中的说明文本。 groups 使该字段仅对某些安全组可用。它是一个字符串，包含以逗号分隔的安全组XML ID列表。这在第十章《安全访问》 中有更详细的说明。 states 允许用户界面根据state 字段的值来动态设置readonly 、required 和invisible 属性的值。因此，它需要state 字段存在并在表单视图中使用（即使它是隐藏的）。状态属性的名称在Odoo中是硬编码的，不能更改。 copy 标记在复制记录时是否复制字段值。默认情况下，非关联字段和Many2one 字段为True，One2many 和计算字段为 False。 index 当设置为True 时，为该字段会创建一个数据库索引。它替换了已弃用的select=1属性。 readonly 标志该字段在用户界面中默认为只读。 required 标志该字段在用户界面中默认为必填项。 这里提到的各种白名单在odoo/tools/mail.py 中定义。 company_dependent 标志该字段按不同的公司存储不同的值。取代了已弃用的Property 字段类型。 group_operator 是一个聚合函数，用于在group by 模式下显示结果。此属性的可能值包括count 、count_distinct 、array_agg 、bool_and 、bool_or 、max 、min 、avg 和sum 。整数、浮点数和货币字段类型此属性的默认值为sum 。 sanitize 标志用于HTML字段，并从可能不安全的标签中去除其内容。使用它执行输入的全局清理。 如果您需要对HTML清理进行更精细的控制，可以使用以下属性，这些属性仅在启用sanitize 时才有效： sanitize_tags=True：删除不属于白名单的标签（这是默认设置） sanitize_attributes=True：删除不属于白名单的标签的属性 sanitize_style=True：删除不属于白名单的样式属性 strip_style=True：删除所有样式元素 strip_class=True：删除类属性 最后，我们根据模型中新增的字段更新了表单视图。我们在这里以任意方式放置 &lt;field&gt; 标记，但您也可以将它们放置在任何您想要的位置。表单视图在第九章《后端视图》 中有更详细的解释。 扩展内容Selection 字段还接受函数引用作为其选择属性而不是列表。这允许动态生成选项列表。您可以在本章的使用引用字段添加动态关联 一节中找到与此相关的示例，其中也使用了选择属性。 Date 和Datetime 字段对象公开了一些方便的实用方法。 对于Date ，我们有以下内容： fields.Date.to_date(string_value) ：将字符串解析为日期对象。 fields.Date.to_string(date_value) ：将Python Date对象转换为字符串。 fields.Date.today() ：以字符串格式返回当前日期。这适用于默认值。 fields.Date.context_today(record, timestamp) ：根据记录（或记录集）上下文的时区，以字符串格式返回时间戳的日期（如果省略时间戳，返回当前日期）。 对于Datetime ，我们有以下内容： fields.Datetime.to_datetime(string_value) ：将字符串解析为日期时间对象。 fields.Datetime.to_string(datetime_value) ：将日期时间对象转换为字符串。 fields.Datetime.now() ：以字符串格式返回当前日期和时间。这适用于默认值。 fields.Datetime.context_timestamp(record, timestamp) ：将原生的时间戳Datime对象转换到记录的上下文中的时区。这不适用于默认值，但可用于将数据发送到外部系统的实例。 除了基本字段，我们还有关系字段：Many2one 、One2many 和Many2many 。这些在本章的向模型添加关联字段 中进行了解释。 也可以有具有自动计算值的字段，使用计算字段 属性定义计算函数。这在向模型添加计算字段 中进行了说明。 在Odoo模型中默认添加了一些字段，因此我们不应该为我们的字段使用这些名称。这些是id字段，用于记录自动生成的标识符，以及一些审计日志字段，如下所示： create_date ：记录创建的时间戳。 create_uid ：记录创建的用户。 write_date ：记录最后一次修改的时间戳。 write_uid ：记录最后一次修改的用户。 可以通过设置_log_access=False 模型属性来禁用这些日志字段的自动创建。另一个特殊字段是active 。它必须是一个布尔字段，允许用户将记录标记为非活动。它用于启用记录的归档/取消归档功能。其定义如下： 1active = fields.Boolean('Active', default=True) 默认情况下，只有active 属性设置为True 的记录才可见，要检索它们，我们需要使用带有[(‘active’, ‘=’, False)] 的域过滤器。或者，如果'active_test': False值被添加到环境的上下文中，ORM将不会过滤掉非活动记录。 在某些情况下，您可能无法修改上下文以获取活动记录和非活动记录。在这种情况下，您可以使用[‘|’, (‘active’, ‘=’, True), (‘active’, ‘=’, False)] 域过滤器。 警告[(‘active’, ‘in’ (True, False))] 不像你想象的那样工作。Odoo明确地在域中寻找* (‘active’, ‘=’, False)* 子句。它将默认将搜索限制为仅活动记录。 使用可配置精度的浮点型字段使用浮点字段时，我们可能希望让用户可配置要使用的小数精度。在本节中，我们将向Library Books模型添加一个成本价格字段，该字段具有用户可配置的小数精度。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤执行以下步骤以将动态小数精度应用于模型的cost_price 字段： 从设置菜单中的链接激活开发人员模式（请参阅第一章安装Odoo开发环境中的激活Odoo激活Odoo开发者模式工具）。这将启用Settings | Technical 菜单。 访问小数精度配置。为此，请打开设置顶部菜单并选择Technical | Database Structure | Decimal Accuracy 。我们应该看到当前定义的设置列表。 添加新配置，将Usage 设置为Book Price ，并填写Digits 精度： 要使用此小数精度设置需要添加模型字段，请通过添加以下代码来编辑models/library_book.py 文件： 12class LibraryBook(models.Model): cost_price = fields.Float('Book Cost', digits='Book Price') 提示每当您在模型中添加新字段时，您还需要将它们添加到视图中以便从用户界面访问它们。在前面的示例中，我们添加了cost_price 字段。 要在表单视图中看到这一点，您需要使用&lt;field name=&quot;cost_price&quot;/&gt;添加它。 运行原理当您将字符串值添加到字段的digits 属性时，Odoo在小数精度模型的Usage 字段中查找该字符串并返回具有16 位精度和配置中定义的小数位数的元组。使用字段定义，而不是硬编码，允许最终用户根据他们的需要进行配置。 提示如果您使用的是v13 之前的版本，则需要一些额外的工作才能在浮点字段中使用digits 属性。在旧版本中，小数精度在一个名为decimal_precision 的单独模块中。要在您的字段中启用自定义小数精度，您必须使用decimal_precision 模块的get_precision()方法，如下所示：cost_price = fields.Float(‘Book Cost’, digits=dp.get_precision(‘Book Price’)) 。 向模型添加货币字段Odoo对与货币相关的货币字段有特殊的支持。 让我们看看如何在模型中使用它。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤货币字段需要一个额外的币别字段来存储相应的货币金额。 my_library 已经有models/library_book.py ，它定义了一个基本模型。我们将对其进行编辑以添加必填字段： 添加币别字段用于存储币别： 123class LibraryBook(models.Model): # ... currency_id = fields.Many2one('res.currency', string='Currency') 添加货币字段用于存储金额： 12345class LibraryBook(models.Model): # ... retail_price = fields.Monetary('Retail Price', # optional: currency_field='currency_id', ) 现在，升级附加模块，新字段应该在模型中可用。在将它们添加到视图之前，它们不会在视图中可见，但我们可以通过开发者模式进入到Settings | Technical | Database Structure | Models 中查看。 将它们添加到表单视图后，它将如下所示： 运行原理货币字段类似于浮点型字段，Odoo能够在用户界面中正确地表示它们，因为它通过第二个字段知道它们的货别是什么。 这个货币字段应该被称为currency_id ，但我们可以使用我们喜欢的任何字段名称，只要它使用可选的currency_field 参数来指示即可。 提示如果您将币别信息存储在名称为currency_id 的字段中，则可以省略货币字段中的currency_field 属性。当您需要在同一记录中维护不同货币的金额时，这非常有用。例如，如果我们要包含销售订单的货币和公司的货币，您可以将这两个字段配置为fields.Many2one(res.currency)并将第一个用于第一个金额，另一个用于 第二笔金额。您还应知道金额的小数精度取自货币定义（res.currency 模型的decimal_precision 字段）。 向模型添加关联字段Odoo模型之间的关系由关系字段表示。存在三种不同类型的关系： many-to-one ：多对一，通常缩写为m2o。 one-to-many ：一对多，通常缩写为o2m。 many-to-many ：多对多，通常缩写为m2m。 查看Library Books 示例，我们可以看到每本书只能有一个出版商，因此我们可以在书籍和出版商之间建立多对一的关系。 但是，每个出版商可以拥有许多书籍。 因此，前面的多对一关系意味着一对多的反向关系。 最后，在某些情况下，我们可以建立多对多关系。在我们的示例中，每本书可以有几个（许多）作者。此外，相反，每个作者可能写过很多书。从任何一方来看，这是一个多对多的关系。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤Odoo使用partner 模型res.partner 来表示人员、组织和地址。我们应该为作者和出版商使用它。我们将编辑models/library_book.py 文件以添加这些字段： 向Library Books模型添加图书出版商的多对一（many-to-one ）字段: 123456789class LibraryBook(models.Model): # ... publisher_id = fields.Many2one( 'res.partner', string='Publisher', # optional: ondelete='set null', context={}, domain=[], ) 要为出版商的书籍添加一对多（one-to-many ）字段，我们需要扩展partner 模型。为简单起见，我们将其添加到同一个 Python文件中： 123456class ResPartner(models.Model): _inherit = 'res.partner' published_book_ids = fields.One2many( 'library.book', 'publisher_id', string='Published Books' ) 我们在这里使用的_inherit 属性用于继承现有模型。这将在本章后面的使用继承向模型添加功能 中解释。 我们已经创建了书籍和作者之间的多对多（many-to-many ）关系，但让我们重新查看一下： 123class LibraryBook(models.Model): # ... author_ids = fields.Many2many('res.partner', string='Authors') 同样的关联，但作者对书籍的关联应该添加到partner 模型中： 1234567class ResPartner(models.Model): # ... authored_book_ids = fields.Many2many( 'library.book', string='Authored Books', # relation='library_book_res_partner_rel' # optional ) 现在，升级附加模块，新字段应该在模型中可用。在将它们添加到视图之前，它们不会出现在视图中，但我们可以通过开发者模式进入到Settings | Technical | Database Structure | Models 中查看。 运行原理多对一字段会在模型的数据库表中添加一列，存储相关记录的数据库ID。在数据库级别，还将创建外键约束，确保存储的ID是对相关表中记录的有效引用。这些关联字段不会创建数据库索引，但这可以通过添加index=True 属性来创建数据库索引。 我们可以看到还有四个属性可以用于多对一字段。ondelete 属性确定删除相关记录时会发生什么。例如，当图书的出版商记录被删除时，图书会发生什么情况？默认值为'set null' ，它在字段上设置一个空值。它也可以是'restrict' ，防止删除相关记录，或'cascade' ，这将导致链接的记录也被删除。 最后两个（context 和domain ）对其他关系字段也有效。这些字段在客户端是很有意义的，在模型层面，它们作为默认值在客户端视图中使用。 context ：在点击字段进入相关记录视图时，会将添加到客户端上下文变量中。例如，我们可以用它来为创建的新记录设置默认值。 domain ：是一个搜索过滤器，用于限制可用的关联记录的列表。 context和domain在第九章《后台视图》 中都有详细的解释。 一对多字段是多对一的反关联，尽管它们像其他字段一样被添加到模型中，但它们在数据库中没有实际的表示。相反，它们是程序化的快捷方式，它们使视图能够表示这些相关记录的列表。这意味着一对多字段在关联模型中需要一个多对一字段。在我们的例子中，我们通过继承一个partner 模型来添加一对多字段。我们将在本章的使用继承向模型添加功能 中详细了解模型的继承。在我们的例子中，一对多字段published_book_ids 引用了library.book 模型的publisher_id 字段。 多对多的关联也不为模型的表添加列。这种类型的关联在数据库中使用一个中间关联表来存储，其中两列存储两个关联对象的ID。在书籍和作者之间添加新关系会在关联表中创建一条新记录，其中包含书籍ID和作者ID。 Odoo自动处理这个关联表的创建。默认情况下，关联表名称是使用两个关联模型的名称构建的，按字母顺序排序，加上一个_rel 后缀。但是，我们可以使用字段属性覆盖它。 需要记住的一个情况是，当两个表名足够大，以至于自动生成的数据库标识符超过PostgreSQL 63个字符的限制时。根据规则，如果两个相关表的名称超过23个字符，则应使用字段属性设置较短的名称。在下一节中，我们将对此进行更详细的介绍。 扩展内容Many2one字段支持附加的auto_join 属性。这是一个允许ORM在该字段上使用SQL连接的标志。因此，它绕过了通常的ORM控制，例如用户访问控制和记录访问规则。在特定情况下，它可以解决性能问题，一般建议避免使用它。 我们已经介绍了如何通过最简单的方法来定义关联字段。让我们看一下特定于该类型字段的属性。 One2many 字段有以下属性： commodel_name ：这是目标模型标识符，对于所有关系字段都是必需的，但可以按位置定义，无需使用关键字。 inverse_name ：这仅适用于One2many 并且是反向Many2one 关联的目标模型中的字段名称。 limit ：这适用于One2many 和Many2many ，并可在用户界面级别限制用户读取的记录数量。 Many2many 字段有以下属性： comodel_name ：这与One2many 字段相同。 relation ：设置多对多关联表表名。 column1 ：这是链接到此模型的关联表中的Many2one 字段的名称。 column2 ：这是链接到comodel 的关联表中的Many2one 字段的名称。 对于Many2many 关联，在大多数情况下ORM会处理这些属性的默认值。它甚至能够检测反向Many2many关联，检测已经存在的关联表，并适当地反转column1和column2的值。 但是，有两种情况我们需要介入并为这些属性提供我们自己的值： 一种情况是我们在相同的两个模型之间需要不止一个Many2many 关系时，我们必须自己提供第二个关系的关联表名称，该名称必须与第一个关联表不同。 另一种情况是相关表的数据库名称足够长，以至于自动生成的关联表名超过了PostgreSQL 数据库对象名称的63 个字符的限制。 自动生成的关联表名称格式是&lt;model1&gt;_&lt;model2&gt;_rel 。但此关联表还为其创建了一个主键索引，其标识符如下： 1&lt;model1&gt;_&lt;model2&gt;_rel_&lt;model1&gt;_id_&lt;model2&gt;_id_key 此主键还需要满足63 个字符的限制。因此，如果两个表名的字符总和超过63 ，需要手动设置关联属性。 添加模型层次结构层次结构（Hierarchies ）表示在同一模型之间做关联。每个记录在同一模型中都有一个父记录，以及许多子记录。这可以通过简单地使用模型与其自身之间的多对一关联来实现。 然而，Odoo还可通过使用嵌套集模型 (https://en.wikipedia.org/wiki/Nested_set_model) 为此类字段提供了更好的支持。启用后，在其域过滤器中使用child_of 运算符进行查询会发现查询速度明显的变快。 继续以Library Books 为例，我们将构建一个分层类别树，可用于对图书进行分类。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤我们将新建一个Python文件，models/library_book_categ.py ，如下所示： 要加载新的Python代码文件，请将以下行添加到models/init.py 文件中： 1from . import library_book_categ 要创建具有父子关系的Book Category 模型，请使用以下代码创建models/library_book_categ.py 文件： 1234567891011121314from odoo import models, fields, apiclass BookCategory(models.Model): _name = 'library.book.category' name = fields.Char('Category') parent_id = fields.Many2one( 'library.book.category', string='Parent Category', ondelete='restrict', index=True ) child_ids = fields.One2many( 'library.book.category', 'parent_id', string='Child Categories' ) 要启用特殊的层次结构支持，还要添加以下代码： 123_parent_store = True_parent_name = &quot;parent_id&quot; # optional if field is 'parent_id'parent_path = fields.Char(index=True) 要添加防止循环关联的检查，请将以下行添加到模型中： 1234567from odoo.exceptions import ValidationError... @api.constraints('parent_id') def _check_hierarchy(self): if not self._check_recursion(): raise models.ValidationError( 'Error! You cannot create recursive categories.') 现在我们需要为一本书分配一个类别。为此，我们将向library.book 模型添加一个新的many2one 字段： 1category_id = fields.Many2one('library.book.category') 最后需要升级模块使这些更改生效。 要在用户界面中显示librart.book.category 模型，您需要添加菜单、视图和安全规则。 有关详细信息，请参阅第三章创建Odoo附加模块。 或者，您可以在https://github.com/PacktPublishing/Odoo-13-Development-Cookbook-FourthEdition查看所有代码。 运行原理步骤1和2创建具有层次结构的新模型。Many2one 关联添加一个字段来与父记录关联。为了更快地搜索子记录，使用index=True 参数在数据库中对该字段进行索引。parent_id 字段必须将ondelete 设置为'cascade' 或'restrict' 。 在这一点上，我们已经具备了实现层次结构所需的一切，但我们还可以做一些额外的事情来改善它。One2many 关系不会向数据库添加任何其他字段，但提供了一种快捷方式来访问以该记录的所有子记录。 在第3步中，我们启用了对层次结构的特殊支持。这对于高读低写指令非常有用，因为它带来了更快的数据浏览速度，但代价是性能更低的的写操作。这是通过添加一个辅助字段parent_path 并将模型属性设置为_parent_store=True 来实现的。启用此属性后，帮助字段将用于在分层树中的搜索中存储数据。默认情况下，假定记录的父字段名为parent_id ，但也可以使用不同的名称。在这种情况下，应使用附加模型属性_parent_name 指示正确的字段名称。 默认如下： 1_parent_name = 'parent_id' 步骤4是为了防止层次结构中出现循环依赖，这意味着在升序树和降序树中都有记录。这对于在树中导航的程序来说是危险的，因为它们可能会进入无限循环。models.Model 为我们提供了一个有效的方法（_check_recursion ）我们在这里进行了复用。 第5步是在libary.book 图书中添加类型为many2one 的category_id 字段，这样我们就可以在图书记录上设置一个类别。 这只是为了完成我们的示例。 扩展内容此处显示的技术应该用于静态 层次结构，这些层次结构经常被读取和查询，但更新频率较低。图书类别就是一个很好的例子，因为图书馆不会不断地创建新类别；但是，读者通常会将他们的搜索限制在一个类别及其子类别中。其原因在于数据库中嵌套集合模型的实现，每当插入、删除或移动类别时，都需要更新所有记录的parent_path 列（以及相关的数据库索引）。这可能是一项非常消耗资源的操作，尤其是在并行事务中执行多行编辑时。 如果您正在处理一个非常动态的层次结构，标准的parent_id 和child_ids 关联通常会通过避免表级锁定来提高性能。 向模型添加约束验证模型可以进行验证，以防止它们输入不希望的条件判断。 Odoo提供两种不同类型的约束： 数据库级别的约束检查。 服务端级别的约束检查。 数据库级别的约束仅限于PostgreSQL 支持的约束。最常用的是UNIQUE 约束，但也可以使用CHECK 和EXCLUDE 约束。 如果这些还不足以满足我们的需求，我们可以使用Python代码编写的Odoo服务端级约束。 我们将使用在第三章创建的Library Books 模型，创建Odoo附加模块，并为其添加一些约束。我们将添加一个防止重复书名的数据库约束，以及一个防止发布日期大于当前日期的Python模型约束。 准备工作我们将继续使用上一小节中的my_library 附加模块。 我们希望它至少包含以下内容： 12345from odoo import models, fieldsclass LibraryBook(models.Model): _name = 'library.book' name = fields.Char('Title', required=True) date_release = fields.Date('Release Date') 实现步骤我们将在models/library_book.py Python文件中编辑LibraryBook 类： 要创建数据库约束，请添加模型属性： 12345678class LibraryBook(models.Model): # ... _sql_constraints = [ ('name_uniq', 'UNIQUE (name)', 'Book title must be unique.'), ('positive_page', 'CHECK(pages&gt;0)', 'No of pages must be positive') ] 要创建Python代码约束，请添加模型方法： 123456789from odoo import api, models, fieldsfrom odoo.exceptions import ValidationErrorclass LibraryBook(models.Model): # ... @api.constrains('date_release') def _check_release_date(self): for record in self: if record.date_release and record.date_release &gt; fields.Date.today(): raise models.ValidationError('Release date must be in the past') 对代码文件进行这些更改后，需要升级附加模块并重新启动服务器。 运行原理第一步在模型的表上创建一个数据库约束。 它在数据库级别强制执行。_sql_constraints 模型属性接受要创建的约束列表。每个约束由一个三元素元组定义。这些列表如下： 用于约束标识符的后缀。在我们的示例中，我们使用了name_uniq ，生成的约束名称是library_book_name_uniq 。 PostgreSQL 用于更改或创建数据库表的SQL语句。 违反约束时向用户报告的消息。 在我们的示例中，我们使用了两个SQL约束。第一个是唯一的书名，第二个是检查该书的页数是否为正数。 警告如果通过模型继承向现有模型添加SQL约束，请确保没有违反约束的行。如果有这样的行，则不会添加SQL约束，并且会在日志中输出错误信息。 正如我们前面提到的，也可以使用其他数据库表约束。请注意，不能以例如NOT NULL 这种方式添加列约束。有关一般PostgreSQL 约束和特别是表约束的更多信息，请查看 http://www.postgresql.org/docs/current/static/ddlconstraints.html。 在第二步中，我们添加了一个方法来执行Python代码验证。这里使用了@api.constrains 修饰，这意味着当参数列表中的一个字段发生更改时，应该执行它以运行检查。如果检查失败，将会抛出ValidationError 异常。 扩展内容通常如果需要复杂的验证，可以使用@api.constrains ，但对于一些简单的情况，可以使用带有CHECK 选项的_sql_constraints 。 看看下面的例子： 123456_sql_constraints = [ ( 'check_credit_debit', 'CHECK(credit + debit&gt;=0 AND credit * debit=0)', 'Wrong credit or debit value in accounting entry!' )] 在前面的示例中，我们使用了CHECK 选项，并且我们正在使用AND 运算符检查同一约束中的多个条件。 向模型添加计算字段有时我们需要一个字段，该字段的值是从同一记录或相关记录中的其他字段计算或派生的。一个典型的例子是总金额，它是通过将单价乘以数量来计算的。在Odoo模型中，这可以使用计算字段来实现。 为了向您展示计算字段的工作原理，我们将在Library Books 模型中添加一个来计算自图书发行日期以来的天数。 还可以使计算字段可编辑和可搜索。 这也将在我们的示例中实现这一点。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤我们将编辑models/library_book.py 代码文件以添加一个新字段和支持其逻辑的方法： 首先将新字段添加到Library Books 模型： 12345678910class LibraryBook(models.Model): # ... age_days = fields.Float( string='Days Since Release', compute='_compute_age', inverse='_inverse_age', search='_search_age', store=False, # optional compute_sudo=True # optional ) 接下来，添加具有值计算逻辑的方法： 1234567891011121314# ...from odoo import api # if not already imported# ...class LibraryBook(models.Model): # ... @api.depends('date_release') def _compute_age(self): today = fields.Date.today() for book in self: if book.date_release: delta = today - book.date_release book.age_days = delta.days else: book.age_days = 0 要添加方法并实现写入计算字段的逻辑，请使用以下代码： 123456789from datetime import timedelta# ...class LibraryBook(models.Model): # ... def _inverse_age(self): today = fields.Date.today() for book in self.filtered('date_release'): d = today - timedelta(days=book.age_days) book.date_release = d 要实现允许您在计算字段可搜索的逻辑，请使用以下代码： 12345678910111213141516from datetime import timedeltaclass LibraryBook(models.Model): # ... def _search_age(self, operator, value): today = fields.Date.today() value_days = timedelta(days=value) value_date = today - value_days # convert the operator: # book with age &gt; value have a date &lt; value_date operator_map = { '&gt;': '&lt;', '&gt;=': '&lt;=', '&lt;': '&gt;', '&lt;=': '&gt;=', } new_op = operator_map.get(operator, operator) return [('date_release', new_op, value_date)] 需要重新启动Odoo，然后升级模块，才能正确激活这些新增功能。 运行原理计算字段的定义与常规字段的定义相同，只是添加了一个compute 属性来指定用于其计算的方法的名称。 它们的相似性可能具有欺骗性，因为计算域在内部与常规域完全不同。计算字段是在运行时动态计算的，因此它们不会存储在数据库中，因此默认情况下您无法搜索或写入计算字段。您需要做一些额外的工作才能启用对计算字段的写入和搜索支持。让我们看看怎么做。 计算函数是在运行时动态计算的，但是ORM使用缓存来避免每次访问其值时重新计算它而造成性能低下。 所以它需要知道它依赖于哪些字段。使用@depends 装饰器来检测其缓存值何时应失效并重新计算。 确保compute 函数始终在计算字段上设置一个值。否则将引发错误。当您的代码中有if 条件且无法在计算字段上设置值时，可能会发生这种情况。这可能很难进行调试。 可以通过实现反函数（inverse ）来添加写支持。使用分配给计算字段的值来更新源字段。当然这只对简单的计算有用。尽管如此，仍然存在一些有用的情况。在我们的示例中，我们可以通过编辑自发行以来的天数计算字段来设置图书发行日期。inverse 属性是可选的；如果您不想使计算字段可编辑，则可以跳过它。 也可以通过设置search 属性为方法名称来使非存储计算字段也可搜索（类似于compute 和inverse ）。 和inverse 属性一样，search 属性也是可选的；如果您不想让计算字段可搜索，您可以跳过它。 但是这种方法预计不会实现在实际的搜索中。相反，它接收用于在字段上搜索的运算符和值作为参数，并期望返回一个具有替换搜索条件的域以供使用。在我们的示例中，我们将对发布以来的天数 字段的搜索转换为发布日期 字段上的等效搜索条件。 可选的store=True 标志将字段存储在数据库中。在这种情况下，在计算之后字段值将存储在数据库中，然后以与常规字段相同的方式检索它们，而不是在运行时重新计算。 由于@api.depends 装饰器，ORM将知道何时需要重新计算和更新这些存储的值。您可以将其视为持久缓存。它还具有使该字段可用于搜索条件的优点，包括按操作排序和分组。如果在计算字段中使用store=True ，则不再需要实现search 方法，因为该字段存储在数据库中，您可以根据存储的字段进行搜索或排序。 在需要以提升的权限完成计算的情况下，使用compute_sudo=True 标志来实现。在当计算需要使用最终用户可能无法访问的字段数据时，可使用这种方法实现。 重要提示在Odoo v13中更改了compute_sudo 的默认值。在Odoo v13之前，compute_sudo 的值为False 。 但在v13中，compute_sudo 的默认值将基于store 属性。 如果store 属性的值为True ，则compute_sudo 为True 否则为False 。但是您始终可以通过在字段定义中显式放置compute_sudo 来手动更改它。 扩展内容Odoo v13为ORM引入了一种新的缓存机制。早期版本中，缓存是基于环境的，但现在在Odoo v13中，我们有一个全局缓存。因此，如果您有一个依赖于上下文值的计算字段，那么您有时可能会得到不正确的值。要解决此问题，您需要使用@api.depends_context 装饰器。 请参考以下示例： 123456@api.depends('price')@api.depends_context('company_id')def _compute_value(self): company_id = self.env.context.get('company_id') ... # other computation 您可以在上面的示例中看到，我们的计算使用上下文中的company_id 。通过在depends_context 装饰器中使用company_id ，我们可以确保字段值将根据上下文中company_id 的值重新计算。 暴露存储在其他模型中的相关字段从服务器读取数据时，Odoo客户端只能获取模型中可用和正在查询的字段的值。与服务器端代码不同，客户端代码不能使用点表示法访问相关表中的数据。 但是这些字段可通过将它们添加为关联字段来进行访问。我们将这样做以使出版商所在的城市在Library Books 模型中可用。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤编辑models/library_book.py 文件以添加新的相关字段： 确保我们有图书出版商的字段： 123class LibraryBook(models.Model):# ... publisher_id = fields.Many2one('res.partner', string='Publisher') 现在，添加发布者所在城市的相关字段： 1234567# class LibraryBook(models.Model):# ... publisher_city = fields.Char( 'Publisher City', related='publisher_id.city', readonly=True ) 最后，我们需要升级附加模块以使新字段在模型中可用。 运行原理关联字段就像常规字段一样，但它们有一个附加属性related ，带有一个分隔字段链遍历的字符串。 在我们的例子中，我们通过publisher_id 访问与发布者相关的记录，然后读取它的city 字段。我们还可以有更长的链，例如publisher_id.country_id.country_code 。 请注意在本例中，我们将相关字段设置为只读 。如果我们不这样做，该字段将是可写的，并且用户可能会更改其值。这将具有更改相关发布者的城市字段值的效果。虽然这可能是一个有用的副作用，但需要谨慎。由同一出版商出版的所有书籍都将更新其publisher_city 字段，这可能不是用户期望的。 扩展内容关联字段实际上是计算字段。它们只是提供了一种方便的快捷语法来从相关模型中读取字段值。作为一个计算域，这意味着store 属性也是可用的。作为一种快捷方式，它们还具有引用字段的所有属性，例如name 、translatable 。 此外，它们支持类似于compute_sudo 的related_sudo 标志；当设置为True 时，遍历时不检查用户的访问权限。 在create() 方法中使用关联字段可能会影响性能，因为这些字段的计算会延迟到它们的创建结束。因此，如果您有一个One2many 关联，例如在sale.order 和sale.order.line 模型中，并且您在line模型上有一个关联字段引用了order模型上的字段，应当在记录创建时在order模型中显式读取该字段，而不是使用关联字段快捷方式，尤其是在有很多行的情况下。 使用引用字段添加动态关联对于关联字段，我们需要事先确定关联的目标模型（或comodel）。但是，有时我们可能需要将决定权留给用户，首先选择我们想要的模型，然后选择我们想要链接到的记录。 在Odoo中可以使用引用字段来实现。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤编辑models/library_book.py 文件以添加新的相关字段： 首先，我们需要添加一个辅助方法来动态构建可选择目标模型的列表： 12345678from odoo import models, fields, apiclass LibraryBook(models.Model): # ... @api.model def _referencable_models(self): models = self.env['ir.model'].search([ ('field_id.name', '=', 'message_ids')]) return [(x.model, x.name) for x in models] 然后，我们需要添加引用字段并使用前面的函数提供可选模型列表： 123ref_doc_id = fields.Reference( selection='_referencable_models', string='Reference Document') 由于我们正在更改模型的结构，因此需要升级模块来激活这些更改。 运行原理引用字段类似于多对一字段，不同之处在于它们允许用户选择要链接到的模型。 可以从selection 属性提供的列表中选择目标模型。selection 属性必须是两个元素元组的列表，其中第一个是模型的内部标识符，第二个是它的文本描述。例如： 1[('res.users', 'User'), ('res.partner', 'Partner')] 但是，我们可以使用最常见的模型，而不是提供固定列表。为简单起见，我们使用所有具有消息传递功能的模型。使用_referencable_models 方法动态组装模型列表。 上例中，我们首先提供了一个函数来浏览所有可以引用的模型记录，以动态构建selection 属性。虽然这两种形式都允许，但是我们在引号内声明了函数名，而不是直接引用不带引号的函数。这样更灵活，它允许引用的函数只在代码的后面定义，而使用直接引用时这是不可以的。 该函数需要@api.model 装饰器，因为它在模型级别上运行，而不是在记录集级别上运行。 虽然此功能看起来不错，但它带来了明显的性能开销。显示大量记录的引用字段（例如，在列表视图中）可能会产生繁重的数据库负载，因为必须在单独的查询中查找每个值。与常规关系字段不同，它也无法利用数据库引用完整性。 使用继承向模型添加功能Odoo最重要的特性之一是模块插件能够在其他模块插件的基础上扩展功能，而无需编辑原始功能的代码。这可能是添加字段或方法、修改现有字段或扩展现有方法以执行附加逻辑。 根据官方文档，Odoo提供了三种继承方式： 类继承（扩展） 原型继承 代理继承 我们将在单独的小节中介绍每一种继承方式。在本小节中我们将介绍类继承（扩展）。它用于向现有模型添加新字段或方法。 我们将扩展Odoo内置的合作伙伴模型res.partner 为其添加创作书籍数量 的计算字段。这涉及向现有模型添加字段和方法。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤我们将扩展Odoo内置的合作伙伴模型。如果你还记得的话，我们已经在本章的向模型添加关联字段 中继承了res.parnter 模型。为了使解释尽可能简单，我们将在models/library_book.py 代码文件中重用res.partner 模型： 首先我们要确保在partner模型中存在authored_book_ids 反向关联，并添加计算域： 1234567class ResPartner(models.Model): _inherit = 'res.partner' _order = 'name' authored_book_ids = fields.Many2many( 'library.book', string='Authored Books') count_books = fields.Integer( 'Number of Authored Books', compute='_compute_count_books' ) 接下来添加计算图书数量所需的方法： 12345678# ...from odoo import api # if not already imported# class ResPartner(models.Model): # ... @api.depends('authored_book_ids') def _compute_count_books(self): for r in self: r.count_books = len(r.authored_book_ids) 最后我们需要升级附加模块才能使修改生效。 运行原理当使用_inherit 属性定义模型类时，它会向继承的模型添加修改，而不是替换它。 这意味着继承类中定义的字段在父模型上添加或更改。在数据库层，ORM将字段添加到同一个数据库表中。 字段也被增量修改。这意味着如果该字段已经存在于父类中，则只修改继承类中声明的属性；其他属性保持在父类中。 继承类中定义的方法替换父类中的方法。如果你不使用super 调用调用父方法，在这种情况下，父类中的方法将不会被执行，我们将失去父类中的功能。因此，每当您通过继承现有方法添加新逻辑时，您应该包含一个带有super 的语句以调用父类中的功能。这在第五章《基本服务器端开发》 中有更详细的讨论。 本小节将向现有模型添加新字段。如果您还想将这些新字段添加到现有视图（用户界面），请参阅第九章《后端视图中的更改现有视图-视图继承》 。 使用继承复制模型定义我们已经在前一节中看到了类继承（扩展）。现在我们将看到原型继承，它用于复制现有模型的整个定义。在本节中，我们将复制library.book 模型。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤原型继承是通过同时使用_name 和_inherit 类属性来执行的。执行以下步骤以生成library.book 模型的副本： 将名为library_book_copy.py 的新文件添加到/my_library/models/ 目录。 将以下内容添加到library_book_copy.py 文件中： 12345from odoo import models, fields, apiclass LibraryBookCopy(models.Model): _name = &quot;library.book.copy&quot; _inherit = &quot;library.book&quot; _description = &quot;Library Book's Copy&quot; 将新文件引用导入/my_library/models/__init__.py 文件。更改后您的__init__.py 文件将如下所示： 123from . import library_bookfrom . import library_book_categfrom . import library_book_copy 最后，我们需要升级附加模块才能使修改生效。进入Settings | Technical |Database Structure | Models 菜单检查新模型的定义，您将在此处看到library.book.copy 模型的新条目。 提示为了查看新模型的菜单和视图，您需要添加视图和菜单的XML定义。要了解有关视图和菜单的更多信息，请参阅请参阅第三章创建Odoo附加模块 中的添加菜单项和视图。 运行原理通过同时使用_name 和_inherit 类属性，您可以复制模型的定义。当您在模型中使用这两个属性时，Odoo将复制_inherit 的模型定义并使用_name 属性创建一个新模型。 在我们的示例中，Odoo将复制library.book 模型的定义并创建一个新模型library.book.copy 。新的library.book.copy 模型有自己的数据库表，其数据完全独立于library.book 父模型。由于它仍然继承自partner模型，因此对它的任何后续修改也会影响新模型。 原型继承复制父类的所有属性。它复制字段、属性和方法。如果要在子类中修改它们，只需向子类添加新定义即可。例如，library.book 模型具有_name_get 方法。如果要在子类中使用不同的_name_get 逻辑，需要重新定义library.book.copy 模型中的_name_get 方法。 警告如果您在_inherit 和_name 属性中使用相同的模型名称，则原型继承不起作用。如果您确实在_inherit 和_name 属性中使用了相同的模型名称，那么它的行为就像普通的扩展继承一样。 扩展内容在官方文档中，这称为原型继承，但在实践中很少使用。这样做的原因是代理继承通常以更有效的方式满足这一需求，而无需复制数据结构。有关这方面的更多信息，您可以参考下一小节使用代理继承将功能复制至另一个模型 。 使用代理继承将功能复制至另一个模型第三种继承是委托继承。它使用_inherits 类属性而不是_inherit 。在某些情况下，我们不想修改现有模型，而是希望基于现有模型创建一个新模型以使用它已有的功能。我们可以使用原型继承来复制模型的定义，但这会产生重复的数据结构。如果您想复制模型的定义而不复制数据结构，那么可以使用委托继承，它使用_inherits 模型属性（注意附加的s ）。 传统的继承与面向对象编程中的概念有很大不同。反过来，委托继承也是类似的，因为可以创建一个新模型来包含父模型的特征。它还支持多态继承，我们从两个或多个其他模型继承。 我们图书馆中已经有书了。是时候给图书馆添加会员了。对于图书馆会员，我们需要在partner模型中找到的所有身份和地址数据，并且我们还希望它还能记录一些与会员资格相关的信息：开始日期、终止日期和卡号。 将这些字段添加到partner模型不是最佳解决方案，因为这些字段对于非会员是不需要的。我们需要将partner模型扩展到具有这些附加字段的新模型。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤新的图书馆会员模型应该在它自己的Python代码文件中，但为了使解释尽可能简单，我们将重用models/library_book.py 文件： 添加新的模型，继承自res.partner 模型: 1234567class LibraryMember(models.Model): _name = 'library.member' _inherits = {'res.partner': 'parent_id'} partner_id = fields.Many2one( 'res.partner', ondelete='cascade' ) 接着我们添加会员的其他特殊字段： 123456# class LibraryMenber(models.Model): # ... date_start = fields.Date('Member Since') date_end = fields.Date('Termination Date') member_number = fields.Char() date_of_birth = fields.Date('Date of birth') 现在我们需要升级附加模块才能使修改生效。 运行原理_inherits 模型属性填的是我们需要继承的父模型。在这种情况下，我们的示例中只有一个res.partner 。它的值是一个键值字典，其中键是继承的模型，值是用于链接到它们的字段名称。我们还必须在模型中定义的Many2one 字段。在我们的示例中，partner_id 是用于与Partner 父模型链接的字段。 为了更好的理解它的运行原理，让我们从数据库层面看看，当新建一个图书馆会员时它做了什么动作： 在res_partner 表新增了一条记录。 在library_member 表新增了一条记录。 library_member 表中的partner_id 字段存储的是res_partner 表记录的ID。 会员记录会自动链接到新的partner记录。这只是一个多对一的关系，但代理机制增加了一些魔力，使partner的字段可以在会员记录中使用，并且新的partner记录也会自动与新会员记录一起创建。 您可能想知道这个自动创建的partner记录并没有什么特别之处。它是一个普通的partner，如果您浏览partner模型，您将能够找到该记录（当然没有额外的会员特殊字段数据）。所有会员都是partner，但只有部分partner也是会员。 那么如果您删除了partner记录那会员记录会发生什么？您可以通过选择关系字段的ondelete 值来决定。对于partner_id ，我们使用了cascade 。这意味着当partner删除时相关的会员记录也会删除。我们本可以使用更保守的restrict 来禁止删除具有链接到会员的partner记录。在这种情况下，只有删除该会员才有效。 请务必注意，代理继承仅适用于字段继承，不适用于方法继承。因此如果partner模型有一个do_something() 方法，会员模型将不会自动继承它。 扩展内容代理继承有一个捷径，您可以在Many2one 字段定义中使用delegate=True 属性，而不是创建_inherits 字典。 这样做与使用_inherits 选项效果完全相同。主要优点是这样写更简单。在给定的示例中，我们执行了与前一个相同的继承委托，但在这种情况下，我们没有创建_inherits 字典，而是在partner_id 字段中使用了delegate=True 选项： 1234567class LibraryMember(models.Model): _name = 'library.member' partner_id = fields.Meny2one('res.partner', ondelete='cascade', delegate=True) date_start = fields.Date('Member Since') date_end = fields.Date('Termination Date') member_mumber = fields.Char() date_of_birth = fields.Date('Date of birth') 一个值得注意的代理继承案例是用户模型res.users 。它继承自partner模型 (res.partner )。 这意味着您可以在用户上看到的某些字段实际上存储在partner模型中（特别是名称字段）。创建新用户时，我们还会获得一个自动创建的新partner。 我们还应该提到，使用_inherit 的传统继承也可以将功能复制到新模型中，尽管效率较低。这在使用继承向模型添加功能中进行了讨论。 使用抽象模型实现可复用的模型功能有时我们希望能够将某个特定功能添加到几个不同的模型中。在不同的文件中重复相同的代码是一种不好的编程习惯；最好实现一次并重用它。 抽象模型允许我们创建一个通用模型，该模型实现了一些可以被常规模型继承的特性，以使该特性可用。 例如我们需要实现一个简单的存档功能。它将活动字段添加到模型中（如果它不存在）并提供存档方法来切换活动标志。这是有效的，因为active 是一个魔法字段。如果默认在模型中出现，active=False 的记录会在查询中被过滤掉。 然后我们将它添加到Library Books 模型中。 准备工作我们将继续使用上一小节中的my_library 附加模块。 实现步骤本节中我们需要添加存档功能到Library Books模型中。为了使解释尽可能简单，我们将把它塞进models/library_book.py 文件中： 为存档功能添加抽象模型。 它必须在Library Book 模型中定义，将在其中使用它： 123456class BaseArchive(models.AbstractModel): _name = 'base.archive' active = fields.Boolean(default=True) def do_archive(self): for record in self: record.active = not record.active 接着我们将编辑Library Book 模型以继承上一步的抽象模型： 1234class LibraryBook(models.Model): _name = 'library.book' _inherit = ['base.archive'] # ... 需要升级附加模块才能激活更改。 运行原理抽象模型基于models.AbstractModel 类，而不是通常的models.Model 。它具有常规模型的所有属性和功能；不同之处在于ORM不会在数据库中为其创建实际的表。这意味着它不能存储任何数据。它仅用作要添加到常规模型中的可重用功能的模板。 我们的存档抽象模型非常简单。它只是添加了活动字段和一个方法来切换活动标志的值，我们希望稍后通过用户界面上的按钮使用它。 当使用_inherit 属性定义模型类时，它会继承那些类的属性方法，并且在当前类中定义的属性方法会对这些继承的特性进行修改。 这里起作用的机制与常规模型扩展的机制相同（根据使用继承向模型添加功能）。 您可能已经注意到_inherit 使用模型标识符列表而不是具有一个模型标识符的字符串。事实上，_inherit 可以有两种形式。使用列表形式允许我们从多个（通常是抽象的）类继承。在这种情况下，我们只继承一个，所以一个文本字符串就可以了。为了说明的目的，使用了一个列表。 扩展内容一个值得注意的内置抽象模型是mail.thread ，它由mail (Discuss) 附加模块提供。在模型上，它启用了为在许多表单底部看到的消息墙提供动力的讨论功能。 除了AbstractModel 之外，还有第三种模型类型可用：models.TransientModel 。这有一个类似models.Model 的数据库表示，但是在那里创建的记录应该是临时的，并且由服务器计划的作业定期清除。除此之外，瞬态模型就像常规模型一样工作。 models.TransientModel 对于更复杂的用户交互（称为向导）很有用。该向导用于请求用户输入。在第八 章《高级服务器端开发技术》中，我们再探讨如何使用这些技术进行高级用户交互。","link":"/Odoo14%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/"},{"title":"Odoo14配置文件模板","text":"Odoo14 配置文件模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[options]addons_path = /your/odoo/path/odoo/addons,/your/odoo/path/addons,/your/custom/addons/pathadmin_passwd = $pbkdf2-sha512$25000$eO8dw3iPEYKwtlZqDQGAkA$PpiUtsix0GRNvwOmd4RYAuIA7Q.hWJSYuYervSE0RJtJTjcLx08KJ871RhE4/JZ6q3ExMe1if.jv8V3beM9oowcsv_internal_sep = ,data_dir = /your/data/pathdb_host = your_db_hostdb_maxconn = 64db_name = Falsedb_password = your_db_passworddb_port = 5432db_sslmode = preferdb_template = template0db_user = your_db_userdbfilter =demo = {}email_from = Falsegeoip_database = /your/GeoIP/pathhttp_enable = Truehttp_interface = 127.0.0.1http_port = 8069import_partial =limit_memory_hard = 2684354560limit_memory_soft = 2147483648limit_request = 8192limit_time_cpu = 60limit_time_real = 120limit_time_real_cron = -1list_db = Truelog_db = Falselog_db_level = warninglog_handler = :INFOlog_level = infologfile = /your/odoo/log/path/server.loglongpolling_port = 8072max_cron_threads = 2osv_memory_age_limit = Falseosv_memory_count_limit = Falsepg_path =pidfile =proxy_mode = Truereportgz = Falsescreencasts =screenshots = /tmp/odoo_testsserver_wide_modules = base,websmtp_password = Falsesmtp_port = 25smtp_server = localhostsmtp_ssl = Falsesmtp_user = Falsesyslog = Falsetest_enable = Falsetest_file =test_tags = Nonetransient_age_limit = 1.0translate_modules = ['all']unaccent = Falseupgrade_path =without_demo = Falseworkers = 4","link":"/Odoo14%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/"},{"title":"PostgreSQL数据库备份还原","text":"备份 PostgreSQL数据库备份推荐使用自带的pg_dump，类似Mysql的mysqldump，以下命令为备份数据库并压缩： 1pg_dump --username=postgres --host=localhost --dbname=DATABASE | xz -9 &gt; DATABASE.sql.xz 也可以使用pg_dumpall命令把所有数据库都dump出来： 1pg_dumpall --username=postgres --host=localhost | xz -9 &gt; DATABASE.sql.xz 还原 还原使用psql命令还原： 1unxz -c DATABASE.sql.xz | psql -U 用户名 -h localhost DATABASE 备份脚本 创建备份脚本dbbackup.sh，使用crontab来每日调用一次，实现自动备份数据库： 12345678910111213#!/bin/sh#备份文件存放路径backup_file_path=&quot;/your/dbbackup/path/&quot;cur_date=$(date +&quot;%Y%m%d_%H%M&quot;)echo &quot;[$(date +'%Y-%m-%d %H:%M:%S')]Start Backup.&quot;pg_dumpall --username=postgres --host=localhost | xz -9 &gt; ${backup_file_path}${cur_date}-DATABASE.sql.xzecho &quot;[$(date +'%Y-%m-%d %H:%M:%S')]Backup Done.&quot;#查找30天前的历史备份数据并删除，历史数据保留30天find &quot;${backup_file_path}&quot; -maxdepth 1 -name &quot;*.sql.xz&quot; -daystart -mtime +30 -delete 给dbbackup.sh添加可执行权限: 1chmod +x dbbackup.sh 最后在crontab中设置自动执行备份脚本： 10 0 * * * /your/dbbackup/path/dbbackup.sh","link":"/PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"},{"title":"Print Spooler 服务意外终止","text":"Print Spooler服务在后台执行打印作业并处理与打印机的交互。如果关闭该服务，则无法进行打印或查看打印机。 问题今天遇到这个问题了，打印不了文件，重启电脑后发现Print Spooler并没有启动。手动进到服务里启动服务，没过几秒钟就停止了，查看windows日志发现Print Spooler 服务意外终止。 解决方法解决这个问题可以参考以下步骤： 停止 Print Spooler 服务； 删掉 C:\\windows\\system32\\spool\\PRINTERS 目录下的所有文件； 重新启动 Print Spooler 服务；","link":"/Print-Spooler-%E6%9C%8D%E5%8A%A1%E6%84%8F%E5%A4%96%E7%BB%88%E6%AD%A2/"},{"title":"SQLServer2017对象名STRING_SPLIT无效","text":"问题SQL Server 2017在使用“STRING_SPLIT”方法时报错： 1select * from STRING_SPLIT('1,2,3,4,5',',') 12消息 208，级别 16，状态 1，第 3 行对象名 'STRING_SPLIT' 无效。 原因STRING_SPLIT方法要求数据库的兼容级别至少为130。当级别小于130时，SQL Server无法找到STRING_SPLIT函数。 STRING_SPLIT方法介绍可参考：https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql?view=sql-server-ver15 使用以下SQL语句查看数据库的兼容级别： 1SELECT compatibility_level FROM sys.databases WHERE name = 'DBName' 解决方法使用以下SQL语句修改数据库兼容级别： 1ALTER DATABASE [DatabaseName] SET COMPATIBILITY_LEVEL=140 140代表SQLServer2017","link":"/SQLServer2017%E5%AF%B9%E8%B1%A1%E5%90%8DSTRING_SPLIT%E6%97%A0%E6%95%88/"},{"title":"STM32延时函数的实现方法","text":"我们在开发STM32工程时常常都需要使用到延时函数，比如控制LED的闪烁、IIC和SPI总线等都会用到延时函数，笔者刚开始接触STM32时查阅了不少的资料，本文将分享三种方法来实现延时函数。## 软件延时软件延时非常的简单粗暴，让单片机循环达到延时的目的： 1234void Delay(__IO u32 nCount){ for(; nCount != 0; nCount--);} 软件延时的优点是简单易懂，实现容易。缺点是不能精准地控制延时时间，在对延时时间要求较高的工程中，软件延时明显不能满足需求。 硬件延时 定时器延时（非中断方式） STM32内核中包含一个24位计数器SysTick，计数到0后又重新加载计数初始值到寄存器。下面介绍如何配置延时函数。STM32外部8MHz时钟倍频到72MHz，然后SysTick计数器再8分频，所以SysTick计数器的工作频率是9MHz(一秒钟计数9M次)。SysTick在STM32的固件库core_cm3.h中是这样定义的： 1234567typedef struct{ __IO uint32_t CTRL; /*!&lt; Offset: 0x00 SysTick Control and Status Register */ __IO uint32_t LOAD; /*!&lt; Offset: 0x04 SysTick Reload Value Register */ __IO uint32_t VAL; /*!&lt; Offset: 0x08 SysTick Current Value Register */ __I uint32_t CALIB; /*!&lt; Offset: 0x0C SysTick Calibration Register */} SysTick_Type; CTRL是SysTick控制和状态寄存器，LOAD是SysTick重载值寄存器，VAL是当前值寄存器，CALIB是SysTick校准寄存器（不常用）。实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;delay.h&quot;static uint8_t fac_us=0;//us延时倍数static uint16_t fac_ms=0;//ms延时倍数/** * @brief 计数器初始化函数 * @param None * @retval None */void delay_init(void){ SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);//选择外部时钟HCLK/8 fac_us=SystemCoreClock/8000000; //72000000/8000000 = 9 fac_ms=(uint16_t)fac_us*1000; //9000}/** * @brief us延时函数 * @param nus 延时us数 * @retval None */void delay_us(uint32_t nus){ uint32_t temp; SysTick-&gt;LOAD = nus*fac_us; //加载时间 SysTick-&gt;VAL = 0x00; //清空计数器 SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; //开始计数 do { temp = SysTick-&gt;CTRL; }while(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; //停止计数 SysTick-&gt;VAL = 0x00; //清空计数器}/** * @brief ms延时函数 * @param mus 延时ms数 * @retval None */void delay_ms(uint16_t nms){ uint32_t temp; SysTick-&gt;LOAD = nms*fac_ms; //加载时间 SysTick-&gt;VAL = 0x00; //清空计数器 SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; //开始计数 do { temp = SysTick-&gt;CTRL; }while(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; //停止计数 SysTick-&gt;VAL = 0x00; //清空计数器} 中断延时（中断方式） 使用SysTick计数器的中断方式实现延时，SysTick_Config()配置SysTick计数器，SystemCoreClock/1000实现1ms产生一次中断，在中断函数SysTick_Handler中对time_delay变量减一处理，当time_delay为0时，到达延时时间。实现代码如下： 12345678910111213141516171819202122232425262728293031uint32_t time_delay;/** * @brief ms延时函数 * @param mus 延时ms数 * @retval None */void delay_ms(__IO uint32_t nms){ if(SysTick_Config(SystemCoreClock/1000)) //配置SysTick计数器 { while(1); } time_delay = nms; while(time_delay); //time_delay为0时，到达延时时间。 SysTick-&gt;CTRL = 0x00; SysTick-&gt;VAL = 0x00;}/** * @brief SysTick中断函数 * @param None * @retval None */void SysTick_Handler(void){ if(time_delay) { time_delay--; }} 总结 使用软件延时实现方便但不能精确延时。使用中断的方法实现的延时函数可以做到精确延时，但使用中断在中断嵌套中不利与其他中断调用此中断函数。使用非中断的方式可以很好的解决以上两种延时方法的缺点，所以比较推荐使用非中断的硬件延时方法实现延时函数。","link":"/STM32%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"title":"Ubuntu 编译树莓派4B OpenWRT固件","text":"迫于树莓派吃灰最近在网上了解了一下R2S，又看了看某宝的价格，嗯打扰了打扰了。回想起自己买了两年的树莓派4b，除了吃灰还是吃灰，干脆拿出来改造成一个旁路由。 Raspberry Pi Foundation Raspberry Pi 4 B 准备内容 树莓派4b一台 Ubuntu系统 参考：编译环境，参数配置 编译环境搭建 安装编译需要的包 123456sudo apt updatesudo apt install build-essential ccache ecj fastjar file g++ gawk \\gettext git java-propose-classpath libelf-dev libncurses5-dev \\libncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \\python3-distutils python3-setuptools rsync subversion swig time \\xsltproc zlib1g-dev 编译源码 获取OpenWRT源码 12git clone https://git.openwrt.org/openwrt/openwrt.gitcd openwrt 如需编译特定版本，需要切换到对应版本分支。这里直接跳到步骤3，从主分支构建。 12git branchgit checkout &lt;branch name&gt; 更新和安装feeds 12./scripts/feeds update -a./scripts/feeds install -a 配置编译内容 1make menuconfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 编译的目标系统Target System -&gt; Broadcom BCM27xxSubtarget -&gt; BCM2711 boards (64 bit)Target Profile -&gt; Raspberry Pi 4B/400/4CM (64bit) # 镜像参数Target Images -&gt; ext4 # ext4格式的固件可方便地调整分区大小Target Images -&gt; squashfs # squashfs格式的固件可恢复出厂设置Target Images -&gt; Kernel partition size = 64 # boot分区大小为64MTarget Images -&gt; Root filesystem partition size = 512 # root分区大小为512M# 可选工具Base system -&gt; block-mount # 在LuCI界面添加&lt;挂载点&gt;菜单Base system -&gt; blockd # 自动挂载设备Base system -&gt; wireless-tools # 无线扩展工具Administration -&gt; htop # 添加htop命令Firmware -&gt; xxx # 选择你需要的网卡固件，默认即可# 文件系统Kernel modules -&gt; Filesystems -&gt; kmod-fs-ext4Kernel modules -&gt; Filesystems -&gt; kmod-fs-ntfsKernel modules -&gt; Filesystems -&gt; kmod-fs-squashfsKernel modules -&gt; Filesystems -&gt; kmod-fs-vfatKernel modules -&gt; Filesystems -&gt; kmod-fuse# 网卡支持Kernel modules -&gt; Network Devices -&gt; kmod-xxx # 有线网卡支持，跟以下几项可根据需求选择性添加Kernel modules -&gt; Wireless Drivers -&gt; kmod-rt2800-usb # 添加Ralink RT5370芯片的USB无线网卡驱动Kernel modules -&gt; USB Support -&gt; kmod-usb-net -&gt; kmod-usb-net-sr9700 # 添加USB2.0的有线网卡SR9700芯片支持Kernel modules -&gt; USB Support -&gt; kmod-usb-net -&gt; kmod-usb-net-rtl8152 # 添加USB2/3的有线网卡RTL8152/3芯片支持Kernel modules -&gt; USB Support -&gt; kmod-usb-net -&gt; kmod-usb-net-asix # 添加支持亚信的有线网卡支持Kernel modules -&gt; USB Support -&gt; kmod-usb-net -&gt; kmod-usb-net-asix-ax88179 # 添加USB3.0的有线网卡芯片AX88179的驱动# USB支持Kernel modules -&gt; USB Support -&gt; kmod-usb-core # 启用USB支持Kernel modules -&gt; USB Support -&gt; kmod-usb-hid # USB键鼠支持Kernel modules -&gt; USB Support -&gt; kmod-usb-ohci # 添加OHCI支持Kernel modules -&gt; USB Support -&gt; kmod-usb-uhci # 添加UHCI支持Kernel modules -&gt; USB Support -&gt; kmod-usb-storage # 启用USB存储Kernel modules -&gt; USB Support -&gt; kmod-usb-storage-extrasKernel modules -&gt; USB Support -&gt; kmod-usb2 # 开启USB2支持Kernel modules -&gt; USB Support -&gt; kmod-usb3 # 开启USB3支持# LuCI设置LuCI -&gt; Collections -&gt; luci # 开启luciLuCI -&gt; Modules -&gt; Translations -&gt; Chinese(zh-cn) # 中文支持LuCI -&gt; Themes -&gt; luci-theme-material # 添加主题# LuCI应用LuCI -&gt; Applications -&gt; luci-app-aria2 # 下载工具LuCI -&gt; Applications -&gt; luci-app-firewall # 防 火 墙LuCI -&gt; Applications -&gt; luci-app-hd-idle # 硬盘休眠LuCI -&gt; Applications -&gt; luci-app-opkg # 软 件 包LuCI -&gt; Applications -&gt; luci-app-qos # 服务质量LuCI -&gt; Applications -&gt; luci-app-samba4 # 网络共享LuCI -&gt; Applications -&gt; luci-app-frpc # 内网穿透LuCI -&gt; Applications -&gt; luci-app-shadowsocks-libev # 翻墙软件LuCI -&gt; Applications -&gt; luci-app-upnp # UPnP服务LuCI -&gt; Applications -&gt; luci-app-wol # 网络唤醒Network -&gt; Download Manager -&gt; ariang # Aria2管理页面Network -&gt; File Transfer -&gt; Aria2 Configuration -&gt; *** # 选择Aria2支持的功能Network -&gt; File Transfer -&gt; curl # 添加curl命令Network -&gt; File Transfer -&gt; wget # 添加wget命令Utilities -&gt; Compression -&gt; bsdtar # tar打包工具Utilities -&gt; Compression -&gt; gzip # GZ 压缩套件Utilities -&gt; Compression -&gt; xz-utils # XZ 压缩套件Utilities -&gt; Compression -&gt; unzip # zip解压工具Utilities -&gt; Compression -&gt; zip # zip压缩工具Utilities -&gt; Disc -&gt; fdisk # 磁盘分区工具Utilities -&gt; Disc -&gt; lsblk # 磁盘查看工具Utilities -&gt; Editors -&gt; vim # vim编辑器Utilities -&gt; Filesystem -&gt; ntfs-3g # NTFS读写支持Utilities -&gt; Filesystem -&gt; resize2fs # 分区大小调整Utilities -&gt; Terminal -&gt; screen # 添加screenUtilities -&gt; pciutils # 添加lspci命令Utilities -&gt; usbutils # 添加lsusb命令 下载所需源码 1make download -j8 V=s #请尽量使用梯子 编译源码，首次编译推荐用单线程； 1make -j1 V=s 再次编译前建议使用make clean清理； 123make clean # 清除bin目录make dirclean # 清除bin目录和交叉编译工具及工具链目录make distclean # 清除所有相关的东西，包括下载的软件包，配置文件，feed内容等 经过漫长的编译，编译完的固件放在./bin/targets/bcm27xx/bcm2711/目录下； 刷写固件 我们需要的文件是openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz，解压压缩文件； 12cd bin/targets/bcm27xx/bcm2711gzip -d openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz 安装BalenaEtcher工具刷写固件 官方代码编译出来的固件500多MB，建议选择4GB以上的TF卡刷写。成功后把TF卡插入树莓派，树莓派插电后红灯常亮表示正常。 配置OpenWRT使用网线连接树莓派与电脑配置OpenWRT，路由器的默认IP地址是192.168.1.1，管理员root，密码password。 已发现的问题 WIFI不能开启5G功能；","link":"/Ubuntu-%E7%BC%96%E8%AF%91%E6%A0%91%E8%8E%93%E6%B4%BE4B-OpenWRT%E5%9B%BA%E4%BB%B6/"},{"title":"Ubuntu安装Pillow失败：The headers or library files could not be found for jpeg...","text":"问题：Ubuntu安装Pillow失败报错12345The headers or library files could not be found for jpeg, a required dependency when compiling Pillow from source. Please see the install instructions at: https://pillow.readthedocs.io/en/latest/installation.html 解决方法：安装libjpeg-dev1sudo apt-get install libjpeg-dev","link":"/Ubuntu%E5%AE%89%E8%A3%85Pillow%E5%A4%B1%E8%B4%A5%EF%BC%9AThe-headers-or-library-files-could-not-be-found-for-jpeg/"},{"title":"Ubuntu安装psycopg2失败：error: command &#39;x86_64-linux-gnu-gcc&#39; failed with exit status 1","text":"问题：Ubuntu安装psycopg2失败报错123error: command 'x86_64-linux-gnu-gcc' failed with exit status 1----------------------------------------ERROR: Failed building wheel for psycopg2 解决方法：安装 python-dev, python3-dev, libpq-dev ： 1sudo apt-get install python-dev python3-dev libpq-dev","link":"/Ubuntu%E5%AE%89%E8%A3%85psycopg2%E5%A4%B1%E8%B4%A5%EF%BC%9Aerror-command-x86-64-linux-gnu-gcc-failed-with-exit-status-1/"},{"title":"VNCViewer No matching security types错误解决方法","text":"当用VNCViewer连接服务器时出现No matching security types错误。 解决方法禁用Vino的加密要求。使用屏幕共享的用户身份运行以下命令： 1gsettings set org.gnome.Vino require-encryption false","link":"/VNCViewer-No-matching-security-types%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"Windows 10 安装SQLServer 2005","text":"报错1The SQL Server service failed to start. For more information, see the SQL Server Books Online topics, “How to: View SQL Server 2005 Setup Log Files” and “Starting SQL Server Manually.” 解决方法 重新运行安装程序到图一报错的地方。 下载文件http://eddiejackson.net/apps/Fix_Error_SQL2005.zip 复制对应版本的文件到安装目录Program Files (x86) -&gt; Microsoft SQL Server &gt; MSSQL.2 &gt; MSSQL &gt; Binn替换原文件。 返回图一点击Retry。 安装完成。 参考：https://eddiejackson.net/wp/?p=16941","link":"/Windows-10-%E5%AE%89%E8%A3%85SQLServer-2005/"},{"title":"Zope DateTime类型的常用操作","text":"strftime(format) 返回按照format格式提供的日期时间字符串。 参见 Python中的 time.strftime 函数。 dow() 返回用整数表示的星期中的天数，星期日是0。 aCommon() 返回按照“Mar 1, 1997 1:45 pm”格式表示的日期时间字符串。 h_12() 返回12小时制的小时数。 Mon_() 兼容：见pMonth。 HTML4() 按照符合HTML 4.0规范的格式返回对象，这个规范是ISO8601标准之一。参见 HTML 4.0 规范，日期输出格式为：YYYY-MM-DDTHH:MM:SSZ T，其中Z是文本字符。时间为UTC（通用协调时间）时间。 greaterThanEqualTo(t) 和其它DateTime对象或浮点数比较DateTime对象，比如由Python 的time 模块返回的数值。如果对象表示一个大于或等于指定的DateTime或time 模块风格的时间的日期或时间对象，则返回真。通过比较长整数型的毫秒，它可以给出更为精确的结果。 dayOfYear() 返回按照对象所在时区表示的年的天数。 lessThan(t) 与其它的DateTime对象或一个浮点数比较DateTime对象，比如由Pythontime 模块返回的数字。如果对象表示一个小于指定的DateTime或time 模块风格的时间的日期或时间对象，则返回真。通过比较长整数型毫秒，它可以给出更为精确的结果。 AMPM() 返回一个对象的最接近秒的时间字符串。 isCurrentHour() 如果这个对象在所在时区中表示一个属于当前小时范围里的日期或时间对象，则返回真。 Month() 返回完整的月份的名称。 mm() 以两位数字符形式返回月份。 ampm() 返回适当的时间修饰语（am或pm）。 hour() 返回以24小时制表示的小时。 aCommonZ() 返回以”Mar 1, 1997 1:45 pm US/Eastern”格式表示对象值的字符串。 Day_() 兼容：见pDay。 pCommon() 返回以”Mar. 1, 1997 1:45 pm”格式表示的对象值的字符串。 minute() 返回分钟。 day() 返回以整数表示的天。 earliestTime() 返回一个新的表示最早时间（全部按秒计算）的DateTime对象，它仍然属于对象所在时区中的当前天。 Date() 返回对象的日期字符串。 Time() 返回对象的最接近秒的时间字符串。 isFuture() 如果这个对象表示一个晚于调用时间的时间日期对象，则返回真。 greaterThan(t) 和其它的DateTime对象或一个浮点数比较DateTime对象，比如和由Pythontime 模块返回的数字比较。如果对象表示一个大于指定的DateTime或符合time 模块风格的时间的date/time对象，则返回真。通过比较长整数型毫秒，它可以给出更为精确的结果。 TimeMinutes() 返回对象的时间字符串，不显示秒。 yy() 返回以两位数字符表示的日历年。 isCurrentDay() 如果对象在所在时区中表示一个属于当前天范围内的日期时间对象，则返回真。 dd() 返回以两位数字符形式表示的天。 rfc822() 返回以RFC 822格式显示的日期。 isLeapYear() 如果当前年（在对象所属时区中）是闰年则返回真 fCommon() 返回一个以”March 1, 1997 1:45 pm”格式表示的对象值的字符串。 isPast() 如果对象表示一个早于调用时间的日期时间对象，则返回真。 fCommonZ() 返回一个以”March 1, 1997 1:45 pm”格式表示的对象值的字符串。 timeTime() 返回UTC中按照Python time模块所使用的格式以浮点数形式表示的日期时间。注意，采用那些拥有对于time模块来说没有含义的值的DateTime来创建日期或时间是可能的。 toZone(z) 返回当前对象在指定的z时区中的DateTime 。 lessThanEqualTo(t) 和另外一个DateTime对象或一个浮点数比较DateTime对象，比如和由Python time模块返回的数字进行比较。如果对象表示一个小于或等于指定的DateTime或time模块风格的时间的日期时间，则返回真。通过比较长整数型毫秒，它可以给出更为精确的结果。 Mon() 兼容：参见aMonth。 parts() 返回包含对象的日历年、月、日、小时、分钟、秒和时区值的元组。 isCurrentYear() 如果这个对象在所属时区中表示一个属于当前年范围以内的日期时间对象，则返回真。 PreciseAMPM() 返回对象的时间字符串。 AMPMMinutes() 返回对象的时间字符串，不显示秒。 equalTo(t) 和另外一个DateTime对象或一个浮点数比较DateTime对象，比如和由Python time模块返回的数字进行比较。如果对象表示一个等于指定的DateTime或time模块风格时间的日期时间，则返回真。通过比较长整数型毫秒，它可以给出更为精确的结果。 pDay() 返回星期的简短名称（带有句点）。 notEqualTo(t) 和另外一个DateTime对象或一个浮点数比较DateTime对象，比如和由Python time模块返回的数字进行比较。如果对象表示一个不等于指定的DateTime或time模块风格时间的日期时间，则返回真。通过比较长整数型毫秒，它可以给出更为精确的结果。 h_24() 返回24小时制的小时。 pCommonZ() 返回以”Mar. 1, 1997 1:45 pm US/Eastern”格式表示的对象值的字符串。 isCurrentMonth() 如果对象在所属的时区中表示一个属于当前月范围以内的日期时间对象，则返回真。 DayOfWeek() 兼容：参见aDay。 latestTime() 返回一个新的表示最迟时间（全部按秒计算）的DateTime对象，它仍然属于对象所在时区中的当前天。 dow_1() 返回以整数表示的星期的天数，星期日为1。 timezone() 返回对象的所属时区。 year() 返回对象的日历年。 PreciseTime() 返回对象的时间字符串。 ISO() 按照ISO标准格式返回对象。输出格式为：YYYY-MM-DD HH:MM:SS millis() 返回自从GMT新纪元以来的毫秒数。 second() 返回秒 month() 返回以整数表示的对象的月份。 pMonth() 返回简写（带有句点）的月份名称。 aMonth() 返回简写的月份名称。 isCurrentMinute() 如果对象在所属时区中表示一个属于当前分钟范围以内的日期时间对象，则返回真。 Day() 返回星期中天的完整名称。 aDay() 返回星期中天的简写名称。 此外，DateTime对象还支持数值计算： 两个DateTime对象可以相减，从而获得两者间的时间差，单位为天。 一个DateTime对象和一个正的或负的数字可以相加，从而获得一个新DateTime对象。 一个正的或负的数字和一个DateTime对象可以相加，从而获得一个新DateTime对象。 一个正的或负的数字可以从一个DateTime对象中减去，从而获得一个新DateTime对象。","link":"/Zope-DateTime%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"Zope REQUEST 和 RESPONSE的常用方法","text":"##REQUEST environ CGI编程规范所要求的环境变量，包括用户请求头信息，服务器信息和其它用户请求相关的信息 form 从用户请求上提交的表单变量 cookies cookie数据 other 其它可以设置的数据 PARENTS 漫游访问对象时所经历的对象列表，从PARENTS[0]开始是所访问对象的父对象 RESPONSE 获取RESPONSE对象 URL 用户所访问的URL，但不包含参数字符串 URLn 其中的n分别是0, 1一直往上数。URL0就是URL，URL1是URL0去掉最后一级路径，URL2是URL1再去掉一级路径，直到网站根为止 URLPATHn URLPATHn分别对应着URLn的路径部分，如URLPATH0就是URL0的路径部分，依此类推 BASEn BASEn以一种与URLn相反的方式计数：BASE0就是网站根，BASE1是所访问的URL的网站根加上一级路径，BASE2就是加上二级路径，依此类推 BASEPATHn BASEPATHn就是BASEn的路径部分 get_header(name, default=None) 返回命名的HTTP头，或者可选的default参数，如果没有这个HTTP头则返回空。注意，有没有 HTTP_ 都可以识别，如 Content-Type,CONTENT_TYPE, HTTP_CONTENT_TYPE 都会返回 Content-Type 头，如果有的话。 getClientAddr() 以字符串形式返回客户端IP，不能找到时返回空字符串 has_key(key) 如果REQUEST对象上有这个key则返回真，否则返回假 items() 以(key, value)的形式返回对象的元组的一个序列 keys() 返回REQUEST所保存的所有对象的key的已排序的序列 set(name, value) 在REQUEST上设置属性，如在Plone模板开发中常用的设置无边框操作是request.set('disable_border', 1) set_lazy(key, callable) 设置延迟计算的数据，callable是一个可调用的对象当这个数据被访问时才调用callable计算出，计算后就保存在other数据中 setServerURL(protocol=None, hostname=None, port=None) 设置服务器相关的URL，同时会影响到URL,URLn,BASEn,还有absolute_url的计算值 values() 返回REQUEST中所保存的所有值的序列 ##RESPONSE addHeader(name, value) 添加一项HTTP响应头 expireCookie(name, **kw) 发送一个cookie过期的消息，通知浏览器删除这个cookie redirect(location, status=302, lock=0) 给浏览器回应重定向，如： RESPONSE.redirect('http://czug.org') setBase(base) 设置响应的基准URL，如果base为None或这个输出已经有base，则没有效果 setBody(body, title=””, is_error=0) 设置返回的响应体为body字符串的内容。并更新返回的Content-Length字段。 setCookie(name, value, **kw) 设置cookie信息，如：RESPONSE.setCookie('__cp', cp, path='%s' % cookie_path(REQUEST)) setHeader(name, value, literal=0) 设置一个返回的HTTP头 setStatus(status, reason=None) 设置返回状态，reason参数是用于描述这个状态的字符串。","link":"/Zope-REQUEST-%E5%92%8C-RESPONSE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"Zope对象的漫游方法","text":"absolute_url 返回当前对象的绝对路径，调用它如 context.absolute_url() absolute_url_path 返回当前对象的绝对路径中的path部分，调用它如 context.absolute_url_path() getPhysicalPath 返回对象的物理路径的列表，这个地址和是否使用虚拟主机在访问无关。调用它如 context.getPhysicalPath() unrestrictedTraverse 不检查访问权限的漫游, 此方法不能在ZMI脚本中使用，在扩展开发中的调用如 context.unrestrictedTraverse('path/to/object') restrictedTraverse 需要检查权限的漫游，与unrestrictedTraverse区别是多了每一级上的权限检查，如 context.restrictedTraverse('path/to/object')","link":"/Zope%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%BC%AB%E6%B8%B8%E6%96%B9%E6%B3%95/"},{"title":"Zope文件夹操作","text":"文件夹操作包括检查子对象的操作，还有剪切、拷贝、粘贴等： hasObject 检查文件夹中是否存在某个对象：folder.hasObject(id) objectIds 返回文件夹中的对象id字符串的列表，可以指定某些类型则只返回该类型：folder.objectIds() objectValues 返回文件夹中对象的列表，可以指定某些类型则只返回该类型：folder.objectValues() manage_delObjects 删除文件夹中的一些对象，参数是所要删除的id字符串列表：folder.manage_delObjects(['id']) _setObject 因为以下划线开头的函数是不会发布的，这个常用在文件系统上的开发中，用于给文件夹中添加对象：folder._setObject('id', someObject) manage_renameObject 修改文件夹中的子对象的id：folder.renameObject(id, new_id) manage_renameObjects 这个函数接受两个id的列表作为参数以同时对多个子对象进行改名：folder.renameObjects([id], [new_id]) manage_copyObjects 复制文件夹中的一组对象：cb_copy_data = folder.manage_copyObjects(['my_document']) manage_cutObjects 剪切文件夹中的一组对象：cb_copy_data = folder.manage_cutObjects(['my_document']) manage_pasteObjects 剪贴一组对象，它使用manage_copyObjects或manage_cutObjects的返回值作为参数：another_folder.manage_pasteObjects(cb_copy_data) objectItems 返回文件夹中对象的(id, value)形式的元组的列表。 现在介绍一个剪切、复制和粘贴的实例。下面的脚本，其功能是把刚才创建的my_document文档复制到新文件夹my_folder里： 1234567from Products.CMFCore.utils import getToolByNameurltool = getToolByName(context, &quot;portal_url&quot;)portal = urltool.getPortalObject()cb_copy_data = portal.manage_copyObjects([&quot;my_document&quot;])folder = getattr(portal, &quot;my_folder&quot;)folder.manage_pasteObjects(cb_copy_data)","link":"/Zope%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/"},{"title":"一行命令统计Nginx访问日志各个ip的访问次数","text":"查看访问各个ip及访问次数按访问次数排序 1[root@vm ~]# awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -rn 查看访问最多的10个ip及访问次数 1[root@vm ~]# awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -rn | head -10","link":"/%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E5%90%84%E4%B8%AAip%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0/"},{"title":"使用BCP命令导出SQL Server表数据","text":"使用BCP命令导出表数据到电子表格文件： 1234567891011121314151617--EXEC master..xp_cmdshell 'BCP test..person out f:\\backup\\person.xls -c -T'declare @tblname varchar(100)declare @dbname varchar(100)declare @dir varchar(200)declare @str varchar(500)set @dir = 'f:\\backup\\'set @dbname = 'test'set @tblname = ''while exists(select name from sys.tables where SCHEMA_NAME(schema_id)=N'dbo' and @tblname &lt; name)begin SELECT @tblname = min(name) from sys.tables where SCHEMA_NAME(schema_id)=N'dbo' and @tblname &lt; name set @str = 'BCP '+@dbname+'..'+@tblname+' out '+@dir+@tblname+'.xls -c -T' exec master..xp_cmdshell @strend","link":"/%E4%BD%BF%E7%94%A8BCP%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BASQL-Server%E8%A1%A8%E6%95%B0%E6%8D%AE/"},{"title":"使用Keil5创建STM32工程","text":"Keil对于做单片机开发的人员来所再熟悉不过了。Keil成立与1982年，在2005年10月被ARM公司收购。相信对于很多STM32的初学者来说从零开始创建一个STM32工程是比较困难的，很多人都是把之前的工程复制过来，再进行改编的，这样可以省掉很多烦恼。笔者最近也在学习STM32的开发，顺便整理一下自己的方法跟大家分享，下面来介绍如何使用Keil μVision5创建一个STM32的工程。 下载ST官方库 在ST官网:https://www.st.com/zh/microcontrollers-microprocessors.html下载STM32 Standard Peripheral Libraries库文件，打开后进入工具与软件 -&gt; 嵌入式软件 -&gt; MCU及MPU嵌入式软件： 笔者购买的开发板是使用STM32F103C8T6微控制器的开发板，所以选择STSW-STM32054: 下载完成后解压文件你会得到以下文件，这里主要用到的是Libraries和Project文件夹： 创建工程文件夹 创建文件夹Template作为工程文件的根目录，然后在Template目录下再创建以下文件夹：CMSIS、USER、FWLIB、STARTUP。 CMSIS用于存放内核函数，USER存放用户自己的函数，FWLIB存放库函数，STARTUP存放启动引导文件。 将STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\CoreSupport中的文件复制到工程目录的CMSIS文件夹中，将STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x中的.c和.h文件复制到工程目录的CMSIS文件夹中，复制完成后的CMSIS文件夹应该是这样的： 将STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template目录下的.c和.h文件复制到工程目录的USER文件夹中，复制完成后的USER文件就是这样的： 将STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver目录下的inc文件夹和src文件夹复制到工程目录的FWLIB文件夹中，复制完成后的FWLIB文件夹应该是这样的： 将STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm中的startup_stm32f10x_md.s文件复制到工程文件夹的STARTUP文件夹中，这里的是单片机的启动引导文件，可以根据芯片的FLASH容量来区分属于小容量、中容量和大容量从而决定使用哪个启动引导文件： FLASH容量 分类 对应的启动引导文件 FLASH &lt;= 32K 小容量 startup_stm32f10x_ld.s 64K &lt;= FLASH &lt;= 128K 中容量 startup_stm32f10x_md.s 256K &lt;= FLASH &lt;= 512K 大容量 startup_stm32f10x_hd.s 笔者购买的开发板是使用STM32F103C8T6的微控制器，拥有64K的FLASH，属于中容量的微控制器，所以启动引导文件选择arm中的startup_stm32f10x_md.s，复制完成后的STARTUP文件夹应该是这样的： 新建μVision工程 打开Keil，新建工程Template，工程文件保存在上一步的Template目录中，保存后选择芯片，这里我们用到的是STM32F103C8，在Search中输入STM32F103C8选中后点OK，在下一步弹出的Manager Run-Time Environment中我们点击Cancel，不需要让Keil来为我们添加库文件，我们使用之前下载好的库文件自己手工添加。 点击Manager Project Items按钮，将Project Targets更名为Template。 删除默认的Groups，并创建以下Groups：CMSIS、USER、FWLIB、STARTUP。 在CMSIS Group中添加工程文件目录的CMSIS文件夹里的.c文件；在USER Group中添加工程文件目录的USER文件夹里的.c文件；在FWLIB Group中添加工程文件目录的FWLIB\\src文件夹里的.c文件；在STARTUP Group中添加工程文件目录的STARTUP文件夹里的startup_stm32f10x_md.s文件；添加完成后点击OK。 点击Options for Target按钮（魔术棒）选择C/C++设置页，在Preprocessor Symbots的Define中填写：USE_STDPERIPH_DRIVER, STM32F10X_MD这里的STM32F10X_MD是因为启动引导文件使用的是中容量的引导文件；Include Paths中填写：.\\CMSIS;.\\FWLIB\\inc;.\\FWLIB\\src;.\\USER;.\\CMSIS\\startup\\arm，完成后点击OK。 编译调试 编译工程出现报错： 12345678910111213141516Rebuild started: Project: Template*** Using Compiler 'V5.06 update 6 (build 750)', folder: 'C:\\Keil_v5\\ARM\\ARMCC\\Bin'Rebuild target 'Template'compiling core_cm3.c...compiling main.c...USER\\main.c(24): error: #5: cannot open source input file &quot;stm32_eval.h&quot;: No such file or directory #include &quot;stm32_eval.h&quot;USER\\main.c: 0 warnings, 1 errorcompiling system_stm32f10x.c......compiling stm32f10x_tim.c...assembling startup_stm32f10x_md.s...compiling stm32f10x_wwdg.c...&quot;.\\Objects\\Template.axf&quot; - 1 Error(s), 0 Warning(s).Target not created.Build Time Elapsed: 00:00:08 原因是没有找到文件stm32_eval.h，修改main.c文件，将不需要的内容删除，修改后的main.c文件如下： 12345678910111213141516171819/* Includes ------------------------------------------------------------------*/#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;/* Private functions ---------------------------------------------------------*//** * @brief Main program. * @param None * @retval None */int main(void){ /* Infinite loop */ while (1) { }} 重新编译工程，依然有错： 12345678910111213141516Rebuild started: Project: Template*** Using Compiler 'V5.06 update 6 (build 750)', folder: 'C:\\Keil_v5\\ARM\\ARMCC\\Bin'Rebuild target 'Template'...compiling stm32f10x_wwdg.c...linking....\\Objects\\Template.axf: Error: L6200E: Symbol SystemCoreClock multiply defined (by system_stm32f10x_1.o and system_stm32f10x.o)..\\Objects\\Template.axf: Error: L6200E: Symbol AHBPrescTable multiply defined (by system_stm32f10x_1.o and system_stm32f10x.o)..\\Objects\\Template.axf: Error: L6200E: Symbol SystemInit multiply defined (by system_stm32f10x_1.o and system_stm32f10x.o)..\\Objects\\Template.axf: Error: L6200E: Symbol SystemCoreClockUpdate multiply defined (by system_stm32f10x_1.o and system_stm32f10x.o).Not enough information to list image symbols.Not enough information to list load addresses in the image map.Finished: 2 information, 0 warning and 4 error messages.&quot;.\\Objects\\Template.axf&quot; - 4 Error(s), 0 Warning(s).Target not created.Build Time Elapsed: 00:00:07 原因是system_stm32f10x.c文件重复，在CMSIS中和USER中都有一份，我们需要将USER中的system_stm32f10x.c文件移除出工程，点击Manager Project Items，选择USER Group，选择USER里的stm32f10x.c然后点击删除按钮。完成后点击OK。 重新编译工程，此时没有报错了： 123456789101112Rebuild started: Project: Template*** Using Compiler 'V5.06 update 6 (build 750)', folder: 'C:\\Keil_v5\\ARM\\ARMCC\\Bin'Rebuild target 'Template'compiling core_cm3.c......compiling stm32f10x_usart.c...assembling startup_stm32f10x_md.s...compiling stm32f10x_wwdg.c...linking...Program Size: Code=856 RO-data=268 RW-data=20 ZI-data=1636 &quot;.\\Objects\\Template.axf&quot; - 0 Error(s), 0 Warning(s).Build Time Elapsed: 00:00:07 保存工程作为以后开发的模板工程，下次开发新项目时复制一份出来可以直接在这上面开发了。 测试工程文件 编辑main.c文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** ****************************************************************************** * @file Project/STM32F10x_StdPeriph_Template/main.c * @author Junle * @version V3.5.0 * @date 27-April-2020 * @brief Main program body ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;/* Private functions ---------------------------------------------------------*/void LED_GPIO_Config(void); //配置GPIOvoid Delay(__IO u32 nCount); //延时函数/** * @brief 配置GPIO. * @param None * @retval None */void LED_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 开启GPIOB时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //定义要使用的pin GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //复用功能的推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //初始化GPIO}/** * @brief 延时函数. * @param None * @retval None */void Delay(__IO u32 nCount){ for(; nCount != 0; nCount--);} /** * @brief Main program. * @param None * @retval None */int main(void){ SystemInit(); LED_GPIO_Config(); /* Infinite loop */ while (1) { GPIO_ResetBits(GPIOB, GPIO_Pin_10); Delay(0x400000); GPIO_SetBits(GPIOB, GPIO_Pin_10); Delay(0x400000); }}/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 点击Options for Target按钮（魔术棒）选择Output设置页，勾选Create HEX File然后点击OK，重新编译工程，完成后在工程文件夹下会生产Objects文件夹，HEX文件会存放在该文件夹中。 将LED和电阻串联连接到开发板的PB10引脚： 下载HEX文件到STM32F103C8T6开发板，运行效果： LED灯闪烁，说明我们手动创建的工程文件可用。","link":"/%E4%BD%BF%E7%94%A8Keil5%E5%88%9B%E5%BB%BASTM32%E5%B7%A5%E7%A8%8B/"},{"title":"使用STM32F103C8T6驱动0.96寸RGB IPS显示屏","text":"笔者购买的是一款0.96寸的IPS显示屏，分辨率为160x80，驱动器IC为ST7735S，65k Colors, RGB 5,6,5-bit Input。 接口定义： GND： 接地； VCC： 3.3~5V电源正； SCL： SPI时钟线； SDA： SPI数据线； RES： 重启线； DC： SPI数据/命令选择线； CS： 片选接口； BLK： 被光控制，默认NC，低电平关闭背光。 本文介绍实现SPI通信协议来驱动显示屏，先给出代码：stm32f103c8-st7735s-lcd ## SPI通信时序参考ST7735S数据手册4线串行接口时序，SPI协议向ST7735S写数据流程是： 把CS片选线从高电平拉到低电平，使能芯片； 操作SDA，DC引脚为要写入的数据 在SCL时钟的上升沿时刻写入数据到芯片中； 重复以上2、3步骤直到各个位的数据写入到芯片； 把CS片选冲低电平拉升到高电平，停止通信。 时序如下图：实现代码如下： 123456789101112131415161718192021/** * @brief SPI协议写一个字节 * @param data 8位数据 * @retval None */void writeBus(uint8_t data){ uint8_t i; LCD_CS_CLR(); for(i=0; i&lt;8; i++) { LCD_SCL_CLR(); if(data&amp;0x80) LCD_SDA_SET(); else LCD_SDA_CLR(); LCD_SCL_SET(); data&lt;&lt;=1; } LCD_CS_SET();} 运行效果 lcd.c中已经实现了一个显示字符串的函数void LCD_showString(uint16_t x, uint16_t y, char *p, uint16_t color);,x, y是字符串显示的左上像素坐标，*p为字符串，color为显示函数。实现方法是使用PCtoLCD2002取模软件对ASCII字符进行取模取模，取模的结果放到font.h文件中。","link":"/%E4%BD%BF%E7%94%A8STM32F103C8T6%E9%A9%B1%E5%8A%A80-96%E5%AF%B8RGB-IPS%E6%98%BE%E7%A4%BA%E5%B1%8F/"},{"title":"分享一款有趣的工具——neural-style","text":"neural-style是一款使用机器学习给照片添加各种风格的Python工具，详细介绍可以参考https://github.com/anishathalye/neural-style。 安装Python3； 从Github克隆代码； 1git clone https://github.com/anishathalye/neural-style 安装需求的包numpy，Pillow，scipy，tensorflow； 1pip install -r requirements.txt 下载训练好的模型放在neural-style的根目录； Pre-trained VGG network (MD5 106118b7cf60435e6d8e04f6a6dc3657) 运行； 1python neural_style.py --content &lt;content file&gt; --styles &lt;style file&gt; --output &lt;output file&gt; &lt;content file&gt;：原图路径； &lt;style file&gt;：风格图片路径； &lt;output file&gt;：输出文件路径； 更多参数设置可运行python neural_style.py -h查看。 原图 风格 处理后的图片","link":"/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94neural-style/"},{"title":"在CentOS7上启用BBR提速","text":"BBR (Bottleneck Bandwidth and RTT)是由Google提供给Linux内核TCP堆栈的一种新的拥塞控制算法。有了BBR，Linux服务器可以显着提高吞吐量并减少连接延迟。 需求 CentOS7 x64服务器 root用户 更新Linux内核安装elrepo repo: 12rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm 从安装elrepo安装内核 1yum --enablerepo=elrepo-kernel install kernel-ml -y 确定内核安装完成 1rpm -qa | grep kernel 内核安装完成输出内容如下： 1234567kernel-ml-4.10.4-1.el7.elrepo.x86_64kernel-ml-headers-4.19.5-1.el7.elrepo.x86_64kernel-tools-libs-3.10.0-862.14.4.el7.x86_64kernel-ml-4.19.0-1.el7.elrepo.x86_64kernel-tools-3.10.0-862.14.4.el7.x86_64kernel-ml-4.19.5-1.el7.elrepo.x86_64kernel-3.10.0-514.el7.x86_64 修改grub2设置启用新内核，输入以下命令显示grub2菜单中的所有条目： 1egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\' 输出结果如下： 123456CentOS Linux (4.19.5-1.el7.elrepo.x86_64) 7 (Core)CentOS Linux 7 Rescue b38eea25ce6937aa19f219f91608f833 (4.19.0-1.el7.elrepo.x86_64)CentOS Linux (4.19.0-1.el7.elrepo.x86_64) 7 (Core)CentOS Linux (4.10.4-1.el7.elrepo.x86_64) 7 (Core)CentOS Linux (3.10.0-514.el7.x86_64) 7 (Core)CentOS Linux (0-rescue-bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) 7 (Core) 输出结果从上到下编号为0-5，我们需要将grub2的默认启动项设置为*CentOS Linux (4.19.5-1.el7.elrepo.x86_64) 7 (Core)*（第一项编号为0）： 1grub2-set-default 0 设置完成后重启服务器： 1reboot 重启完成后输入以下命令确定新内核引导成功： 1uname -r 输出结果如下则说明成功： 14.19.5-1.el7.elrepo.x86_64 启用BBR输入以下命令修改sysctl配置： 123echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.confsysctl -p 完成后依次输入以下命令确定系统是否启用了BBR： 12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control 如果输出结果中都含有BBR字样，则表示BBR已经启用。","link":"/%E5%9C%A8CentOS7%E4%B8%8A%E5%90%AF%E7%94%A8BBR%E6%8F%90%E9%80%9F/"},{"title":"如何在CentOS 7上安装ERP5","text":"需求 CentOS 7服务器 ipv6地址 root用户权限 安装SlapOS Node可以参考文档《如何在CentOS 7上安装SlapOS》完成SlapOS Node安装。 配置SlapOS在终端输入以下命令： 123456slapos configure local \\ --interface-name eth0 \\ --partition-number 16 \\ --ipv4-local-network 10.0.0.0/24 \\ --daemon-listen-ip 127.0.0.1 \\ --daemon-listen-port 50000 interface-name: Computer Partition使用的网卡， 请根据自己实际的网卡填写， 该网卡需要有ipv6地址。partition-number: SlapOS创建的Computer Partition数量，对于ERP5需要10个左右，这里我们配置16个。ipv4-local-network: Computer Partition使用的网络。daemon-listen-ip: slapos-proxy绑定的地址。daemon-listen-port: slapos-proxy绑定的端口。 完成后输入以下命令格式化Computer Partition： 1slapos node format --now 输出如下： 1234[root@vm ~]# slapos node format --now2018-10-19 14:18:11 slapos[1464] INFO Updating computer2018-10-19 14:18:32 slapos[1464] INFO Posting information to 'http://127.0.0.1:50000'2018-10-19 14:18:32 slapos[1464] INFO slapos successfully prepared the computer. 安装ERP5获取SlapOS buildout配置文件到本地目录*/opt/buildout* 1mkdir -p /opt/buildout &amp;&amp; cd /opt/buildout 1git clone https://github.com/SlapOS/slapos.git 1cd slapos &amp;&amp; git checkout 1.0.67 构建和安装ERP5软件 1slapos supply /opt/buildout/slapos/software/erp5/software.cfg local_computer SlapOS会根据buildout配置去构建和安装ERP5所需的各个软件，ERP5构建过程可能需要较长时间，建议丢在那里让它跑一晚上，通过以下命令可以查看buildout日志： 1tail -f /opt/slapos/log/slapos-node-software.log 输入以下命令： 1slapos node software 输出内容如下，则说明软件构建完成： 123[root@vm opt]# slapos node software2018-10-19 14:35:14 slapos[7190] INFO Processing software releases...2018-10-19 14:35:14 slapos[7190] INFO Finished software releases. 创建ERP5实例输入以下命令创建ERP5实例： 1slapos request erp5 /opt/buildout/slapos/software/erp5/software.cfg SlapOS会自动创建ERP5实例，实例化过程大约需要5-10分钟，通过以下命令查看实例化日志： 1tail -f /opt/slapos/log/slapos-node-instance.log 输入以下命令查看实例化结果： 1slapos request erp5 /opt/buildout/slapos/software/erp5/software.cfg 输出结果如下，则说明实例化完成。 123452018-10-19 16:47:39 slapos[13925] INFO Instance requested.State is : started.2018-10-19 16:47:39 slapos[13925] INFO Connection parameters of instance are:2018-10-19 16:47:39 slapos[13925] INFO {'_': '{&quot;hosts-dict&quot;: {&quot;erp5-cloudooo&quot;: &quot;10.0.0.221&quot;, &quot;erp5-smtp&quot;: &quot;127.0.0.2&quot;, &quot;erp5-catalog-0&quot;: &quot;10.0.0.218&quot;, &quot;erp5-memcached-volatile&quot;: &quot;10.0.0.215&quot;, &quot;erp5-memcached-persistent&quot;: &quot;10.0.0.214&quot;}, &quot;site-id&quot;: &quot;erp5&quot;, &quot;monitor-setup-url&quot;: &quot;&quot;, &quot;family-default-v6&quot;: &quot;https://[xxxx:xxx::xxxx]:2151&quot;, &quot;deadlock-debugger-password&quot;: &quot;yzhmrcqk&quot;, &quot;inituser-login&quot;: &quot;zope&quot;, &quot;inituser-password&quot;: &quot;uslxwikz&quot;, &quot;monitor-base-url&quot;: &quot;&quot;, &quot;mariadb-test-database-list&quot;: [&quot;mysql://testuser_0:testpassword0@10.0.0.218:2099/erp5_test_0&quot;], &quot;mariadb-database-list&quot;: [&quot;mysql://user:insecure@10.0.0.218:2099/erp5&quot;], &quot;memcached-volatile-url&quot;: &quot;memcached://10.0.0.215:2013/&quot;, &quot;memcached-persistent-url&quot;: &quot;memcached://10.0.0.214:2003/&quot;, &quot;caucase-http-url&quot;: &quot;http://[xxxx:xxx::xxxx]:8890&quot;, &quot;cloudooo-url&quot;: &quot;http://10.0.0.221:2020/&quot;, &quot;family-default&quot;: &quot;https://10.0.0.211:2151&quot;}'}2018-10-19 16:47:39 slapos[13925] INFO You can rerun the command to get up-to-date information. ERP5的实例化结果输出的是一个字典，** family-default-v6 是ERP5实例连接url， inituser-login 是用户名， inituser-password **是密码。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E5%AE%89%E8%A3%85ERP5/"},{"title":"如何在CentOS 7上安装SlapOS Node","text":"需求 CentOS 7服务器 root用户权限 添加SlapOS源1sudo wget https://download.opensuse.org/repositories/home:/VIFIBnexedi/CentOS_7/home:VIFIBnexedi.repo -O /etc/yum.repos.d/slapos.repo 导入RPM-GPG-KEY1sudo rpm --import http://download.opensuse.org/repositories/home:/VIFIBnexedi/CentOS_7/repodata/repomd.xml.key 安装SlapOS1sudo yum install slapos.node -y","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E5%AE%89%E8%A3%85SlapOS-Node/"},{"title":"如何在CentOS 7上安装和配置VNC Server","text":"安装GNOME Desktop Packages1yum groupinstall &quot;GNOME Desktop&quot; 安装Tigervnc和依赖包1yum install tigervnc-server xorg-x11-fonts-Type1 创建VNC Server配置文件复制VNC配置文件模板/lib/systemd/system/vncserver@.service到/etc/systemd/system/vncserver@:&lt;Port_Number&gt;.service。我们希望VNC Server监听5903端口&lt;Port_Number&gt;为3，如果监听VNC Server监听5904端口&lt;Port_Number&gt;则为4，以此类推： 1cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:3.service 修改VNC Server配置文件修改配置文件/etc/systemd/system/vncserver@:3.service： 123456789101112131415[Unit]Description=Remote desktop service (VNC)After=syslog.target network.target[Service]Type=forkingExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'ExecStart=/usr/sbin/runuser -l &lt;USER&gt; -c &quot;/usr/bin/vncserver %i&quot;PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pidExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'[Install]WantedBy=multi-user.target 替换文本中的**&lt;USER&gt;**为你的VNC用户。 firewall添加端口12firewall-cmd --permanent --zone=public --add-port=5903/tcpfirewall-cmd --reload 设置VNC密码12345678910111213141516171819[root@vm ~]# su - testLast login: Tue Jul 23 08:47:39 CST 2019 on pts/0[test@vm ~]$ vncserverYou will require a password to access your desktops.Password:Verify:Would you like to enter a view-only password (y/n)? nA view-only password is not usedxauth: file /home/test/.Xauthority does not existNew 'vm:3 (test)' desktop is vm:3Creating default startup script /home/test/.vnc/xstartupCreating default config /home/test/.vnc/configStarting applications specified in /home/test/.vnc/xstartupLog file is /home/test/.vnc/vm:3.log 启动VNC Server和设置开机启动123systemctl daemon-reloadsystemctl start vncserver@:3.servicesystemctl enable vncserver@:3.service","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEVNC-Server/"},{"title":"如何在CentOS 7上添加SSH端口","text":"修改文件/etc/ssh/sshd_config12Port 22 #去掉这行开头的#号Port 22222 #添加一行 firewall添加端口12firewall-cmd --zone=public --add-port=22222/tcp --permanentfirewall-cmd --reload 修改selinux如果没有安装policycoreutils-python需要先安装： 1yum -y install policycoreutils-python 安装完成后添加22222端口： 1semanage port -a -t ssh_port_t -p tcp 22222 查看是否添加成功： 12[root@vm ~]# semanage port -l | grep sshssh_port_t tcp 22222, 22 重启ssh服务1systemctl restart sshd 检查ssh服务是否监听22222端口： 123456789101112131415161718[root@vm ~]# systemctl status sshd● sshd.service - OpenSSH server daemon Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2019-07-23 15:26:10 CST; 24s ago Docs: man:sshd(8) man:sshd_config(5) Main PID: 17854 (sshd) Tasks: 1 CGroup: /system.slice/sshd.service └─17854 /usr/sbin/sshd -DJul 23 15:26:10 vm systemd[1]: Starting OpenSSH server daemon...Jul 23 15:26:10 vm sshd[17854]: Server listening on 0.0.0.0 port 22222.Jul 23 15:26:10 vm sshd[17854]: Server listening on :: port 22222.Jul 23 15:26:10 vm sshd[17854]: Server listening on 0.0.0.0 port 22.Jul 23 15:26:10 vm sshd[17854]: Server listening on :: port 22.Jul 23 15:26:10 vm systemd[1]: Started OpenSSH server daemon.Hint: Some lines were ellipsized, use -l to show in full. 可见看到ssh服务监听22222和22端口。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E6%B7%BB%E5%8A%A0SSH%E7%AB%AF%E5%8F%A3/"},{"title":"如何在CentOS8上安装Mysql5.7","text":"在CentOS8上，默认情况下直接使用yum安装mysql，安装的是Mysql 8.0，在一些比较老的项目中，我们需要使用的mysql版本是5.7，下面我分享一个在CentOS8中安装Myslq5.7的方法。 12345678910111213141516···Dependencies resolved.================================================================================ Package Arch Version Repository Size================================================================================Installing: mysql x86_64 8.0.17-3.module_el8.0.0+181+899d6349 AppStream 11 MInstalling dependencies: mysql-common x86_64 8.0.17-3.module_el8.0.0+181+899d6349 AppStream 143 kEnabling module streams: mysql 8.0Transaction Summary================================================================================Install 2 Packages··· 下载Mysql5.7的RPM包进入https://downloads.mysql.com/archives/community/，选择对应的mysql版本和操作系统版本，下载以下包： RPM Package, MySQL Server RPM Package, Client Utilities RPM Package, Shared Libraries RPM Package, MySQL Configuration安装Mysql Server需要这些包。 安装过程安装时需要按以下顺序安装，因为这些包存在依赖关系：MySQL Configuration -&gt; Shared Libraries -&gt; Client Utilities -&gt; MySQL Server 1234yum localinstall mysql-community-common-5.7.30-1.el7.x86_64.rpmyum localinstall mysql-community-libs-5.7.30-1.el7.x86_64.rpmyum localinstall mysql-community-client-5.7.30-1.el7.x86_64.rpmyum localinstall mysql-community-server-5.7.30-1.el7.x86_64.rpm 配置Mysql 系统启动时自启动： 1systemctl enable mysqld 启动mysql服务： 1systemctl start mysqld 查看mysqld服务运行状态： 1systemctl status mysqld 输出内容： 123456789101112● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Fri 2020-08-21 02:07:18 EDT; 41min ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 55384 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 55366 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 55386 (mysqld) Tasks: 28 (limit: 24984) Memory: 178.1M CGroup: /system.slice/mysqld.service └─55386 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid 如果忘记root密码需要重置root密码可参考《如何重置Mysql5.7 root密码》。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS8%E4%B8%8A%E5%AE%89%E8%A3%85Mysql5-7/"},{"title":"如何在Chart.js的图表顶部显示值","text":"本文介绍如何在Chart.js的图表顶部显示数值。 制作一个曲线图表，如下图所示。需要看具体数值时需要点击曲线上的点才能显示，用户在手机上操作时由于手机屏幕小很难点击到曲线上的点，需要将具体数值显示在曲线对应的点上。 方法一通过查找我找到了一些解决方法：https://stackoverflow.com/questions/42556835/show-values-on-top-of-bars-in-chart-js/42562284，但这个解决方法存在一些问题： 当图表中存在两个以上的曲线时，显示的数值颜色跟曲线的颜色不匹配； 当点击图例隐藏曲线时，数值不能隐藏； 根据这些问题我对option的animation进行修改如下： 12345678910111213141516171819202122232425&quot;animation&quot;: { &quot;duration&quot;: 1, &quot;onComplete&quot;: function() { var chartInstance = this.chart, ctx = chartInstance.ctx; ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize, Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily); ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; chartLegendItems = chartInstance.legend.legendItems; //获取图例 this.data.datasets.forEach(function(dataset, i) { var meta = chartInstance.controller.getDatasetMeta(i); meta.data.forEach(function(bar, index) { if (chartLegendItems[i].hidden == false) { //当图例隐藏时不显示数值 var data = Number(dataset.data[index]).toFixed(2); //保留两位小数 ctx.fillStyle = dataset.backgroundColor; //设置数值字体颜色为曲线颜色 ctx.fillText(data, bar._model.x, bar._model.y - 8); } }); }); }} 效果如下图： 方法二通过chartjs插件：chartjs-plugin-datalabels 添加script： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.7.0&quot;&gt;&lt;/script&gt; 效果如下图：你还可以自定义数值显示样式，详细内容可以参考chartjs-plugin-datalabels的文档。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8Chart-js%E7%9A%84%E5%9B%BE%E8%A1%A8%E9%A1%B6%E9%83%A8%E6%98%BE%E7%A4%BA%E5%80%BC/"},{"title":"如何在Ubuntu 20.04部署Apache Superset","text":"Apache Superset 是一个开源数据可视化软件，能够处理 PB 级大数据。该应用程序最初是 Maxime Beauchemin（Apache Airflow的创建者）在 Airbnb 工作时的一个 hack-a-thon 项目，并于 2017 年进入 Apache 孵化器计划。除了 Airbnb，该项目还得到了其他领先科技公司的重大贡献，包括 Lyft 和 Dropbox。 2021年Superset 从孵化器项目毕业，成为 Apache 软件基金会的顶级项目。——维基百科 Superset提供： 用于快速构建图表的无代码界面 强大的、基于 Web 的 SQL 编辑器，可用于高级查询 用于快速定义自定义维度和指标的轻量级语义层 对几乎所有 SQL 数据库或数据引擎的开箱即用支持 各种漂亮的可视化展示您的数据，从简单的条形图到地理空间可视化 轻量级、可配置的缓存层，有助于减轻数据库负载 高度可扩展的安全角色和身份验证选项 用于程序化定制的 API 从头开始设计的云原生架构以实现规模化 安装依赖使用以下命令安装依赖： 1sudo apt-get install build-essential libssl-dev libffi-dev python3-dev python3-pip libsasl2-dev libldap2-dev default-libmysqlclient-dev postgresql postgresql-contrib nginx 创建PostgreSQL数据库和数据库用户本教程使用PostgreSQL数据库作为Superset的数据库，安装完成后需要进行以下配置。 通过以下命令登录到PostgreSQL数据库： 1sudo -u postgres psql 创建Superset数据库 1CREATE DATABASE superset_db; 创建数据库用户 1CREATE USER superset_user WITH PASSWORD 'password'; 修改数据库链接参数 123ALTER ROLE superset_user SET client_encoding TO 'utf8';ALTER ROLE superset_user SET default_transaction_isolation TO 'read committed';ALTER ROLE superset_user SET timezone TO 'UTC'; superset_user访问管理superset数据库 1GRANT ALL PRIVILEGES ON DATABASE superset_db TO superset_user; 配置完成后使用以下命令退出PostgreSQL交互界面 1\\q 为您Superset创建 Python 虚拟环境 更新pip和安装必要的包 12sudo pip install --upgrade pipsudo pip install virtualenv 创建虚拟环境 1virtualenv superset 激活虚拟环境 1source superset/bin/activate 安装Superset 1pip install apache-superset 安装其他python依赖 1pip install gunicorn gevent Pillow pymssql 配置Superset 在superset/bin目录创建Superset配置文件superset_config.py，详细配置可参考官方文档或这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Superset specific configROW_LIMIT = 5000#SUPERSET_WEBSERVER_PORT = 8088# Flask App Builder configuration# Your App secret key will be used for securely signing the session cookie# and encrypting sensitive information on the database# Make sure you are changing this key for your deployment with a strong key.# You can generate a strong key using `openssl rand -base64 42`'''使用命令“openssl rand -base64 42”创建SECRET_KEY填写到下面'''SECRET_KEY = ''# The SQLAlchemy connection string to your database backend# This connection defines the path to the database that stores your# superset metadata (slices, connections, tables, dashboards, ...).# Note that the connection information to connect to the datasources# you want to explore are managed directly in the web UI'''数据库连接，我是用的是PostgreSQL数据库链接字符串：postgresql://&lt;数据库用户&gt;:&lt;密码&gt;@&lt;主机名/ip&gt;/&lt;数据库名&gt;'''SQLALCHEMY_DATABASE_URI = 'postgresql://superset_user:password@127.0.0.1/superset_db'# Flask-WTF flag for CSRFWTF_CSRF_ENABLED = True# Add endpoints that need to be exempt from CSRF protectionWTF_CSRF_EXEMPT_LIST = []# A CSRF token that expires in 1 yearWTF_CSRF_TIME_LIMIT = 60 * 60 * 24 * 365# Set this API key to enable Mapbox visualizationsMAPBOX_API_KEY = ''COMPRESS_REGISTER = False#默认中文BABEL_DEFAULT_LOCALE = &quot;zh&quot;#superset支持的语言LANGUAGES = { &quot;en&quot;: {&quot;flag&quot;: &quot;us&quot;, &quot;name&quot;: &quot;English&quot;}, &quot;es&quot;: {&quot;flag&quot;: &quot;es&quot;, &quot;name&quot;: &quot;Spanish&quot;}, &quot;it&quot;: {&quot;flag&quot;: &quot;it&quot;, &quot;name&quot;: &quot;Italian&quot;}, &quot;fr&quot;: {&quot;flag&quot;: &quot;fr&quot;, &quot;name&quot;: &quot;French&quot;}, &quot;zh&quot;: {&quot;flag&quot;: &quot;cn&quot;, &quot;name&quot;: &quot;Chinese&quot;}, &quot;ja&quot;: {&quot;flag&quot;: &quot;jp&quot;, &quot;name&quot;: &quot;Japanese&quot;}, &quot;de&quot;: {&quot;flag&quot;: &quot;de&quot;, &quot;name&quot;: &quot;German&quot;}, &quot;pt&quot;: {&quot;flag&quot;: &quot;pt&quot;, &quot;name&quot;: &quot;Portuguese&quot;}, &quot;pt_BR&quot;: {&quot;flag&quot;: &quot;br&quot;, &quot;name&quot;: &quot;Brazilian Portuguese&quot;}, &quot;ru&quot;: {&quot;flag&quot;: &quot;ru&quot;, &quot;name&quot;: &quot;Russian&quot;}, &quot;ko&quot;: {&quot;flag&quot;: &quot;kr&quot;, &quot;name&quot;: &quot;Korean&quot;}, &quot;sk&quot;: {&quot;flag&quot;: &quot;sk&quot;, &quot;name&quot;: &quot;Slovak&quot;}, &quot;sl&quot;: {&quot;flag&quot;: &quot;si&quot;, &quot;name&quot;: &quot;Slovenian&quot;}, &quot;nl&quot;: {&quot;flag&quot;: &quot;nl&quot;, &quot;name&quot;: &quot;Dutch&quot;},}SHOW_STACKTRACE = FalseDEBUG = FalseAPP_NAME = &quot;Superset&quot; 通过运行以下命令完成初始化Superset 123456789101112# 初始化数据库superset db upgrade# 在您的元数据数据库中创建一个管理员用户（使用 `admin` 作为用户名以便能够加载示例）$ export FLASK_APP=supersetsuperset fab create-admin# 加载演示数据superset load_examples# 创建默认角色和权限superset init 创建/etc/systemd/system/superset.service服务 123456789101112[Unit]Description=superset daemonAfter=network.target[Service]User=supersetGroup=supersetWorkingDirectory=/home/superset/superset/ExecStart=/home/superset/superset/bin/gunicorn -w 2 -k gevent --worker-connections 1000 --timeout 120 -b localhost:6666 --limit-request-line 0 --limit-request-field_size 0 --statsd-host localhost:8125 &quot;superset.app:create_app()&quot;[Install]WantedBy=multi-user.target 服务创建完成后需要执行以下命令 1sudo systemctl daemon-reload 启动Superset服务 1sudo systemctl start superset 服务启动后会监听本地的6666端口。 配置Nginx 下面的是我的配置文件，需根据自己的实际情况修改 1234567891011121314151617181920212223242526upstream superset { server 127.0.0.1:6666;}server { listen 80; listen [::]:80; server_name _; return 301 https://$server_name$request_uri;}server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name _; ssl_certificate /etc/nginx/ssl/fullchain.cer; ssl_certificate_key /etc/nginx/ssl/private.key; location / { proxy_pass http://superset; }} 配置完成后reload一下Nginx 1sudo systemctl reload nginx 运行效果登陆界面右上角可以选择语言，输入之前创建的管理员用户名密码 演示数据包含以下已经做好的看板 看板效果 踩坑 初始化执行superset db upgrade 时报错：ImportError: cannot import name 'soft_unicode' from 'markupsafe' in... 原因：MarkupSafe:2.1.0版本取消了soft_unicode（https://markupsafe.palletsprojects.com/en/2.1.x/changes/#version-2-1-0），Superset安装的时候默认安装的MarkupSafe:2.1.0。 解决方法：pip install --upgrade MarkupSafe==2.0.1，降低MarkupSafe的版本。 优化汉化问题，修改site-packages/superset/translations/zh/LC_MESSAGES/目录下的po文件，修改后进入site-packages/superset目录执行命令：pybabel compile -d translations重新编译。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu-20-04%E9%83%A8%E7%BD%B2Apache-Superset/"},{"title":"如何在Ubuntu 20.10上安装Odoo14","text":"需求 git Python3.6 or later PostgreSQL10.0 or later 安装步骤安装依赖1sudo apt install python3-dev libxml2-dev libxslt1-dev libldap2-dev libsasl2-dev libtiff5-dev libjpeg8-dev libopenjp2-7-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev libharfbuzz-dev libfribidi-dev libxcb1-dev libpq-dev 安装wkhtmltox 123wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.focal_amd64.debsudo dpkg -i wkhtmltox_0.12.5-1.focal_amd64.deb 如果以上命令出现了报错，通过如下命令可强制安装依赖： 1sudo apt-get install -f 安装PostgreSQL： 1sudo apt install postgresql postgresql-client -y 对于具有从右到左界面的语言（例如阿拉伯语或希伯来语），需要软件包rtlcss： 12sudo apt-get install nodejs npm -ysudo npm install -g rtlcss 下载Odoo源代码 创建目录~/odoo-dev/用于存放Odoo源代码： 123mkdir ~/odoo-devcd ~/odoo-devgit clone https://github.com/odoo/odoo -b 14.0 --depth=1 安装Odoo Python依赖1pip3 install -r ~/odoo-dev/odoo/requirements.txt 创建Odoo应用数据库 切换linux用户到postgres： 1sudo su - postgres 使用psql命令进入PostgreSQL数据库： 1psql 使用以下命令创建Odoo数据库用户和数据库： 123456CREATE DATABASE odoodev;CREATE USER odoouser WITH PASSWORD 'password';ALTER ROLE odoouser SET client_encoding TO 'utf8';ALTER ROLE odoouser SET default_transaction_isolation to 'read committed';ALTER ROLE odoouser SET timezone to 'GTM+8';GRANT ALL PRIVILEGES ON DATABASE odoodev to odoouser; 完成后输入以下指令推出数据库后台： 1\\q 启动实例1python3 odoo-bin -d odoodev -i base --addons-path=addons --db-filter=odoodev$ –-db_host=localhost --db_user=odoouser --db_password='password' 命令参数解释： -d database_name：默认使用这一数据库。 –db-filter=database_name$：仅尝试连接匹配所提供正则表达式的数据库。一个Odoo安装可以为使用不同数据库的多个实例提供服务，通过这一参数限制可用的数据库。最后的那个$很重要，因为在匹配模式中使用了正则表达式，这会避免选择以相同的指定字符串开头的名称。 –addons-path=directory1,directory2,…：Odoo通过这一逗号分隔列表中的目录来查找插件（add-on）。在实例创建的时候扫描该列表来添加实例中可用的插件模块列表。如果希望使用Odoo企业版，请在这一选项中添加其目录。 -i base: 用于安装base模块。通过命令行创建数据库时需要使用到。 –db_host=localhost: 使用TCP连接数据库服务 –db_user=odoouser: 使用指定的数据库登录用户 –db_password=password: 这是用于认证PostgreSQL服务的密码 更多参数可使用--help查看。","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu-20-10%E4%B8%8A%E5%AE%89%E8%A3%85Odoo14/"},{"title":"如何在Ubuntu20.04部署Metabase","text":"Metabase是一款简单的开源BI工具。Metabase的两个核心概念是问题及其对应的答案，Metabase一切都基于问题和答案。Metabase有以下特点： 在五分钟内完成设置（我们不是在开玩笑）。 让团队中的任何人在不了解SQL的情况下提出问题。 更复杂的查询可使用SQL编辑器实现。 使用过滤器、自动刷新、全屏和自定义点击行为构建美观的交互式仪表板。 创建清理、注释和组合原始表的模型。 定义规范的细分和指标供您的团队使用。 使用仪表板订阅按计划将数据发送到Slack或电子邮件。 设置警报，让Metabase在您的数据更改时通知您。 在您的应用程序甚至整个元数据库中嵌入图表和仪表板。 官方支持的数据库，以下数据库的官方驱动程序是由Metabase团队进行维护的。付费计划的客户将获得官方支持。 BigQuery (Google Cloud Platform) Druid Google Analytics H2 MongoDB (version 3.6 or higher) MySQL (version 5.7 or higher, as well as MariaDB version 10.2 or higher) Oracle PostgreSQL Presto Redshift (Amazon Web Services) Snowflake SparkSQL SQL Server SQLite Vertica 安装依赖本文使用PostgreSQL数据库作为Metabase的数据库，使用以下命令安装依赖： 1sudo apt-get install openjdk-17-jdk postgresql postgresql-contrib nginx 创建PostgreSQL数据库和数据库用户 通过以下命令登录到PostgreSQL数据库： 1sudo -u postgres psql 创建Superset数据库 1CREATE DATABASE metabase_db; 创建数据库用户 1CREATE USER metabase_user WITH PASSWORD 'password'; 修改数据库链接参数 123ALTER ROLE metabase_user SET client_encoding TO 'utf8';ALTER ROLE metabase_user SET default_transaction_isolation TO 'read committed';ALTER ROLE metabase_user SET timezone TO 'UTC'; superset_user访问管理superset数据库 1GRANT ALL PRIVILEGES ON DATABASE metabase_db TO metabase_user; 配置完成后使用以下命令退出PostgreSQL交互界面 1\\q 安装和配置Metabase 下载最新版的Metabase jar包，当前最新的版本是v0.43.1 1wget https://downloads.metabase.com/v0.43.1/metabase.jar 创建Metabase配置文件mkdir -p /etc/metabase &amp;&amp; sudo vim /etc/metabase/config 1234567891011MB_PASSWORD_COMPLEXITY=strongMB_PASSWORD_LENGTH=10MB_JETTY_HOST=127.0.0.1MB_JETTY_PORT=3000MB_DB_TYPE=postgresMB_DB_DBNAME=metabase_dbMB_DB_PORT=5432MB_DB_USER=metabase_userMB_DB_PASS=passwordMB_DB_HOST=localhostMB_EMOJI_IN_LOGS=false MB_PASSWORD_COMPLEXITY：密码复杂度，可填内容&lt;weak|normal|strong&gt;； MB_PASSWORD_LENGTH：密码最小长度； MB_JETTY_HOST：Metabase绑定的地址； MB_JETTY_HOST：Metabase监听的端口； MB_DB_TYPE：数据库类型，可填内容&lt;postgres|mysql|h2&gt;； MB_DB_DBNAME：数据库名称； MB_DB_PORT：数据库端口； MB_DB_USER：数据库用户； MB_DB_PASS：数据库用户密码； MB_DB_HOST：数据库地址； MB_EMOJI_IN_LOGS：日志中包含表情符号，默认情况下true，可填内容&lt;true|false&gt;； 创建系统日志配置文件/etc/rsyslog.d/metabase.conf 12if $programname == 'metabase' then /var/log/metabase.log&amp; stop 重启系统日志 1sudo systemctl restart rsyslog.service 创建Metabase服务/etc/systemd/system/metabase.service 1234567891011121314151617181920[Unit]Description=Metabase serverAfter=syslog.targetAfter=network.target[Service]WorkingDirectory=/home/metabase/ExecStart=/usr/bin/java -jar /home/metabase/metabase.jarEnvironmentFile=/etc/metabase/configUser=metabaseType=simpleStandardOutput=syslogStandardError=syslogSyslogIdentifier=metabaseSuccessExitStatus=143TimeoutStopSec=120Restart=always[Install]WantedBy=multi-user.target 配置完成后执行以下命令 1sudo systemctl daemon-reload 配置Nginx 12345678server { listen 80; listen [::]:80; server_name your.domain.com; location / { proxy_pass http://127.0.0.1:3000; }} 启动Metabase服务 1sudo systemctl start metabase.service 初始化 打开页面首先进入到以下界面，点击按钮开始初始化实例 配置语言 配置管理员用户 添加数据库，这里我们先不添加 配置匿名信息 配置完成 配置完成后","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu20-04%E9%83%A8%E7%BD%B2Metabase/"},{"title":"如何更新ERP5的业务模板","text":"安装ERP5可参考文档《如何在CentOS 7上安装ERP5》完成安装，安装完成后进入ERP5业务模板目录： 1[root@erp5 ~] cd /opt/slapgrid/9acaca863b17989c02d809a4de0295dd/parts/erp5/ 切换到slapsoft用户： 1[root@erp5 erp5] su slapsoft 从远程仓库更新ERP5代码： 1sh-4.2$ git pull --rebase 更新完成后重建ERP5业务模板： 1sh-4.2$ product/ERP5/bin/genbt5list bt5/ product/ERP5/bootstrap 重建完成后用开发者用户（zope）登录到ERP5，打开下面路径*/erp5/portal_templates/view*，点击右上角Import / Export按钮；点击Update Repository Information更新ERP5业务模板路径；点击选择列表选择Upgrade Business Templates from Repositories，在左边的checkbox上勾选需要更新的业务模板，并点击按钮Upgrade Business Templates from Repositories；等待页面刷新，完成后拉到最底下，点击按钮Validate Installation确定更新。","link":"/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0ERP5%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%A8%A1%E6%9D%BF/"},{"title":"如何还原SQLServer master数据库","text":"注意：SQLServer的master数据库只能还原到版本号相同的SQLServer实例 执行命令select @@version;查询当前SQLServer实例的版本号： 1Microsoft SQL Server 2005 - 9.00.5324.00 备份master数据库执行以下SQL语句，备份master数据库到D:\\master.bak目录： 1BACKUP DATABASE master TO DISK = 'D:\\master.bak' WITH REPLACE; 备份Service Master Key执行以下SQL语句，备份master数据库到D:\\smk.bak目录： 1BACKUP SERVICE MASTER KEY TO FILE=N'D:\\smk.bak' ENCRYPTION BY PASSWORD = 'password'; 进入单用户模式在server中找到SQL Server(MSSQLSERVER)的服务，停止后，在参数项中加入“-m”：如果进入单用户模式之后，却一个用户都不可以登录，可以在服务器上运行“netstat -ano | findstr 1433”查看SQLSERVER的端口，查看是否已经有用户在登录； 还原master数据库打开命令提示符工具输入以下代码还原master数据库 123C:\\&gt; sqlcmd 1&gt; RESTORE DATABASE master FROM DISK='D:\\master.bak' WITH REPLACE; 2&gt; GO 重新启动SQLServer如果还原master数据库后，SQLSERVER的服务无法开启，请注意是否因为备份的实例的master数据库路径与还原的实例的master数据库路径不一致导致的，可查看windows应用程序日志查看报错原因。 1234567891011121314151617181920212223242526272829303132日志名称: Application来源: MSSQLSERVER日期: 2019/8/13 16:38:22事件 ID: 17207任务类别: (2)级别: 错误关键字: 经典用户: 暂缺计算机: test描述:FileMgr::StartLogFiles: Operating system error 2(系统找不到指定的文件。) occurred while creating or opening file 'C:\\Program Files (x86)\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\DATA\\mssqlsystemresource.ldf'. Diagnose and correct the operating system error, and retry the operation.事件 Xml:&lt;Event xmlns=&quot;http://schemas.microsoft.com/win/2004/08/events/event&quot;&gt; &lt;System&gt; &lt;Provider Name=&quot;MSSQLSERVER&quot; /&gt; &lt;EventID Qualifiers=&quot;49152&quot;&gt;17207&lt;/EventID&gt; &lt;Level&gt;2&lt;/Level&gt; &lt;Task&gt;2&lt;/Task&gt; &lt;Keywords&gt;0x80000000000000&lt;/Keywords&gt; &lt;TimeCreated SystemTime=&quot;2019-08-13T08:38:22.403131400Z&quot; /&gt; &lt;EventRecordID&gt;4811&lt;/EventRecordID&gt; &lt;Channel&gt;Application&lt;/Channel&gt; &lt;Computer&gt;test&lt;/Computer&gt; &lt;Security /&gt; &lt;/System&gt; &lt;EventData&gt; &lt;Data&gt;FileMgr::StartLogFiles&lt;/Data&gt; &lt;Data&gt;2(系统找不到指定的文件。)&lt;/Data&gt; &lt;Data&gt;C:\\Program Files (x86)\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\DATA\\mssqlsystemresource.ldf&lt;/Data&gt; &lt;Binary&gt;37430000100000000A0000005000440045002D004A005&lt;/Binary&gt; &lt;/EventData&gt;&lt;/Event&gt; 如果是，可以在命令提示符工具中执行命令 1NET START MSSQLSERVER /f /T3608 把SQLSERVER实例启动到master-only恢复模式，再执行如下列的SQL语句，修改Master数据库中记录的其他的系统数据库的路径记录: 12345678910111213141516171819202122USE master;GOALTER DATABASE mssqlsystemresource MODIFY FILE (NAME=data,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\mssqlsystemresource.mdf' ); ALTER DATABASE mssqlsystemresource MODIFY FILE (NAME=log,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\mssqlsystemresource.ldf' ); ALTER DATABASE mssqlsystemresource SET READ_ONLY; USE master;GOALTER DATABASE model MODIFY FILE (NAME=modeldev,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\model.mdf' ); ALTER DATABASE model MODIFY FILE (NAME=modellog,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\modellog.ldf' );GOUSE master;GOALTER DATABASE msdb MODIFY FILE (NAME=MSDBData,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\msdbdata.mdf' ); ALTER DATABASE msdb MODIFY FILE (NAME=MSDBLog,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\msdblog.ldf' );GOUSE master;GOALTER DATABASE tempdb MODIFY FILE (NAME=tempdev,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\tempdb.mdf' ); ALTER DATABASE tempdb MODIFY FILE (NAME=templog,FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\templog.ldf' );GO 注意“C:\\Program Files\\Microsoft SQL Server\\MSSQL.1\\MSSQL\\Data\\”路径为还原的实例的路径。 执行以上SQL语句后重启服务。 还原Service Master Key1RESTORE SERVICE MASTER KEY FROM FILE=N'D:\\smk.bak' DECRYPTION BY PASSWORD = 'password' FORCE;","link":"/%E5%A6%82%E4%BD%95%E8%BF%98%E5%8E%9FSQLServer-master%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"如何重置Mysql5.7 root密码","text":"分享一个mysql技巧，当你忘记mysql5.7的root密码时，需要重置root密码可以参考以下方法。 修改mysql配置文件以我的服务器为例，我的服务器linux版本为CentOS8，mysql的配置文件默认路径为/etc/my.cnf，修改文件； 123vim /etc/my.cnf## 在[mysqld]中加入下面一行skip-grant-tables 完成后重启mysql的服务； 1systemctl restart mysqld 登录mysql1mysql -uroot 修改配置文件后，这里登录不需要密码； 重置密码1234use mysqlupdate user set authentication_string='' where user='root';flush privileges;alter user 'root'@'localhost' identified by '你的新密码'; 后续工作退出mysql，修改配置文件/etc/my.cnf，删除skip-grant-tables行，重新启动mysqld服务； 1systemctl restart mysqld 至此修改完成。good luck!!! 需要在CentOS8上安装MySQL5.7的可以参考《如何在CentOS8上安装Mysql5.7》。","link":"/%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEMysql5-7-root%E5%AF%86%E7%A0%81/"},{"title":"排查SQL Server中运行缓慢的查询问题","text":"正在执行的慢SQL 12345678910111213141516SELECT req.session_id , req.total_elapsed_time AS duration_ms , req.cpu_time AS cpu_time_ms , req.total_elapsed_time - req.cpu_time AS wait_time , req.logical_reads , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, ((CASE statement_end_offset WHEN -1 THEN DATALENGTH(ST.text) ELSE req.statement_end_offset END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 1, 512) AS statement_text FROM sys.dm_exec_requests AS req CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS STORDER BY total_elapsed_time DESC; 过去执行的慢SQL 123456789101112SELECT t.text, (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time, (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time, ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time, qs.total_logical_reads / qs.execution_count AS avg_logical_reads, qs.total_logical_writes / qs.execution_count AS avg_writes, (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executionsFROM sys.dm_exec_query_stats qs CROSS apply sys.Dm_exec_sql_text (sql_handle) tWHERE t.text like '&lt;Your Query&gt;%'-- Replace &lt;Your Query&gt; with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC","link":"/%E6%8E%92%E6%9F%A5SQL-Server%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%BC%93%E6%85%A2%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"},{"title":"搭建属于自己的SlapOS云平台（一） 安装 SlapOS Master","text":"SlapOS是一种分散的云计算技术，使用Buildout在异构环境中自动部署和配置应用程序。SlapOS支持IaaS，PaaS和SaaS应用程序。 SlapOS Master用于管理SlapOS云平台，提供软件管理，服务实例管理，使用记帐和计费模块等功能，通过SlapOS能很方便地创建想要的服务。关于SlapOS的更多信息可阅览SlapOS的官网。 安装过程安装SlapOS Master过程类似ERP5安装（ERP5安装过程可以参考这里），不同的地方是Buildout配置文件和创建实例的参数。确保在操作以下步骤之前完成SlapOS Node的安装（SlapOS Node的安装可参考这里）。 配置SlapOS在终端输入以下命令： 123456[root@vm ~]# slapos configure local \\ --interface-name eth0 \\ --partition-number 16 \\ --ipv4-local-network 10.0.0.0/24 \\ --daemon-listen-ip 127.0.0.1 \\ --daemon-listen-port 50000 interface-name： Computer Partition使用的网卡， 请根据自己实际的网卡填写， 该网卡需要有ipv6地址。partition-number： SlapOS创建的Computer Partition数量，对于ERP5需要10个左右，这里我们配置16个。ipv4-local-network： Computer Partition使用的网络。daemon-listen-ip： slapos-proxy绑定的地址。daemon-listen-port： slapos-proxy绑定的端口。 完成后输入以下命令格式化Computer Partition： 1[root@vm ~]# slapos node format --now 输出如下： 1234[root@vm ~]# slapos node format --now2018-10-19 14:18:11 slapos[1464] INFO Updating computer2018-10-19 14:18:32 slapos[1464] INFO Posting information to 'http://127.0.0.1:50000'2018-10-19 14:18:32 slapos[1464] INFO slapos successfully prepared the computer. 安装SlapOS获取SlapOS buildout配置文件到本地目录*/opt/buildout* 1[root@vm ~]# mkdir -p /opt/buildout &amp;&amp; cd /opt/buildout 1[root@vm ~]# git clone https://github.com/SlapOS/slapos.git 构建和安装ERP5软件 1[root@vm ~]# slapos supply /opt/buildout/slapos/software/slapos-master/software.cfg local_computer 通过以下命令可以查看buildout日志： 1[root@vm ~]# tail -f /opt/slapos/log/slapos-node-software.log 输入以下命令： 1[root@vm ~]# slapos node software 输出内容如下，则说明软件构建完成： 123[root@vm opt]# slapos node software2018-10-19 14:35:14 slapos[7190] INFO Processing software releases...2018-10-19 14:35:14 slapos[7190] INFO Finished software releases. 创建SlapOS Master实例创建证书颁发机构文件夹输入以下命令，在*/etc/*目录下创建文件夹slapos-ssl文件夹: 1[root@vm ~]# mkdir -pv /etc/slapos-ssl 修改文件夹用户权限： 12[root@vm ~]# chmod 770 -R /etc/slapos-ssl [root@vm ~]# chown -R slapsoft:slapsoft /etc/slapos-ssl 创建SlapOS Master实例参数配置脚本输入以下命令创建脚本 12[root@vm ~]# touch slapos-master-config.py[root@vm ~]# chmod +x slapos-master-config.py 修改脚本内容为以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/opt/slapos/bin/pyimport jsonimport slapos.slap.slapslapos_master_url = 'http://127.0.0.1:50000/'slap = slapos.slap.slap()slap.initializeConnection(slapos_master_url)software_url = '/opt/buildout/slapos/software/slapos-master/software.cfg'computer_id = 'local_computer'parameter_dict = { &quot;zope-partition-dict&quot;: { &quot;activities-node&quot;: { &quot;family&quot;: &quot;activities&quot;, &quot;thread-amount&quot;: 2, &quot;instance-count&quot;: 1, &quot;timerserver-interval&quot;: 1, &quot;port-base&quot;: 2200, }, &quot;distribution-node&quot;: { &quot;family&quot;: &quot;distribution&quot;, &quot;thread-amount&quot;: 1, &quot;instance-count&quot;: 1, &quot;port-base&quot;: 2210, &quot;timerserver-interval&quot;: 1, }, &quot;web-node&quot;: { &quot;family&quot;: &quot;web&quot;, &quot;thread-amount&quot;: 4, &quot;instance-count&quot;: 1, &quot;port-base&quot;: 2230, }, &quot;service-slapos&quot;: { &quot;family&quot;: &quot;service&quot;, &quot;thread-amount&quot;: 2, &quot;instance-count&quot;: 1, &quot;port-base&quot;: 2240, &quot;ssl-authentication&quot;: True, &quot;backend-path&quot;: &quot;/%(site-id)s/portal_slap&quot;, }, },}ca_path = '/etc/slapos-ssl'parameter_dict[&quot;shared-certificate-authority-path&quot;] = ca_pathpartition = slap.registerOpenOrder().request( software_url, &quot;slapos_master&quot;, software_type='default', partition_parameter_kw={ '_': json.dumps(parameter_dict, sort_keys=True, indent=2), })print &quot;SlapOS Master Instance: {0}&quot;.format(partition.getConnectionParameterDict()) 执行脚本创建SlapOS Master实例： 1[root@vm ~]# ./slapos-master-config.py 等待SlapOS Master实例Buildout完成，可通过以下命令查看Buildout日志： 1[root@vm ~]# tail -f /opt/slapos/log/slapos-node-instance.log 等待10-15分钟后重新执行脚本如果输出内容如下表示实例Buildout完成： 123452018-10-19 16:47:39 slapos[13925] INFO Instance requested.State is : started.2018-10-19 16:47:39 slapos[13925] INFO Connection parameters of instance are:2018-10-19 16:47:39 slapos[13925] INFO {'_': '{&quot;hosts-dict&quot;: {&quot;erp5-cloudooo&quot;: &quot;10.0.0.221&quot;, &quot;erp5-smtp&quot;: &quot;127.0.0.2&quot;, &quot;erp5-catalog-0&quot;: &quot;10.0.0.218&quot;, &quot;erp5-memcached-volatile&quot;: &quot;10.0.0.215&quot;, &quot;erp5-memcached-persistent&quot;: &quot;10.0.0.214&quot;}, &quot;site-id&quot;: &quot;erp5&quot;, &quot;monitor-setup-url&quot;: &quot;&quot;, &quot;family-default-v6&quot;: &quot;https://[xxxx:xxx::xxxx]:2151&quot;, &quot;deadlock-debugger-password&quot;: &quot;yzhmrcqk&quot;, &quot;inituser-login&quot;: &quot;zope&quot;, &quot;inituser-password&quot;: &quot;uslxwikz&quot;, &quot;monitor-base-url&quot;: &quot;&quot;, &quot;mariadb-test-database-list&quot;: [&quot;mysql://testuser_0:testpassword0@10.0.0.218:2099/erp5_test_0&quot;], &quot;mariadb-database-list&quot;: [&quot;mysql://user:insecure@10.0.0.218:2099/erp5&quot;], &quot;memcached-volatile-url&quot;: &quot;memcached://10.0.0.215:2013/&quot;, &quot;memcached-persistent-url&quot;: &quot;memcached://10.0.0.214:2003/&quot;, &quot;caucase-http-url&quot;: &quot;http://[xxxx:xxx::xxxx]:8890&quot;, &quot;cloudooo-url&quot;: &quot;http://10.0.0.221:2020/&quot;, &quot;family-default&quot;: &quot;https://10.0.0.211:2151&quot;}'}2018-10-19 16:47:39 slapos[13925] INFO You can rerun the command to get up-to-date information. 修改证书颁发机构文件夹用户权限执行以下命令修改权限： 123[root@vm ~]# cd /etc/slapos-ssl [root@vm ~]# chmod -R 770 cacert.pem crl requests certs crlnumber index.txt newcerts private serial [root@vm ~]# chown -R slapsoft:slapsoft cacert.pem crl requests certs crlnumber index.txt newcerts private serial 重启SlapOS Master实例执行以下命令重启SlapOS Master实例： 1[root@vm ~]# slapos node restart all 至此SlapOS Master安装完成","link":"/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84SlapOS%E4%BA%91%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%AE%89%E8%A3%85-SlapOS-Master/"},{"title":"树莓派4b GPIO引脚图","text":"","link":"/%E6%A0%91%E8%8E%93%E6%B4%BE4b-GPIO%E5%BC%95%E8%84%9A%E5%9B%BE/"},{"title":"树莓派4b Oops - unable to determine board type... model: 17","text":"问题树莓派4b在执行gpio readall出错 12pi@raspberrypi:~ $ gpio readallOops - unable to determine board type... model: 17 当前wiringPi版本： 1234567891011pi@raspberrypi:~ $ gpio -vgpio version: 2.50Copyright (c) 2012-2018 Gordon HendersonThis is free software with ABSOLUTELY NO WARRANTY.For details type: gpio -warrantyRaspberry Pi Details: Type: Unknown17, Revision: 01, Memory: 0MB, Maker: Sony * Device tree is enabled. *--&gt; Raspberry Pi 4 Model B Rev 1.1 * This Raspberry Pi supports user-level GPIO access. 解决方法按以下方法更新wiringPi：http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/更新后wiringPi版本: 1234567891011pi@raspberrypi:/tmp $ gpio -vgpio version: 2.52Copyright (c) 2012-2018 Gordon HendersonThis is free software with ABSOLUTELY NO WARRANTY.For details type: gpio -warrantyRaspberry Pi Details: Type: Pi 4B, Revision: 01, Memory: 2048MB, Maker: Sony * Device tree is enabled. *--&gt; Raspberry Pi 4 Model B Rev 1.1 * This Raspberry Pi supports user-level GPIO access. 执行gpio readall命令： 123456789101112131415161718192021222324252627pi@raspberrypi:/tmp $ gpio readall +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | | | 3.3v | | | 1 || 2 | | | 5v | | | | 2 | 8 | SDA.1 | IN | 1 | 3 || 4 | | | 5v | | | | 3 | 9 | SCL.1 | IN | 1 | 5 || 6 | | | 0v | | | | 4 | 7 | GPIO. 7 | IN | 1 | 7 || 8 | 1 | IN | TxD | 15 | 14 | | | | 0v | | | 9 || 10 | 1 | IN | RxD | 16 | 15 | | 17 | 0 | GPIO. 0 | IN | 0 | 11 || 12 | 0 | IN | GPIO. 1 | 1 | 18 | | 27 | 2 | GPIO. 2 | IN | 0 | 13 || 14 | | | 0v | | | | 22 | 3 | GPIO. 3 | IN | 0 | 15 || 16 | 0 | IN | GPIO. 4 | 4 | 23 | | | | 3.3v | | | 17 || 18 | 0 | IN | GPIO. 5 | 5 | 24 | | 10 | 12 | MOSI | IN | 0 | 19 || 20 | | | 0v | | | | 9 | 13 | MISO | IN | 0 | 21 || 22 | 0 | IN | GPIO. 6 | 6 | 25 | | 11 | 14 | SCLK | IN | 0 | 23 || 24 | 1 | IN | CE0 | 10 | 8 | | | | 0v | | | 25 || 26 | 1 | IN | CE1 | 11 | 7 | | 0 | 30 | SDA.0 | IN | 1 | 27 || 28 | 1 | IN | SCL.0 | 31 | 1 | | 5 | 21 | GPIO.21 | IN | 1 | 29 || 30 | | | 0v | | | | 6 | 22 | GPIO.22 | IN | 1 | 31 || 32 | 0 | IN | GPIO.26 | 26 | 12 | | 13 | 23 | GPIO.23 | IN | 0 | 33 || 34 | | | 0v | | | | 19 | 24 | GPIO.24 | IN | 0 | 35 || 36 | 0 | IN | GPIO.27 | 27 | 16 | | 26 | 25 | GPIO.25 | IN | 0 | 37 || 38 | 0 | IN | GPIO.28 | 28 | 20 | | | | 0v | | | 39 || 40 | 0 | IN | GPIO.29 | 29 | 21 | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+---Pi 4B--+---+------+---------+-----+-----+","link":"/%E6%A0%91%E8%8E%93%E6%B4%BE4b-Oops-unable-to-determine-board-type-model-17/"},{"title":"树莓派4b VNC链接提示Cannot currently show the Desktop","text":"问题树莓派4b在设置VNC后使用VNC Viewer链接后提示：Cannot currently show the Desktop，无法显示桌面。 解决方法开启VNC功能后还需要设置桌面的分辨率，方法如下： 1sudo raspi-config 在菜单选择advanced -&gt; Resolution： 选择要设置的分辨率： 设置完成后选择Finish并重启树莓派，重启后重新连接VNC Viewer即可。","link":"/%E6%A0%91%E8%8E%93%E6%B4%BE4b-VNC%E9%93%BE%E6%8E%A5%E6%8F%90%E7%A4%BACannot-currently-show-the-Desktop/"},{"title":"树莓派4b安装官方系统Raspbian","text":"本文介绍通过NOOBS安装Raspbin系统，New Out Of Box Software (NOOBS)是Raspberry Pi操作系统安装管理器。 准备内容 树莓派4b 树莓派电源 鼠标键盘 Micro HDMI转HDMI线 带HDMI接口的显示器 tf卡 NOOBS（带系统镜像） 安装NOOBS 格式化SD卡，文件系统为FAT，安装完全版的Raspbian至少需要16GB的SD卡空间。 下载NOOBS压缩包。可以在Raspberry Pi网站上下载NOOBS：https://www.raspberrypi.org/downloads/noobs/官方提供两个版本的：NOOBS和NOOBS Lite NOOBS包含Raspbian系统镜像，可离线安装系统； NOOBS Lite不包含Raspbian系统镜像，安装时需要在线下载系统镜像。本文使用NOOBS安装。 下载完成后解压缩文件到SD卡根目录。 安装系统 将SD卡插入树莓派背面的SD卡插槽，链接硬件，最后接通电源。","link":"/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9FRaspbian/"},{"title":"清理SQL Server数据库日志的方法","text":"清理sql server数据库日志方法： 打开查询分析器，输入命令DUMP TRANSACTION 数据库名 WITH NO_LOG 再打开企业管理器–右键你要压缩的数据库–所有任务–收缩数据库–收缩文件–选择日志文件–在收缩方式里选择收缩至: ,这里会给出一个允许收缩到的最小M数,直接输入这个数,确定就可以了。","link":"/%E6%B8%85%E7%90%86SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"物联网ESP8266开发板NodeMcu引脚图","text":"","link":"/%E7%89%A9%E8%81%94%E7%BD%91ESP8266%E5%BC%80%E5%8F%91%E6%9D%BFNodeMcu%E5%BC%95%E8%84%9A%E5%9B%BE/"},{"title":"重新初始化SQL Server错误日志","text":"您可以使用sp_cycle_errorlog存储过程定期重新初始化错误日志： 12EXEC sp_cycle_errorlog ; GO 重新初始化前：重新初始化后：","link":"/%E9%87%8D%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96SQL-Server%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"},{"title":"RuoYi系统如何与SQLServer数据库完美搭配","text":"最近在使用RuoYi系统开发ERP系统，由于需要使用SQLServer数据库来作为系统数据库所以有了今天的文章。 先给出完整代码，包含数据库脚本：https://github.com/elnujuw/RuoYi-SQLServer 本文使用的数据库版本是Microsoft SQL Server 2019，下面将介绍具体实现步骤： ruoyi-admin工程下的pom.xml文件添加SQLServer驱动依赖包 12345&lt;!-- SQLServer驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt; &lt;artifactId&gt;mssql-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 修改application-druid.yml配置文件 修改driverClassName 1driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver 修改主数据源url 1url: jdbc:sqlserver://数据库ip:1433;SelectMethod=cursor;DatabaseName=数据库名称 修改validationQuery 12# 配置检测连接是否有效validationQuery: select 'x' 修改application-druid.yml配置文件 123# PageHelper分页插件pagehelper: helperDialect: sqlserver2012 修改SQL语句函数 ifnull 替换为 isnull 替换find_in_set，例如： 1find_in_set(#{deptId}, ancestors) 替换为 charindex (',' + CONVERT (VARCHAR, #{deptId}), ',' + ancestors) &gt; 0 concat 替换为 ‘’+’’ sysdate() 替换为 getdate() 替换date_format，例如： 1date_format(u.create_time,'%y%m%d') &gt;= date_format(#{params.beginTime},'%y%m%d') 替换为 DATEDIFF(day, u.create_time , #{params.endTime}) &gt;= 0 limit 1 替换为 top(1) 修改代码生成器 修改selectDbTableList 为： 12345678910111213SELECTso.name table_name,sep.value table_comment,so.create_date create_time,so.modify_date update_timeFROMsys.objects AS soLEFT JOIN sys.extended_properties AS sep ON so.object_id = sep.major_idWHEREso.type = 'U'AND sep.minor_id = 0AND so.name NOT LIKE 'qrtz_%' AND so.name NOT LIKE 'gen_%'AND so.name NOT IN (select table_name from gen_table) 修改selectDbTableListByName为： 12345678910111213141516SELECTSO.name table_name,SEP.VALUE table_comment,SO.create_date create_time,SO.modify_date update_timeFROMsys.objects AS SOLEFT JOIN sys.extended_properties AS SEP ON SO.object_id = SEP.major_idWHERESO.type = 'U'AND SEP.minor_id = 0and SO.name NOT LIKE 'qrtz_%' and SO.name NOT LIKE 'gen_%'and SO.name in&lt;foreach collection=&quot;array&quot; item=&quot;name&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{name}&lt;/foreach&gt; 修改selectDbTableColumnsByName为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SELECT a.name AS column_name,(CASE WHEN a.isnullable = 1 THEN 0 ELSE 1 END ) AS is_required,( CASE WHEN ( SELECT COUNT(*) FROM sysobjects WHERE ( name IN ( SELECT name FROM sysindexes WHERE (id = a.id) AND ( indid IN ( SELECT indid FROM sysindexkeys WHERE (id = a.id) AND ( colid IN ( SELECT colid FROM syscolumns WHERE (id = a.id) AND (name = a.name) ) ) ) ) ) ) AND (xtype = 'PK') ) &gt; 0 THEN 1 ELSE 0 END) AS is_pk,a.colorder AS sort,isnull(g.[value], ' ') AS column_comment,(CASE WHEN COLUMNPROPERTY(a.id, a.name, 'IsIdentity') = 1 THEN 1 ELSE 0 END) AS is_increment,b.name AS column_typeFROM syscolumns aLEFT JOIN systypes b ON a.xtype = b.xusertypeINNER JOIN sysobjects d ON a.id = d.id AND d.xtype = 'U' AND d.name &lt;![CDATA[ &lt;&gt; ]]&gt; 'dtproperties'LEFT JOIN syscomments e ON a.cdefault = e.idLEFT JOIN sys.extended_properties g ON a.id = g.major_id AND a.colid = g.minor_id LEFT JOIN sys.extended_properties f ON d.id = f.class AND f.minor_id = 0LEFT JOIN sys.objects h ON a.id = h.object_idLEFT JOIN sys.schemas i ON h.schema_id = i.schema_idWHERE d.name = #{tableName}ORDER BY a.colorder 踩过的坑 使用SQLServer数据库mybatis批量插入时数字可能会丢失精度 解决方法，参考以下批量插入，使用cast(#{item.rate,jdbcType=DECIMAL} as decimal(18,6))如： 123456&lt;insert id=&quot;batchBaseMoneyrateDetail&quot;&gt; insert into base_moneyrate_d( moneyrate_id, item_id, money_id, rate) values &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt; ( #{item.moneyrateId}, #{item.itemId}, #{item.moneyId}, cast(#{item.rate,jdbcType=DECIMAL} as decimal(18,6))) &lt;/foreach&gt;&lt;/insert&gt; 代码生成器导入表没有可选的表数据 原因是数据库表没有设置表说明，解决方法（如角色表，添加表说明）： 12345678910111213141516171819/* 为了防止任何可能出现的数据丢失问题，您应该先仔细检查此脚本，然后再在数据库设计器的上下文之外运行此脚本。*/BEGIN TRANSACTIONSET QUOTED_IDENTIFIER ONSET ARITHABORT ONSET NUMERIC_ROUNDABORT OFFSET CONCAT_NULL_YIELDS_NULL ONSET ANSI_NULLS ONSET ANSI_PADDING ONSET ANSI_WARNINGS ONCOMMITBEGIN TRANSACTIONGODECLARE @v sql_variant SET @v = N'角色表'EXECUTE sp_addextendedproperty N'MS_Description', @v, N'SCHEMA', N'dbo', N'TABLE', N'sys_role', NULL, NULLGOALTER TABLE dbo.sys_role SET (LOCK_ESCALATION = TABLE)GOCOMMIT","link":"/RuoYi%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E4%B8%8ESQLServer%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E7%BE%8E%E6%90%AD%E9%85%8D/"},{"title":"如何在RuoYi-Vue项目中整合积木报表","text":"在本篇博客中，我们将介绍如何在RuoYi-Vue项目中整合积木报表来实现数据可视化和报表功能。 本示例以之前介绍的SQLServer版的RuoYi系统RuoYi-SQLServer为例。 参考官方文档完成1-7步； 前端代码创建API文件 src/api/report/jimu.js： 123456789import request from '@/utils/request'// 报表设计器export function design(query) { return request({ url: '/report/jimu/design', method: 'get' })} 创建页面 src/views/report/jimu/design.vue： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div v-loading=&quot;loading&quot; :style=&quot;'height:'+ height&quot;&gt; &lt;iframe :src=&quot;src&quot; frameborder=&quot;no&quot; style=&quot;width: 100%;height: 100%&quot; scrolling=&quot;auto&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { getToken } from '@/utils/auth' import { design } from '@/api/report/jimu' export default { name: &quot;Ureport&quot;, data() { return { src: &quot;&quot;, height: document.documentElement.clientHeight - 94.5 + &quot;px;&quot;, loading: true, }; }, created() { design().then(res =&gt; { this.src = res + &quot;?token=Bearer &quot; + getToken(); }) }, mounted: function() { setTimeout(() =&gt; { this.loading = false; }, 230); const that = this; window.onresize = function temp() { that.height = document.documentElement.clientHeight - 94.5 + &quot;px;&quot;; }; } };&lt;/script&gt; 添加Token校验 修改后端配置文件application.yml，添加reportUrl： 123ruoyi: # 积木报表访问地址 reportUrl: http://127.0.0.1:8080/ 创建文件：ruoyi-framework\\src\\main\\java\\com\\ruoyi\\framework\\jimu\\JimuController.java： 1234567891011121314151617181920@RestController@RequestMapping(&quot;/report/jimu&quot;)public class JimuController { @Autowired Environment environment; @GetMapping(&quot;/design&quot;) @PreAuthorize(&quot;@ss.hasPermi('report:jimu:design')&quot;) public String design() { return environment.getProperty(&quot;ruoyi.reportUrl&quot;) + &quot;jmreport/list&quot;; } @GetMapping(&quot;/view&quot;) @PreAuthorize(&quot;@ss.hasPermi('report:jimu:view')&quot;) public String view(){ return environment.getProperty(&quot;ruoyi.reportUrl&quot;)+&quot;/jmreport/view&quot;; }} 创建文件：ruoyi-framework\\src\\main\\java\\com\\ruoyi\\framework\\jimu\\JimuReportTokenService.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Componentpublic class JimuReportTokenService implements JmReportTokenServiceI { @Autowired private TokenService tokenService; @Autowired private ISysUserService iSysUserService; @Override public String getUsername(String token) { LoginUser loginUser = tokenService.getLoginUserFromToken(token); return loginUser.getUsername(); } @Override public String[] getRoles(String s) { return new String[0]; } // 校验token @Override public Boolean verifyToken(String token) { if(token !=null &amp;&amp; token.length()&gt;0){ //这个获得的token 是带前缀的，所以需要新加一个一个方法,处理token，再返回loginUser LoginUser loginUser = tokenService.getLoginUserFromToken(token); if (StringUtils.isNotNull(loginUser)) { return true; } } return false; } @Override public String getToken(HttpServletRequest request) { String token = request.getParameter(&quot;token&quot;); String jmToken = request.getHeader(&quot;token&quot;); if (token == null || token.length() == 0) { token = jmToken; } if (token != null &amp;&amp; token.length() &gt; 0) { return token; } return &quot;&quot;; } @Override public String getToken() { return JmReportTokenServiceI.super.getToken(); } @Override public Map&lt;String, Object&gt; getUserInfo(String token) { Map&lt;String, Object&gt; map = new HashMap(5); LoginUser loginUser = tokenService.getLoginUserFromToken(token); //设置用户名 map.put(SYS_USER_CODE, loginUser.getUsername()); //设置部门编码 map.put(SYS_ORG_CODE, loginUser.getDeptId()); // 将所有信息存放至map 解析sql/api会根据map的键值解析 return map; } @Override public HttpHeaders customApiHeader() { HttpHeaders header = new HttpHeaders(); header.add(&quot;Authorization&quot;, getToken()); header.add(&quot;X-Access-Token&quot;, getToken()); return header; } @Override public String getTenantId() { return JmReportTokenServiceI.super.getTenantId(); }} 修改tokenService，添加方法： 123456789101112131415161718192021222324252627/** * 根据 token，获取用户信息 * Bearer + gettoken() */public LoginUser getLoginUserFromToken(String token) { if (StringUtils.isNotEmpty(token)) { //处理token if (StringUtils.isNotEmpty(token) &amp;&amp; token.startsWith(Constants.TOKEN_PREFIX)) { token = token.replace(Constants.TOKEN_PREFIX, &quot;&quot;); } try { Claims claims = parseToken(token); // 解析对应的权限以及用户信息 String uuid = (String) claims.get(Constants.LOGIN_USER_KEY); String userKey = getTokenKey(uuid); LoginUser user = redisCache.getCacheObject(userKey); return user; } catch (Exception e) { } } return null;} 创建自定义拦截器，检查是否有权限：ruoyi-framework\\src\\main\\java\\com\\ruoyi\\framework\\jimu\\JimuInterceptor.java： 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class JimuInterceptor implements HandlerInterceptor { @Autowired private TokenService tokenService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(&quot;token&quot;); if (StringUtils.isEmpty(token)) { token = request.getHeader(&quot;Token&quot;); } LoginUser loginUser = tokenService.getLoginUserFromToken(token); if (loginUser != null) { // 超级管理员无需鉴权 if (loginUser.getUser() != null &amp;&amp; loginUser.getUser().isAdmin()) { return true; } else { // 获取权限集合 Set&lt;String&gt; permissions = loginUser.getPermissions(); // 如果拥有设计器的权限，则无需view权限也可以通过校验 if (permissions != null &amp;&amp; permissions.contains(&quot;report:jimu:design&quot;)) { return true; } // 其余情况，一般是通过报表菜单点击进来的，校验对应报表的权限：report:jimu:view:{reportId} // http://.../jmreport/view/1234567890，则reportId = 1234567890 String reportId = StringUtils.substringAfterLast(request.getRequestURI(), &quot;/&quot;); String viewPerm = &quot;report:jimu:view:&quot; + reportId; if (permissions != null &amp;&amp; permissions.contains(viewPerm)) { return true; } } } AjaxResult ajaxResult = AjaxResult.error(&quot;参数错误或没有改报表的访问权限！&quot;); ServletUtils.renderString(response, JSONObject.toJSONString(ajaxResult)); return false; }} ResourcesConfig中注册自定义拦截器 12345678910/** * 自定义拦截规则 */@Overridepublic void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;); // 添加下面一行 registry.addInterceptor(jimuInterceptor).addPathPatterns(&quot;/jmreport/**&quot;);} 添加菜单 效果","link":"/%E5%A6%82%E4%BD%95%E5%9C%A8RuoYi-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%95%B4%E5%90%88%E7%A7%AF%E6%9C%A8%E6%8A%A5%E8%A1%A8/"}],"tags":[{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"ERP5","slug":"ERP5","link":"/tags/ERP5/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ESP8266","slug":"ESP8266","link":"/tags/ESP8266/"},{"name":"Arduino","slug":"Arduino","link":"/tags/Arduino/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Odoo","slug":"Odoo","link":"/tags/Odoo/"},{"name":"Odoo开发者指南","slug":"Odoo开发者指南","link":"/tags/Odoo%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/tags/PostgreSQL/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SQLServer","slug":"SQLServer","link":"/tags/SQLServer/"},{"name":"RaspberryPI","slug":"RaspberryPI","link":"/tags/RaspberryPI/"},{"name":"OpenWRT","slug":"OpenWRT","link":"/tags/OpenWRT/"},{"name":"Zope","slug":"Zope","link":"/tags/Zope/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"工具分享","slug":"工具分享","link":"/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"SlapOS","slug":"SlapOS","link":"/tags/SlapOS/"},{"name":"Chart.js","slug":"Chart-js","link":"/tags/Chart-js/"},{"name":"数据可视化","slug":"数据可视化","link":"/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"Superset","slug":"Superset","link":"/tags/Superset/"},{"name":"Metabase","slug":"Metabase","link":"/tags/Metabase/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"RuoYi","slug":"RuoYi","link":"/tags/RuoYi/"}],"categories":[],"pages":[{"title":"tags","text":"","link":"/tags/index.html"}]}